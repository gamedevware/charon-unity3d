











// file path is ProjectSetting.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class ProjectSetting : Document, IEquatable<ProjectSetting>, IComparable, IComparable<ProjectSetting>
	{
		private readonly int hashCode;

		public string Id { get; }
		public string Name { get; }
		public string PrimaryLanguage { get; }
		public string Languages { get; }
		public string Copyright { get; }
		public string Version { get; }
		/// <summary>
		/// Constructor for ProjectSetting.
		/// </summary>
		public ProjectSetting(string id, string name, string primaryLanguage, string languages, string copyright, string version)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.Name = name;
			this.PrimaryLanguage = primaryLanguage;
			this.Languages = languages;
			this.Copyright = copyright;
			this.Version = version;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(ProjectSetting other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is ProjectSetting == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (ProjectSetting)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.Name, other.Name)
				&& AreEquals(this.PrimaryLanguage, other.PrimaryLanguage)
				&& AreEquals(this.Languages, other.Languages)
				&& AreEquals(this.Copyright, other.Copyright)
				&& AreEquals(this.Version, other.Version)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as ProjectSetting);
		}
		/// <inheritdoc />
		public int CompareTo(ProjectSetting other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(ProjectSetting value1, ProjectSetting value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(ProjectSetting value1, ProjectSetting value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.Name)
				+ GetHashCodeFor(this.PrimaryLanguage)
				+ GetHashCodeFor(this.Languages)
				+ GetHashCodeFor(this.Copyright)
				+ GetHashCodeFor(this.Version)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Project Name: ").Append(this.Name).Append(", ");
				sb.Append("Primary Language: ").Append(this.PrimaryLanguage).Append(", ");
				sb.Append("Languages: ").Append(this.Languages).Append(", ");
				sb.Append("Copyright: ").Append(this.Copyright).Append(", ");
				sb.Append("Version: ").Append(this.Version).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Parameter.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Parameter : Document, IEquatable<Parameter>, IComparable, IComparable<Parameter>
	{
		private readonly int hashCode;

		public ParameterId Id { get; }
		/// <summary>
		/// Maximal value for this attribute.
		/// </summary>
		public Nullable<float> MinValue { get; }
		/// <summary>
		/// Maximal value for this attribute.
		/// </summary>
		public Nullable<float> MaxValue { get; }
		public Parameter MinValueParameter => this.MinValueParameterRaw.Dereference();
		public DocumentReference<Parameter> MinValueParameterRaw { get; }
		public Parameter MaxValueParameter => this.MaxValueParameterRaw.Dereference();
		public DocumentReference<Parameter> MaxValueParameterRaw { get; }
		public ParameterValueKind ValueKind { get; }
		/// <summary>
		/// Constructor for Parameter.
		/// </summary>
		public Parameter(ParameterId id, Nullable<float> minValue, Nullable<float> maxValue, DocumentReference<Parameter> minValueParameter, DocumentReference<Parameter> maxValueParameter, ParameterValueKind valueKind)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.MinValue = minValue;
			this.MaxValue = maxValue;
			this.MinValueParameterRaw = minValueParameter;
			this.MaxValueParameterRaw = maxValueParameter;
			this.ValueKind = valueKind;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Parameter other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Parameter == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Parameter)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.MinValue, other.MinValue)
				&& AreEquals(this.MaxValue, other.MaxValue)
				&& AreEquals(this.MinValueParameterRaw, other.MinValueParameterRaw)
				&& AreEquals(this.MaxValueParameterRaw, other.MaxValueParameterRaw)
				&& AreEquals(this.ValueKind, other.ValueKind)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Parameter);
		}
		/// <inheritdoc />
		public int CompareTo(Parameter other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(Parameter value1, Parameter value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Parameter value1, Parameter value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.MinValue)
				+ GetHashCodeFor(this.MaxValue)
				+ GetHashCodeFor(this.MinValueParameterRaw)
				+ GetHashCodeFor(this.MaxValueParameterRaw)
				+ GetHashCodeFor(this.ValueKind)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Min Value: ").Append(this.MinValue).Append(", ");
				sb.Append("Max Value: ").Append(this.MaxValue).Append(", ");
				sb.Append("Min Value Parameter: ").Append(this.MinValueParameterRaw).Append(", ");
				sb.Append("Max Value Parameter: ").Append(this.MaxValueParameterRaw).Append(", ");
				sb.Append("Value Kind: ").Append(this.ValueKind).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is ParameterValue.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class ParameterValue : Document, IEquatable<ParameterValue>, IComparable, IComparable<ParameterValue>
	{
		private readonly int hashCode;

		public int Id { get; }
		public Parameter Parameter => this.ParameterRaw.Dereference();
		public DocumentReference<Parameter> ParameterRaw { get; }
		public float Value { get; }
		public Condition Condition => this.ConditionRaw.Dereference();
		public DocumentReference<Condition> ConditionRaw { get; }
		/// <summary>
		/// Constructor for ParameterValue.
		/// </summary>
		public ParameterValue(int id, DocumentReference<Parameter> parameter, float @value, DocumentReference<Condition> condition)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.ParameterRaw = parameter;
			this.Value = @value;
			this.ConditionRaw = condition;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(ParameterValue other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is ParameterValue == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (ParameterValue)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.ParameterRaw, other.ParameterRaw)
				&& AreEquals(this.Value, other.Value)
				&& AreEquals(this.ConditionRaw, other.ConditionRaw)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as ParameterValue);
		}
		/// <inheritdoc />
		public int CompareTo(ParameterValue other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(ParameterValue value1, ParameterValue value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(ParameterValue value1, ParameterValue value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.ParameterRaw)
				+ GetHashCodeFor(this.Value)
				+ GetHashCodeFor(this.ConditionRaw)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Parameter: ").Append(this.ParameterRaw).Append(", ");
				sb.Append("Value: ").Append(this.Value).Append(", ");
				sb.Append("Condition: ").Append(this.ConditionRaw).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Provision.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Provision : Document, IEquatable<Provision>, IComparable, IComparable<Provision>
	{
		private readonly int hashCode;

		public string Id { get; }
		/// <summary>
		/// Cost of provision in gold.
		/// </summary>
		public int Cost { get; }
		public Item Item { get; }
		/// <summary>
		/// Constructor for Provision.
		/// </summary>
		public Provision(string id, int cost, Item item)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.Cost = cost;
			this.Item = item;
			SetParent(this.Item, this);
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Provision other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Provision == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Provision)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.Cost, other.Cost)
				&& AreEquals(this.Item, other.Item)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Provision);
		}
		/// <inheritdoc />
		public int CompareTo(Provision other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Provision value1, Provision value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Provision value1, Provision value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.Cost)
				+ GetHashCodeFor(this.Item)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Cost: ").Append(this.Cost).Append(", ");
				sb.Append("Item: ").Append(this.Item).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Hero.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Hero : Document, IEquatable<Hero>, IComparable, IComparable<Hero>
	{
		private readonly int hashCode;

		public string Id { get; }
		public string Name => this.NameRaw.Value;
		public LocalizedString NameRaw { get; }
		public string Bio => this.BioRaw.Value;
		public LocalizedString BioRaw { get; }
		public bool Religious { get; }
		/// <summary>
		/// List of heroes which dislikes current hero.
		/// </summary>
		public DocumentCollection<string,Hero> DislikeHeroes => this.DislikeHeroesRaw.Dereference(document => document.Id);
		public DocumentReferenceCollection<Hero> DislikeHeroesRaw { get; }
		public Provision Provisions => this.ProvisionsRaw.Dereference();
		public DocumentReference<Provision> ProvisionsRaw { get; }
		public int ProvisionsCount { get; }
		/// <summary>
		/// Maximum possible change in the position of the hero. Direction - forward.
		/// </summary>
		public int MovementForward { get; }
		/// <summary>
		/// Maximum possible change in the position of the hero. Direction - backward.
		/// </summary>
		public int MovementBackward { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public int Protection { get; }
		public int AccuracyModifier { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float StunResistance { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float BlightResistance { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float DiseaseResistance { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float DeathBlowResistance { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float MoveResistance { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float BleedResistance { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float DebuffResistance { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float TrapResistance { get; }
		public DocumentCollection<string,Armor> Armors { get; }
		public DocumentCollection<string,Weapon> Weapons { get; }
		/// <summary>
		/// Constructor for Hero.
		/// </summary>
		public Hero(string id, LocalizedString name, LocalizedString bio, bool religious, DocumentReferenceCollection<Hero> dislikeHeroes, DocumentReference<Provision> provisions, int provisionsCount, int movementForward, int movementBackward, int protection, int accuracyModifier, float stunResistance, float blightResistance, float diseaseResistance, float deathBlowResistance, float moveResistance, float bleedResistance, float debuffResistance, float trapResistance, DocumentCollection<string,Armor> armors, DocumentCollection<string,Weapon> weapons)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.NameRaw = name;
			this.BioRaw = bio;
			this.Religious = religious;
			this.DislikeHeroesRaw = dislikeHeroes;
			this.ProvisionsRaw = provisions;
			this.ProvisionsCount = provisionsCount;
			this.MovementForward = movementForward;
			this.MovementBackward = movementBackward;
			this.Protection = protection;
			this.AccuracyModifier = accuracyModifier;
			this.StunResistance = stunResistance;
			this.BlightResistance = blightResistance;
			this.DiseaseResistance = diseaseResistance;
			this.DeathBlowResistance = deathBlowResistance;
			this.MoveResistance = moveResistance;
			this.BleedResistance = bleedResistance;
			this.DebuffResistance = debuffResistance;
			this.TrapResistance = trapResistance;
			this.Armors = armors;
			this.Weapons = weapons;
			foreach (var document in this.Armors) { SetParent(document, this); }
			foreach (var document in this.Weapons) { SetParent(document, this); }
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Hero other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Hero == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Hero)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.NameRaw, other.NameRaw)
				&& AreEquals(this.BioRaw, other.BioRaw)
				&& AreEquals(this.Religious, other.Religious)
				&& AreEquals(this.DislikeHeroesRaw, other.DislikeHeroesRaw)
				&& AreEquals(this.ProvisionsRaw, other.ProvisionsRaw)
				&& AreEquals(this.ProvisionsCount, other.ProvisionsCount)
				&& AreEquals(this.MovementForward, other.MovementForward)
				&& AreEquals(this.MovementBackward, other.MovementBackward)
				&& AreEquals(this.Protection, other.Protection)
				&& AreEquals(this.AccuracyModifier, other.AccuracyModifier)
				&& AreEquals(this.StunResistance, other.StunResistance)
				&& AreEquals(this.BlightResistance, other.BlightResistance)
				&& AreEquals(this.DiseaseResistance, other.DiseaseResistance)
				&& AreEquals(this.DeathBlowResistance, other.DeathBlowResistance)
				&& AreEquals(this.MoveResistance, other.MoveResistance)
				&& AreEquals(this.BleedResistance, other.BleedResistance)
				&& AreEquals(this.DebuffResistance, other.DebuffResistance)
				&& AreEquals(this.TrapResistance, other.TrapResistance)
				&& AreEquals(this.Armors, other.Armors)
				&& AreEquals(this.Weapons, other.Weapons)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Hero);
		}
		/// <inheritdoc />
		public int CompareTo(Hero other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Hero value1, Hero value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Hero value1, Hero value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.NameRaw)
				+ GetHashCodeFor(this.BioRaw)
				+ GetHashCodeFor(this.Religious)
				+ GetHashCodeFor(this.DislikeHeroesRaw)
				+ GetHashCodeFor(this.ProvisionsRaw)
				+ GetHashCodeFor(this.ProvisionsCount)
				+ GetHashCodeFor(this.MovementForward)
				+ GetHashCodeFor(this.MovementBackward)
				+ GetHashCodeFor(this.Protection)
				+ GetHashCodeFor(this.AccuracyModifier)
				+ GetHashCodeFor(this.StunResistance)
				+ GetHashCodeFor(this.BlightResistance)
				+ GetHashCodeFor(this.DiseaseResistance)
				+ GetHashCodeFor(this.DeathBlowResistance)
				+ GetHashCodeFor(this.MoveResistance)
				+ GetHashCodeFor(this.BleedResistance)
				+ GetHashCodeFor(this.DebuffResistance)
				+ GetHashCodeFor(this.TrapResistance)
				+ GetHashCodeFor(this.Armors)
				+ GetHashCodeFor(this.Weapons)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Name: ").Append(this.NameRaw).Append(", ");
				sb.Append("Bio: ").Append(this.BioRaw).Append(", ");
				sb.Append("Religious: ").Append(this.Religious).Append(", ");
				sb.Append("Dislike Heroes: ").Append(this.DislikeHeroesRaw).Append(", ");
				sb.Append("Provisions: ").Append(this.ProvisionsRaw).Append(", ");
				sb.Append("Provisions Count: ").Append(this.ProvisionsCount).Append(", ");
				sb.Append("Movement Forward: ").Append(this.MovementForward).Append(", ");
				sb.Append("Movement Backward: ").Append(this.MovementBackward).Append(", ");
				sb.Append("Protection: ").Append(this.Protection).Append(", ");
				sb.Append("Accuracy Modifier: ").Append(this.AccuracyModifier).Append(", ");
				sb.Append("Stun Resistance: ").Append(this.StunResistance).Append(", ");
				sb.Append("Blight Resistance: ").Append(this.BlightResistance).Append(", ");
				sb.Append("Disease Resistance: ").Append(this.DiseaseResistance).Append(", ");
				sb.Append("Death Blow Resistance: ").Append(this.DeathBlowResistance).Append(", ");
				sb.Append("Move Resistance: ").Append(this.MoveResistance).Append(", ");
				sb.Append("Bleed Resistance: ").Append(this.BleedResistance).Append(", ");
				sb.Append("Debuff Resistance: ").Append(this.DebuffResistance).Append(", ");
				sb.Append("Trap Resistance: ").Append(this.TrapResistance).Append(", ");
				sb.Append("Armors: ").Append(this.Armors).Append(", ");
				sb.Append("Weapons: ").Append(this.Weapons).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Item.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Item : Document, IEquatable<Item>, IComparable, IComparable<Item>
	{
		private readonly int hashCode;

		public string Id { get; }
		public string Name => this.NameRaw.Value;
		public LocalizedString NameRaw { get; }
		public string Description => this.DescriptionRaw.Value;
		public LocalizedString DescriptionRaw { get; }
		/// <summary>
		/// Zero and one mean - non stackable.
		/// </summary>
		public int StackSize { get; }
		/// <summary>
		/// Gold value of treasure. Rewared upon completion of mission.
		/// </summary>
		public int GoldValue { get; }
		public DocumentCollection<int,ParameterValue> ActivationEffects { get; }
		/// <summary>
		/// Constructor for Item.
		/// </summary>
		public Item(string id, LocalizedString name, LocalizedString description, int stackSize, int goldValue, DocumentCollection<int,ParameterValue> activationEffects)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.NameRaw = name;
			this.DescriptionRaw = description;
			this.StackSize = stackSize;
			this.GoldValue = goldValue;
			this.ActivationEffects = activationEffects;
			foreach (var document in this.ActivationEffects) { SetParent(document, this); }
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Item other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Item == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Item)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.NameRaw, other.NameRaw)
				&& AreEquals(this.DescriptionRaw, other.DescriptionRaw)
				&& AreEquals(this.StackSize, other.StackSize)
				&& AreEquals(this.GoldValue, other.GoldValue)
				&& AreEquals(this.ActivationEffects, other.ActivationEffects)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Item);
		}
		/// <inheritdoc />
		public int CompareTo(Item other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Item value1, Item value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Item value1, Item value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.NameRaw)
				+ GetHashCodeFor(this.DescriptionRaw)
				+ GetHashCodeFor(this.StackSize)
				+ GetHashCodeFor(this.GoldValue)
				+ GetHashCodeFor(this.ActivationEffects)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Name: ").Append(this.NameRaw).Append(", ");
				sb.Append("Description: ").Append(this.DescriptionRaw).Append(", ");
				sb.Append("Stack Size: ").Append(this.StackSize).Append(", ");
				sb.Append("Gold Value: ").Append(this.GoldValue).Append(", ");
				sb.Append("Activation Effects: ").Append(this.ActivationEffects).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Location.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Location : Document, IEquatable<Location>, IComparable, IComparable<Location>
	{
		private readonly int hashCode;

		public string Id { get; }
		public string Name => this.NameRaw.Value;
		public LocalizedString NameRaw { get; }
		public Nullable<LocationFlags> Flags { get; }
		/// <summary>
		/// Constructor for Location.
		/// </summary>
		public Location(string id, LocalizedString name, Nullable<LocationFlags> flags)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.NameRaw = name;
			this.Flags = flags;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Location other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Location == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Location)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.NameRaw, other.NameRaw)
				&& AreEquals(this.Flags, other.Flags)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Location);
		}
		/// <inheritdoc />
		public int CompareTo(Location other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Location value1, Location value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Location value1, Location value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.NameRaw)
				+ GetHashCodeFor(this.Flags)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Name: ").Append(this.NameRaw).Append(", ");
				sb.Append("Flags: ").Append(this.Flags).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Trinket.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Trinket : Document, IEquatable<Trinket>, IComparable, IComparable<Trinket>
	{
		private readonly int hashCode;

		public string Id { get; }
		public TrinketRarity Rarity { get; }
		public Location OriginDungeon => this.OriginDungeonRaw.Dereference();
		public DocumentReference<Location> OriginDungeonRaw { get; }
		public Hero HeroRestriction => this.HeroRestrictionRaw.Dereference();
		public DocumentReference<Hero> HeroRestrictionRaw { get; }
		public Item Item { get; }
		public DocumentCollection<int,ParameterValue> Effects { get; }
		/// <summary>
		/// Constructor for Trinket.
		/// </summary>
		public Trinket(string id, TrinketRarity rarity, DocumentReference<Location> originDungeon, DocumentReference<Hero> heroRestriction, Item item, DocumentCollection<int,ParameterValue> effects)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.Rarity = rarity;
			this.OriginDungeonRaw = originDungeon;
			this.HeroRestrictionRaw = heroRestriction;
			this.Item = item;
			this.Effects = effects;
			SetParent(this.Item, this);
			foreach (var document in this.Effects) { SetParent(document, this); }
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Trinket other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Trinket == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Trinket)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.Rarity, other.Rarity)
				&& AreEquals(this.OriginDungeonRaw, other.OriginDungeonRaw)
				&& AreEquals(this.HeroRestrictionRaw, other.HeroRestrictionRaw)
				&& AreEquals(this.Item, other.Item)
				&& AreEquals(this.Effects, other.Effects)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Trinket);
		}
		/// <inheritdoc />
		public int CompareTo(Trinket other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Trinket value1, Trinket value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Trinket value1, Trinket value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.Rarity)
				+ GetHashCodeFor(this.OriginDungeonRaw)
				+ GetHashCodeFor(this.HeroRestrictionRaw)
				+ GetHashCodeFor(this.Item)
				+ GetHashCodeFor(this.Effects)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Rarity: ").Append(this.Rarity).Append(", ");
				sb.Append("Origin Dungeon: ").Append(this.OriginDungeonRaw).Append(", ");
				sb.Append("Hero Restriction: ").Append(this.HeroRestrictionRaw).Append(", ");
				sb.Append("Item: ").Append(this.Item).Append(", ");
				sb.Append("Effects: ").Append(this.Effects).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Monster.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Monster : Document, IEquatable<Monster>, IComparable, IComparable<Monster>
	{
		private readonly int hashCode;

		public string Id { get; }
		public string Name => this.NameRaw.Value;
		public LocalizedString NameRaw { get; }
		public MonsterType Type { get; }
		public Nullable<MonsterType> SecondType { get; }
		public DocumentCollection<int,ParameterValue> Parameters { get; }
		public DocumentCollection<string,Location> Locations => this.LocationsRaw.Dereference(document => document.Id);
		public DocumentReferenceCollection<Location> LocationsRaw { get; }
		/// <summary>
		/// Constructor for Monster.
		/// </summary>
		public Monster(string id, LocalizedString name, MonsterType type, Nullable<MonsterType> secondType, DocumentCollection<int,ParameterValue> parameters, DocumentReferenceCollection<Location> locations)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.NameRaw = name;
			this.Type = type;
			this.SecondType = secondType;
			this.Parameters = parameters;
			this.LocationsRaw = locations;
			foreach (var document in this.Parameters) { SetParent(document, this); }
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Monster other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Monster == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Monster)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.NameRaw, other.NameRaw)
				&& AreEquals(this.Type, other.Type)
				&& AreEquals(this.SecondType, other.SecondType)
				&& AreEquals(this.Parameters, other.Parameters)
				&& AreEquals(this.LocationsRaw, other.LocationsRaw)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Monster);
		}
		/// <inheritdoc />
		public int CompareTo(Monster other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Monster value1, Monster value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Monster value1, Monster value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.NameRaw)
				+ GetHashCodeFor(this.Type)
				+ GetHashCodeFor(this.SecondType)
				+ GetHashCodeFor(this.Parameters)
				+ GetHashCodeFor(this.LocationsRaw)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Name: ").Append(this.NameRaw).Append(", ");
				sb.Append("Type: ").Append(this.Type).Append(", ");
				sb.Append("Second Type: ").Append(this.SecondType).Append(", ");
				sb.Append("Parameters: ").Append(this.Parameters).Append(", ");
				sb.Append("Locations: ").Append(this.LocationsRaw).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Loot.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Loot : Document, IEquatable<Loot>, IComparable, IComparable<Loot>
	{
		private readonly int hashCode;

		public int Id { get; }
		public LootType Type { get; }
		public Nullable<int> Amount { get; }
		/// <summary>
		/// Constructor for Loot.
		/// </summary>
		public Loot(int id, LootType type, Nullable<int> amount)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.Type = type;
			this.Amount = amount;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Loot other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Loot == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Loot)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.Type, other.Type)
				&& AreEquals(this.Amount, other.Amount)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Loot);
		}
		/// <inheritdoc />
		public int CompareTo(Loot other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(Loot value1, Loot value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Loot value1, Loot value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.Type)
				+ GetHashCodeFor(this.Amount)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Type: ").Append(this.Type).Append(", ");
				sb.Append("Amount: ").Append(this.Amount).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is CombatEffect.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class CombatEffect : Document, IEquatable<CombatEffect>, IComparable, IComparable<CombatEffect>
	{
		private readonly int hashCode;

		public int Id { get; }
		public DocumentCollection<int,ParameterValue> Changes { get; }
		/// <summary>
		/// zero or empty - effect is permanent.
		/// </summary>
		public Nullable<int> Duration { get; }
		public DurationUnit DurationUnit { get; }
		/// <summary>
		/// Constructor for CombatEffect.
		/// </summary>
		public CombatEffect(int id, DocumentCollection<int,ParameterValue> changes, Nullable<int> duration, DurationUnit durationUnit)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.Changes = changes;
			this.Duration = duration;
			this.DurationUnit = durationUnit;
			foreach (var document in this.Changes) { SetParent(document, this); }
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(CombatEffect other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is CombatEffect == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (CombatEffect)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.Changes, other.Changes)
				&& AreEquals(this.Duration, other.Duration)
				&& AreEquals(this.DurationUnit, other.DurationUnit)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as CombatEffect);
		}
		/// <inheritdoc />
		public int CompareTo(CombatEffect other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(CombatEffect value1, CombatEffect value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(CombatEffect value1, CombatEffect value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.Changes)
				+ GetHashCodeFor(this.Duration)
				+ GetHashCodeFor(this.DurationUnit)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Changes: ").Append(this.Changes).Append(", ");
				sb.Append("Duration: ").Append(this.Duration).Append(", ");
				sb.Append("Duration Unit: ").Append(this.DurationUnit).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is CurioCleansingOption.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class CurioCleansingOption : Document, IEquatable<CurioCleansingOption>, IComparable, IComparable<CurioCleansingOption>
	{
		private readonly int hashCode;

		public int Id { get; }
		/// <summary>
		/// Chance of happening of this cleansing option relative to other options.
		/// </summary>
		public float Chance { get; }
		/// <summary>
		/// Cleansing item.
		/// </summary>
		public Item Item => this.ItemRaw.Dereference();
		public DocumentReference<Item> ItemRaw { get; }
		public DocumentCollection<int,Loot> Loot { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%. Positive value is for positive quirks and negative for negative quirks.
		/// </summary>
		public Nullable<float> QuirkChance { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public Nullable<float> DiseaseChance { get; }
		public DocumentCollection<int,ParameterValue> Effects { get; }
		public bool ItemIsConsumed { get; }
		/// <summary>
		/// Constructor for CurioCleansingOption.
		/// </summary>
		public CurioCleansingOption(int id, float chance, DocumentReference<Item> item, DocumentCollection<int,Loot> loot, Nullable<float> quirkChance, Nullable<float> diseaseChance, DocumentCollection<int,ParameterValue> effects, bool itemIsConsumed)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.Chance = chance;
			this.ItemRaw = item;
			this.Loot = loot;
			this.QuirkChance = quirkChance;
			this.DiseaseChance = diseaseChance;
			this.Effects = effects;
			this.ItemIsConsumed = itemIsConsumed;
			foreach (var document in this.Loot) { SetParent(document, this); }
			foreach (var document in this.Effects) { SetParent(document, this); }
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(CurioCleansingOption other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is CurioCleansingOption == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (CurioCleansingOption)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.Chance, other.Chance)
				&& AreEquals(this.ItemRaw, other.ItemRaw)
				&& AreEquals(this.Loot, other.Loot)
				&& AreEquals(this.QuirkChance, other.QuirkChance)
				&& AreEquals(this.DiseaseChance, other.DiseaseChance)
				&& AreEquals(this.Effects, other.Effects)
				&& AreEquals(this.ItemIsConsumed, other.ItemIsConsumed)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as CurioCleansingOption);
		}
		/// <inheritdoc />
		public int CompareTo(CurioCleansingOption other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(CurioCleansingOption value1, CurioCleansingOption value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(CurioCleansingOption value1, CurioCleansingOption value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.Chance)
				+ GetHashCodeFor(this.ItemRaw)
				+ GetHashCodeFor(this.Loot)
				+ GetHashCodeFor(this.QuirkChance)
				+ GetHashCodeFor(this.DiseaseChance)
				+ GetHashCodeFor(this.Effects)
				+ GetHashCodeFor(this.ItemIsConsumed)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Chance: ").Append(this.Chance).Append(", ");
				sb.Append("Item: ").Append(this.ItemRaw).Append(", ");
				sb.Append("Loot: ").Append(this.Loot).Append(", ");
				sb.Append("Quirk Chance: ").Append(this.QuirkChance).Append(", ");
				sb.Append("Disease Chance: ").Append(this.DiseaseChance).Append(", ");
				sb.Append("Effects: ").Append(this.Effects).Append(", ");
				sb.Append("Item Is Consumed: ").Append(this.ItemIsConsumed).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Curio.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Curio : Document, IEquatable<Curio>, IComparable, IComparable<Curio>
	{
		private readonly int hashCode;

		public string Id { get; }
		public CurioType Type { get; }
		public string Name => this.NameRaw.Value;
		public LocalizedString NameRaw { get; }
		public string Description => this.DescriptionRaw.Value;
		public LocalizedString DescriptionRaw { get; }
		/// <summary>
		/// None mean - can&apos;t cleanse.
		/// </summary>
		public DocumentCollection<int,CurioCleansingOption> CleansingOptions { get; }
		public CurioPlacementRestictions PlacementRestictions { get; }
		public DocumentCollection<string,Location> Locations => this.LocationsRaw.Dereference(document => document.Id);
		public DocumentReferenceCollection<Location> LocationsRaw { get; }
		/// <summary>
		/// Constructor for Curio.
		/// </summary>
		public Curio(string id, CurioType type, LocalizedString name, LocalizedString description, DocumentCollection<int,CurioCleansingOption> cleansingOptions, CurioPlacementRestictions placementRestictions, DocumentReferenceCollection<Location> locations)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.Type = type;
			this.NameRaw = name;
			this.DescriptionRaw = description;
			this.CleansingOptions = cleansingOptions;
			this.PlacementRestictions = placementRestictions;
			this.LocationsRaw = locations;
			foreach (var document in this.CleansingOptions) { SetParent(document, this); }
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Curio other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Curio == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Curio)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.Type, other.Type)
				&& AreEquals(this.NameRaw, other.NameRaw)
				&& AreEquals(this.DescriptionRaw, other.DescriptionRaw)
				&& AreEquals(this.CleansingOptions, other.CleansingOptions)
				&& AreEquals(this.PlacementRestictions, other.PlacementRestictions)
				&& AreEquals(this.LocationsRaw, other.LocationsRaw)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Curio);
		}
		/// <inheritdoc />
		public int CompareTo(Curio other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Curio value1, Curio value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Curio value1, Curio value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.Type)
				+ GetHashCodeFor(this.NameRaw)
				+ GetHashCodeFor(this.DescriptionRaw)
				+ GetHashCodeFor(this.CleansingOptions)
				+ GetHashCodeFor(this.PlacementRestictions)
				+ GetHashCodeFor(this.LocationsRaw)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Type: ").Append(this.Type).Append(", ");
				sb.Append("Name: ").Append(this.NameRaw).Append(", ");
				sb.Append("Description: ").Append(this.DescriptionRaw).Append(", ");
				sb.Append("Cleansing Options: ").Append(this.CleansingOptions).Append(", ");
				sb.Append("Placement Restictions: ").Append(this.PlacementRestictions).Append(", ");
				sb.Append("Locations: ").Append(this.LocationsRaw).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Disease.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Disease : Document, IEquatable<Disease>, IComparable, IComparable<Disease>
	{
		private readonly int hashCode;

		public string Id { get; }
		public string Name => this.NameRaw.Value;
		public LocalizedString NameRaw { get; }
		public DocumentCollection<int,ParameterValue> Effects { get; }
		/// <summary>
		/// Constructor for Disease.
		/// </summary>
		public Disease(string id, LocalizedString name, DocumentCollection<int,ParameterValue> effects)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.NameRaw = name;
			this.Effects = effects;
			foreach (var document in this.Effects) { SetParent(document, this); }
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Disease other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Disease == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Disease)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.NameRaw, other.NameRaw)
				&& AreEquals(this.Effects, other.Effects)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Disease);
		}
		/// <inheritdoc />
		public int CompareTo(Disease other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Disease value1, Disease value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Disease value1, Disease value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.NameRaw)
				+ GetHashCodeFor(this.Effects)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Name: ").Append(this.NameRaw).Append(", ");
				sb.Append("Effects: ").Append(this.Effects).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Quirk.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Quirk : Document, IEquatable<Quirk>, IComparable, IComparable<Quirk>
	{
		private readonly int hashCode;

		public string Id { get; }
		public string Name => this.NameRaw.Value;
		public LocalizedString NameRaw { get; }
		public bool IsPositive { get; }
		public DocumentCollection<int,ParameterValue> Effects { get; }
		/// <summary>
		/// Constructor for Quirk.
		/// </summary>
		public Quirk(string id, LocalizedString name, bool isPositive, DocumentCollection<int,ParameterValue> effects)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.NameRaw = name;
			this.IsPositive = isPositive;
			this.Effects = effects;
			foreach (var document in this.Effects) { SetParent(document, this); }
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Quirk other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Quirk == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Quirk)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.NameRaw, other.NameRaw)
				&& AreEquals(this.IsPositive, other.IsPositive)
				&& AreEquals(this.Effects, other.Effects)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Quirk);
		}
		/// <inheritdoc />
		public int CompareTo(Quirk other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Quirk value1, Quirk value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Quirk value1, Quirk value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.NameRaw)
				+ GetHashCodeFor(this.IsPositive)
				+ GetHashCodeFor(this.Effects)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Name: ").Append(this.NameRaw).Append(", ");
				sb.Append("Is Positive: ").Append(this.IsPositive).Append(", ");
				sb.Append("Effects: ").Append(this.Effects).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Condition.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Condition : Document, IEquatable<Condition>, IComparable, IComparable<Condition>
	{
		private readonly int hashCode;

		public string Id { get; }
		public string Description => this.DescriptionRaw.Value;
		public LocalizedString DescriptionRaw { get; }
		public ConditionsCheckFormula Check { get; }
		public IReadOnlyDictionary<string,object> UnboundCheck { get; }
		/// <summary>
		/// Constructor for Condition.
		/// </summary>
		public Condition(string id, LocalizedString description, ConditionsCheckFormula check, IReadOnlyDictionary<string,object> unboundCheck)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.DescriptionRaw = description;
			this.Check = check;
			this.UnboundCheck = unboundCheck;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Condition other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Condition == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Condition)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.DescriptionRaw, other.DescriptionRaw)
				&& AreEquals(this.Check, other.Check)
				&& AreEquals(this.UnboundCheck, other.UnboundCheck)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Condition);
		}
		/// <inheritdoc />
		public int CompareTo(Condition other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Condition value1, Condition value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Condition value1, Condition value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.DescriptionRaw)
				+ GetHashCodeFor(this.Check)
				+ GetHashCodeFor(this.UnboundCheck)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Description: ").Append(this.DescriptionRaw).Append(", ");
				sb.Append("Check: ").Append(this.Check).Append(", ");
				sb.Append("Unbound Check: ").Append(this.UnboundCheck).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Weapon.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Weapon : Document, IEquatable<Weapon>, IComparable, IComparable<Weapon>
	{
		private readonly int hashCode;

		public string Id { get; }
		public string Name => this.NameRaw.Value;
		public LocalizedString NameRaw { get; }
		public int DamageFrom { get; }
		public int DamageTo { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float CriticalStrikeChance { get; }
		public int Speed { get; }
		/// <summary>
		/// Constructor for Weapon.
		/// </summary>
		public Weapon(string id, LocalizedString name, int damageFrom, int damageTo, float criticalStrikeChance, int speed)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.NameRaw = name;
			this.DamageFrom = damageFrom;
			this.DamageTo = damageTo;
			this.CriticalStrikeChance = criticalStrikeChance;
			this.Speed = speed;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Weapon other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Weapon == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Weapon)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.NameRaw, other.NameRaw)
				&& AreEquals(this.DamageFrom, other.DamageFrom)
				&& AreEquals(this.DamageTo, other.DamageTo)
				&& AreEquals(this.CriticalStrikeChance, other.CriticalStrikeChance)
				&& AreEquals(this.Speed, other.Speed)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Weapon);
		}
		/// <inheritdoc />
		public int CompareTo(Weapon other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Weapon value1, Weapon value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Weapon value1, Weapon value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.NameRaw)
				+ GetHashCodeFor(this.DamageFrom)
				+ GetHashCodeFor(this.DamageTo)
				+ GetHashCodeFor(this.CriticalStrikeChance)
				+ GetHashCodeFor(this.Speed)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Name: ").Append(this.NameRaw).Append(", ");
				sb.Append("Damage From: ").Append(this.DamageFrom).Append(", ");
				sb.Append("Damage To: ").Append(this.DamageTo).Append(", ");
				sb.Append("Critical Strike Chance: ").Append(this.CriticalStrikeChance).Append(", ");
				sb.Append("Speed: ").Append(this.Speed).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is Armor.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class Armor : Document, IEquatable<Armor>, IComparable, IComparable<Armor>
	{
		private readonly int hashCode;

		public string Id { get; }
		public string Name => this.NameRaw.Value;
		public LocalizedString NameRaw { get; }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float Dodge { get; }
		public int HitPoints { get; }
		/// <summary>
		/// Constructor for Armor.
		/// </summary>
		public Armor(string id, LocalizedString name, float dodge, int hitPoints)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.NameRaw = name;
			this.Dodge = dodge;
			this.HitPoints = hitPoints;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Armor other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Armor == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Armor)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.NameRaw, other.NameRaw)
				&& AreEquals(this.Dodge, other.Dodge)
				&& AreEquals(this.HitPoints, other.HitPoints)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Armor);
		}
		/// <inheritdoc />
		public int CompareTo(Armor other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Armor value1, Armor value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Armor value1, Armor value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.NameRaw)
				+ GetHashCodeFor(this.Dodge)
				+ GetHashCodeFor(this.HitPoints)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Name: ").Append(this.NameRaw).Append(", ");
				sb.Append("Dodge: ").Append(this.Dodge).Append(", ");
				sb.Append("Hit Points: ").Append(this.HitPoints).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is ItemWithCount.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class ItemWithCount : Document, IEquatable<ItemWithCount>, IComparable, IComparable<ItemWithCount>
	{
		private readonly int hashCode;

		public int Id { get; }
		public Item Item => this.ItemRaw.Dereference();
		public DocumentReference<Item> ItemRaw { get; }
		public int Count { get; }
		/// <summary>
		/// Constructor for ItemWithCount.
		/// </summary>
		public ItemWithCount(int id, DocumentReference<Item> item, int count)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.ItemRaw = item;
			this.Count = count;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(ItemWithCount other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is ItemWithCount == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (ItemWithCount)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.ItemRaw, other.ItemRaw)
				&& AreEquals(this.Count, other.Count)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as ItemWithCount);
		}
		/// <inheritdoc />
		public int CompareTo(ItemWithCount other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(ItemWithCount value1, ItemWithCount value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(ItemWithCount value1, ItemWithCount value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.ItemRaw)
				+ GetHashCodeFor(this.Count)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Item: ").Append(this.ItemRaw).Append(", ");
				sb.Append("Count: ").Append(this.Count).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is StartingSet.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public sealed partial class StartingSet : Document, IEquatable<StartingSet>, IComparable, IComparable<StartingSet>
	{
		private readonly int hashCode;

		public int Id { get; }
		public DocumentCollection<int,ItemWithCount> Items { get; }
		public DocumentCollection<string,Hero> Heroes => this.HeroesRaw.Dereference(document => document.Id);
		public DocumentReferenceCollection<Hero> HeroesRaw { get; }
		public Location Location => this.LocationRaw.Dereference();
		public DocumentReference<Location> LocationRaw { get; }
		/// <summary>
		/// Constructor for StartingSet.
		/// </summary>
		public StartingSet(int id, DocumentCollection<int,ItemWithCount> items, DocumentReferenceCollection<Hero> heroes, DocumentReference<Location> location)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.Items = items;
			this.HeroesRaw = heroes;
			this.LocationRaw = location;
			foreach (var document in this.Items) { SetParent(document, this); }
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(StartingSet other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is StartingSet == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (StartingSet)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.Items, other.Items)
				&& AreEquals(this.HeroesRaw, other.HeroesRaw)
				&& AreEquals(this.LocationRaw, other.LocationRaw)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as StartingSet);
		}
		/// <inheritdoc />
		public int CompareTo(StartingSet other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(StartingSet value1, StartingSet value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(StartingSet value1, StartingSet value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.Items)
				+ GetHashCodeFor(this.HeroesRaw)
				+ GetHashCodeFor(this.LocationRaw)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Items: ").Append(this.Items).Append(", ");
				sb.Append("Heroes: ").Append(this.HeroesRaw).Append(", ");
				sb.Append("Location: ").Append(this.LocationRaw).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
// file path is ParameterId.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
		public enum ParameterId: int
		{
		None = 0,
		HitPoints = 1,
		MaxHitPoints = 2,
		MaxHitPointsPercent = 3,
		Speed = 4,
		Accuracy = 5,
		CrtiticalStrikeChance = 6,
		Stress = 7,
		Dodge = 8,
		Protection = 9,
		ScoutingChance = 10,
		FoodConsumationMultiplier = 11,
		HealResistance = 20,
		StunResistance = 21,
		BlightResistance = 22,
		DiseaseResistance = 23,
		DeathBlowResistance = 24,
		MoveResistance = 25,
		BleedResistance = 26,
		DebuffResistance = 27,
		TrapResistance = 28,
		StressResistance = 29,
		HealAmplification = 30,
		StressHealAplification = 31,
		DamageFrom = 50,
		DamageTo = 51,
		DamagePercent = 52,
		HealFrom = 53,
		HealTo = 54,
		HealMultiplier = 55,
		HealPercent = 56,
		StressHealFrom = 57,
		StressHealTo = 58,
		StressHealPercent = 59,
		BleedHealChance = 60,
		StunChance = 70,
		MarkChance = 71,
		KnockbackChance = 73,
		VirtueChance = 74,
		Position = 80,
	}
}
// file path is ParameterValueKind.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
		public enum ParameterValueKind: int
		{
		None = 0,
		Integer = 1,
		Number = 2,
		Percent = 3,
	}
}
// file path is LocationFlags.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[Flags]
	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
		public enum LocationFlags: int
		{
		None = 0,
		Home = 1,
		Tutorial = 2,
	}
}
// file path is TrinketRarity.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
		public enum TrinketRarity: int
		{
		None = 0,
		Common = 1,
		Uncommon = 2,
		Rare = 3,
		VeryRare = 4,
		Shrieker = 5,
		Ancestral = 6,
		CrimsonCourt = 7,
		DarkestDungeon = 8,
		Trophy = 9,
		Backer = 10,
	}
}
// file path is MonsterType.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
		public enum MonsterType: int
		{
		None = 0,
		Human = 1,
		Beast = 2,
		Unholy = 3,
		Eldritch = 4,
		Corpse = 5,
		Carpentry = 6,
		Crockery = 7,
		Ironwork = 8,
		Thatchery = 9,
		Cosmic = 10,
	}
}
// file path is LootType.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
		public enum LootType: int
		{
		None = 0,
		Any = 1,
		Heirloom = 2,
		Trinket = 3,
		Supplies = 4,
		Torch = 5,
		Gold = 6,
		Food = 7,
	}
}
// file path is DurationUnit.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
		public enum DurationUnit: int
		{
		None = 0,
		Rounds = 1,
		Camps = 2,
		Missions = 3,
	}
}
// file path is CurioType.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[Flags]
	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
		public enum CurioType: int
		{
		None = 0,
		Reflective = 1,
		Worship = 2,
		Knowledge = 4,
		Haunted = 8,
		Scrounging = 16,
		Fountain = 32,
		Torture = 64,
		Treasure = 128,
		Body = 256,
		Unholy = 512,
		Drink = 1024,
		Food = 2048,
	}
}
// file path is CurioPlacementRestictions.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[Flags]
	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
		public enum CurioPlacementRestictions: int
		{
		None = 0,
		Room = 1,
		Corridor = 2,
	}
}
// file path is ConditionsCheckFormula.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;


	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public partial class ConditionsCheckFormula
	{
		public partial class ConditionsCheckFormulaScope
		{
			public Condition @this;
		}

#if USE_DYNAMIC_EXPRESSIONS
		private static readonly GameDevWare.Dynamic.Expressions.Binder ExpressionBinder;

		private readonly Expression<Func<Assets.Scripts.CheckContext, bool>> expression;
		private Func<Assets.Scripts.CheckContext, bool> compiledExpression;

		public ConditionsCheckFormulaScope Context { get; private set; }

		static ConditionsCheckFormula()
		{
			var formulaTypes = new Type[]
			{
				typeof(Assets.Scripts.CheckContext),
				typeof(Assets.Scripts.AttackType),
				typeof(bool),
				typeof(ConditionsCheckFormulaScope)
			};

			var parameters = new ParameterExpression[]
			{
				Expression.Parameter(typeof(Assets.Scripts.CheckContext), "context"),
			};

			var typeResolver = new GameDevWare.Dynamic.Expressions.KnownTypeResolver(formulaTypes, RpgGameData.TypeResolver);
			ExpressionBinder = new GameDevWare.Dynamic.Expressions.Binder(parameters, typeof(bool), typeResolver);

			// AOT preparation
			if (typeof(object).Name == string.Empty)
			{
				new System.Runtime.CompilerServices.StrongBox<ConditionsCheckFormulaScope>(default(ConditionsCheckFormulaScope));
				new System.Runtime.CompilerServices.StrongBox<Assets.Scripts.AttackType>(default(Assets.Scripts.AttackType));
			}
			GameDevWare.Dynamic.Expressions.AotCompilation.RegisterFunc<Assets.Scripts.CheckContext, bool>();
		}
		public ConditionsCheckFormula(IReadOnlyDictionary<string, object> expressionTree)
		{
			if (expressionTree == null) throw new ArgumentNullException(nameof(expressionTree));

			var syntaxTreeNode = new GameDevWare.Dynamic.Expressions.SyntaxTreeNode((IDictionary<string, object>)expressionTree);
			this.Context = new ConditionsCheckFormulaScope();
			this.expression = (Expression<Func<Assets.Scripts.CheckContext, bool>>)ConditionsCheckFormula.ExpressionBinder.Bind(syntaxTreeNode, Expression.Constant(this.Context));
		}

		public bool Invoke(Assets.Scripts.CheckContext context)
		{
			var __fn = this.CompileAot();
			return __fn.Invoke(context);
		}

		public Func<Assets.Scripts.CheckContext, bool> CompileAot()
		{
			try
			{
				if (this.compiledExpression == null)
				{
					this.compiledExpression = this.expression.CompileAot();
				}
				return this.compiledExpression;
			}
			catch (Exception compilationError)
			{
				throw new InvalidOperationException(string.Format("Failed to compile expression '{0}' due errors: {1}{2}", this.ToString(), Environment.NewLine, compilationError.Message), compilationError);
			}
		}
		public Func<Assets.Scripts.CheckContext, bool> Compile()
		{
			try
			{
				if (this.compiledExpression == null)
				{
					this.compiledExpression = this.expression.Compile();
				}
				return this.compiledExpression;
			}
			catch (Exception compilationError)
			{
				throw new InvalidOperationException(string.Format("Failed to compile expression '{0}' due errors: {1}{2}", this.ToString(), Environment.NewLine, compilationError.Message), compilationError);
			}
		}
#elif !SUPPRESS_BUILD_IN_FORMULAS
		private static readonly Formulas.IFormulaTypeResolver TypeResolver;

		private Formulas.FormulaExpression expression;

		public ConditionsCheckFormulaScope Context { get; private set; }

		static ConditionsCheckFormula()
		{
			var formulaTypes = new Type[]
			{
				typeof(Assets.Scripts.CheckContext),
				typeof(Assets.Scripts.AttackType),
				typeof(bool),
				typeof(ConditionsCheckFormulaScope)
			};

			TypeResolver = new Formulas.KnownFormulaTypeResolver(formulaTypes, Formulas.FormulaOptions.None, RpgGameData.TypeResolver);
			// AOT
			Formulas.FormulaExpression.RegisterFunc<Assets.Scripts.CheckContext, bool>();
		}
		public ConditionsCheckFormula(IReadOnlyDictionary<string, object> expressionTree)
		{
			if (expressionTree == null) throw new ArgumentNullException(nameof(expressionTree));

			this.Context = new ConditionsCheckFormulaScope();
			this.expression = Formulas.FormulaExpression.Create(expressionTree, typeof(bool));
		}

		public bool Invoke(Assets.Scripts.CheckContext context)
		{
			var __lambdaArguments = new Dictionary<string, Formulas.VariableValue>();

			__lambdaArguments["context"] = new Formulas.VariableValue(context);

			var __globalValue = new Formulas.VariableValue(this.Context);
			var __executionContext = new Formulas.FormulaExecutionContext(__lambdaArguments, typeResolver: ConditionsCheckFormula.TypeResolver, global: __globalValue);
			var __result = this.expression.Execute(__executionContext);
			return __result.To<bool>();
		}
#else
		public ConditionsCheckFormula(IReadOnlyDictionary<string, object> expressionTree)
		{
			if (expressionTree == null) throw new ArgumentNullException(nameof(expressionTree));
		}

		public bool Invoke(Assets.Scripts.CheckContext context)
		{
			throw new NotSupportedException();
		}
#endif

		public override string ToString()
		{
			return this.expression.ToString();
		}
	}
}
// file path is RpgGameData.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(RpgGameData.GeneratorName, RpgGameData.GeneratorVersion)]
	public partial class RpgGameData
	{
		public const string GeneratorName = "Charon";
		public const string GeneratorVersion = "2023.4.4.0";

		private class DocumentCollections
		{
			public DocumentCollection<string,ProjectSetting> _projectSettings = DocumentCollection<string,ProjectSetting>.Empty;
			public DocumentCollection<ParameterId,Parameter> _parameters = DocumentCollection<ParameterId,Parameter>.Empty;
			public DocumentCollection<int,ParameterValue> _parameterValues = DocumentCollection<int,ParameterValue>.Empty;
			public DocumentCollection<string,Provision> _provisions = DocumentCollection<string,Provision>.Empty;
			public DocumentCollection<string,Hero> _heros = DocumentCollection<string,Hero>.Empty;
			public DocumentCollection<string,Item> _items = DocumentCollection<string,Item>.Empty;
			public DocumentCollection<string,Location> _locations = DocumentCollection<string,Location>.Empty;
			public DocumentCollection<string,Trinket> _trinkets = DocumentCollection<string,Trinket>.Empty;
			public DocumentCollection<string,Monster> _monsters = DocumentCollection<string,Monster>.Empty;
			public DocumentCollection<int,Loot> _loots = DocumentCollection<int,Loot>.Empty;
			public DocumentCollection<int,CombatEffect> _combatEffects = DocumentCollection<int,CombatEffect>.Empty;
			public DocumentCollection<int,CurioCleansingOption> _curioCleansingOptions = DocumentCollection<int,CurioCleansingOption>.Empty;
			public DocumentCollection<string,Curio> _curios = DocumentCollection<string,Curio>.Empty;
			public DocumentCollection<string,Disease> _diseases = DocumentCollection<string,Disease>.Empty;
			public DocumentCollection<string,Quirk> _quirks = DocumentCollection<string,Quirk>.Empty;
			public DocumentCollection<string,Condition> _conditions = DocumentCollection<string,Condition>.Empty;
			public DocumentCollection<string,Weapon> _weapons = DocumentCollection<string,Weapon>.Empty;
			public DocumentCollection<string,Armor> _armors = DocumentCollection<string,Armor>.Empty;
			public DocumentCollection<int,ItemWithCount> _itemWithCounts = DocumentCollection<int,ItemWithCount>.Empty;
			public DocumentCollection<int,StartingSet> _startingSets = DocumentCollection<int,StartingSet>.Empty;
		}

		#region Formula fields
		public static readonly Type[] FormulaTypes = new Type[]
		{
				typeof(RpgGameData),
				typeof(ProjectSetting),
				typeof(Parameter),
				typeof(ParameterValue),
				typeof(Provision),
				typeof(Hero),
				typeof(Item),
				typeof(Location),
				typeof(Trinket),
				typeof(Monster),
				typeof(Loot),
				typeof(CombatEffect),
				typeof(CurioCleansingOption),
				typeof(Curio),
				typeof(Disease),
				typeof(Quirk),
				typeof(Condition),
				typeof(Weapon),
				typeof(Armor),
				typeof(ItemWithCount),
				typeof(StartingSet),
				typeof(ConditionsCheckFormula),
				typeof(ParameterId),
				typeof(ParameterValueKind),
				typeof(LocationFlags),
				typeof(TrinketRarity),
				typeof(MonsterType),
				typeof(LootType),
				typeof(DurationUnit),
				typeof(CurioType),
				typeof(CurioPlacementRestictions),
		};
#if USE_DYNAMIC_EXPRESSIONS
		public static readonly GameDevWare.Dynamic.Expressions.ITypeResolver TypeResolver = new GameDevWare.Dynamic.Expressions.KnownTypeResolver(FormulaTypes);
#elif !SUPPRESS_BUILD_IN_FORMULAS
		public static readonly Formulas.IFormulaTypeResolver TypeResolver = new Formulas.KnownFormulaTypeResolver(FormulaTypes, Formulas.FormulaOptions.None);
#endif
		#endregion

		#region Schema collections storage fields
		private readonly DocumentCollections rootDocuments = new DocumentCollections();
		private readonly DocumentCollections allDocuments = new DocumentCollections();
		#endregion

		#region Schema collections
		public ProjectSetting ProjectSetting => this.GetOne<ProjectSetting>(this.rootDocuments._projectSettings.AsList);
		public DocumentCollection<ParameterId,Parameter> AllParameters => this.allDocuments._parameters;
		public DocumentCollection<ParameterId,Parameter> RootParameters => this.rootDocuments._parameters;
		public DocumentCollection<int,ParameterValue> AllParameterValues => this.allDocuments._parameterValues;
		public DocumentCollection<int,ParameterValue> RootParameterValues => this.rootDocuments._parameterValues;
		public DocumentCollection<string,Provision> AllProvisions => this.allDocuments._provisions;
		public DocumentCollection<string,Provision> RootProvisions => this.rootDocuments._provisions;
		public DocumentCollection<string,Hero> AllHeros => this.allDocuments._heros;
		public DocumentCollection<string,Hero> RootHeros => this.rootDocuments._heros;
		public DocumentCollection<string,Item> AllItems => this.allDocuments._items;
		public DocumentCollection<string,Item> RootItems => this.rootDocuments._items;
		public DocumentCollection<string,Location> AllLocations => this.allDocuments._locations;
		public DocumentCollection<string,Location> RootLocations => this.rootDocuments._locations;
		public DocumentCollection<string,Trinket> AllTrinkets => this.allDocuments._trinkets;
		public DocumentCollection<string,Trinket> RootTrinkets => this.rootDocuments._trinkets;
		public DocumentCollection<string,Monster> AllMonsters => this.allDocuments._monsters;
		public DocumentCollection<string,Monster> RootMonsters => this.rootDocuments._monsters;
		public DocumentCollection<int,Loot> AllLoots => this.allDocuments._loots;
		public DocumentCollection<int,Loot> RootLoots => this.rootDocuments._loots;
		public DocumentCollection<int,CombatEffect> AllCombatEffects => this.allDocuments._combatEffects;
		public DocumentCollection<int,CombatEffect> RootCombatEffects => this.rootDocuments._combatEffects;
		public DocumentCollection<int,CurioCleansingOption> AllCurioCleansingOptions => this.allDocuments._curioCleansingOptions;
		public DocumentCollection<int,CurioCleansingOption> RootCurioCleansingOptions => this.rootDocuments._curioCleansingOptions;
		public DocumentCollection<string,Curio> AllCurios => this.allDocuments._curios;
		public DocumentCollection<string,Curio> RootCurios => this.rootDocuments._curios;
		public DocumentCollection<string,Disease> AllDiseases => this.allDocuments._diseases;
		public DocumentCollection<string,Disease> RootDiseases => this.rootDocuments._diseases;
		public DocumentCollection<string,Quirk> AllQuirks => this.allDocuments._quirks;
		public DocumentCollection<string,Quirk> RootQuirks => this.rootDocuments._quirks;
		public DocumentCollection<string,Condition> AllConditions => this.allDocuments._conditions;
		public DocumentCollection<string,Condition> RootConditions => this.rootDocuments._conditions;
		public DocumentCollection<string,Weapon> AllWeapons => this.allDocuments._weapons;
		public DocumentCollection<string,Weapon> RootWeapons => this.rootDocuments._weapons;
		public DocumentCollection<string,Armor> AllArmors => this.allDocuments._armors;
		public DocumentCollection<string,Armor> RootArmors => this.rootDocuments._armors;
		public DocumentCollection<int,ItemWithCount> AllItemWithCounts => this.allDocuments._itemWithCounts;
		public DocumentCollection<int,ItemWithCount> RootItemWithCounts => this.rootDocuments._itemWithCounts;
		public StartingSet StartingSet => this.GetOne<StartingSet>(this.rootDocuments._startingSets.AsList);
		#endregion

		private ReadOnlyCollection<String> languages = new ReadOnlyCollection<String>(new String[] { "en-US" });
		private LocalizedString.LanguageSwitcher languageSwitcher;
#pragma warning disable 0414 // The variable changeNumber', 'revisionHash' is declared but never used
		private int changeNumber = 0;
		private string revisionHash = null;
#pragma warning restore 0414

		public ReadOnlyCollection<string> SupportedLanguages { get { return this.languages; } }
		public Func<string, object, Document> FindDocument { get; private set;}


		public RpgGameData(Stream gameDataStream, Formatters.GameDataLoadOptions options)
		{
			if (gameDataStream == null) throw new ArgumentNullException(nameof(gameDataStream));
			if (options == null) throw new ArgumentNullException(nameof(options));

			this.languageSwitcher = new LocalizedString.LanguageSwitcher {
				CurrentLanguageId = "en-US",
				FallbackLanguageId = "en-US",
				PrimaryLanguageId = "en-US",
			};

			this.FindDocument = this.FindDocumentInternal;

			var reader = CreateReader(gameDataStream, options);
			foreach (var patchStream in (options.Patches ?? Array.Empty<Stream>()))
			{
				using(var patchReader = this.CreateReader(patchStream, options))
				{
					var patchDocument = patchReader.ReadObject();
					reader = new Formatters.PatchingGameDataReader(reader, patchDocument, this.ReplaceToSchemaName, options.LeaveStreamsOpen);
				}
			}
			try { this.ReadGameData(reader); }
			finally { reader.Dispose(); }

			this.FindAllDocuments();


#pragma warning disable 0162 // Unreachable code detected
			this.OnInitialize();
#pragma warning restore 0162
		}

		partial void OnInitialize();

		public IEnumerable<Document> GetAllDocuments()
		{
			return this.EnumerateAll();
		}

		public void SetLanguage(string languageId)
		{
			this.SetLanguage(languageId, languageId);
		}
		public void SetLanguage(string languageId, string fallbackLanguageId = "en-US")
		{
			if (languageId == null) throw new ArgumentNullException(nameof(languageId));
			if (fallbackLanguageId == null) throw new ArgumentNullException(nameof(fallbackLanguageId));

			this.languageSwitcher.CurrentLanguageId = languageId;
			this.languageSwitcher.FallbackLanguageId = fallbackLanguageId ?? languageId;
		}

		private DocumentT GetOne<DocumentT>(IReadOnlyCollection<DocumentT> documents) where DocumentT : Document
		{
			switch(documents.Count)
			{
				case 0: throw new InvalidOperationException($"Unable to find '{typeof(DocumentT)}' document. Please create '{typeof(DocumentT)}' document before using this property.");
				case 1: return System.Linq.Enumerable.Single<DocumentT>(documents);
				default: throw new InvalidOperationException($"There are multiple variants of the '{typeof(DocumentT)}' document. Please remove the excess before using this property.");
			}
		}

		private Document FindDocumentInternal(string schemaId, object id)
		{
			if (schemaId == null) throw new ArgumentNullException(nameof(schemaId));

#pragma warning disable 1522 // Empty switch block
			switch (schemaId)
			{
				case "ProjectSettings":
				case "55a4f32faca22e191098f3d9": return this.allDocuments._projectSettings.Get(ChangeType<string>(id));
				case "Parameter":
				case "59f5b0a730bb84165c06b547": return this.allDocuments._parameters.Get(ChangeType<ParameterId>(id));
				case "ParameterValue":
				case "59f5b11030bb84165c06b54e": return this.allDocuments._parameterValues.Get(ChangeType<int>(id));
				case "Provision":
				case "59f5b1c830bb84165c06b556": return this.allDocuments._provisions.Get(ChangeType<string>(id));
				case "Hero":
				case "59f5b29330bb84165c06b55c": return this.allDocuments._heros.Get(ChangeType<string>(id));
				case "Item":
				case "59f5b3f130bb84165c06b56b": return this.allDocuments._items.Get(ChangeType<string>(id));
				case "Location":
				case "59f5b57530bb84165c06b579": return this.allDocuments._locations.Get(ChangeType<string>(id));
				case "Trinket":
				case "59f5b61630bb84165c06b57f": return this.allDocuments._trinkets.Get(ChangeType<string>(id));
				case "Monster":
				case "59f5b7f330bb84165c06b58a": return this.allDocuments._monsters.Get(ChangeType<string>(id));
				case "Loot":
				case "59f5b9dd30bb84165c06b59a": return this.allDocuments._loots.Get(ChangeType<int>(id));
				case "CombatEffect":
				case "59f5baaa30bb84165c06b5a0": return this.allDocuments._combatEffects.Get(ChangeType<int>(id));
				case "CurioCleansingOption":
				case "59f5bac130bb84165c06b5a4": return this.allDocuments._curioCleansingOptions.Get(ChangeType<int>(id));
				case "Curio":
				case "59f5bbc230bb84165c06b5ae": return this.allDocuments._curios.Get(ChangeType<string>(id));
				case "Disease":
				case "59f5d3a7983a361970003662": return this.allDocuments._diseases.Get(ChangeType<string>(id));
				case "Quirk":
				case "59f5d728983a361970003684": return this.allDocuments._quirks.Get(ChangeType<string>(id));
				case "Conditions":
				case "59f5dedf983a361970003697": return this.allDocuments._conditions.Get(ChangeType<string>(id));
				case "Weapon":
				case "59f9e745983a364298db5e22": return this.allDocuments._weapons.Get(ChangeType<string>(id));
				case "Armor":
				case "59f9e7b6983a364298db5e2c": return this.allDocuments._armors.Get(ChangeType<string>(id));
				case "ItemWithCount":
				case "5a1d78d107ff9a7b889cba7d": return this.allDocuments._itemWithCounts.Get(ChangeType<int>(id));
				case "StartingSet":
				case "5a1d78de07ff9a7b889cba83": return this.allDocuments._startingSets.Get(ChangeType<int>(id));
			}
#pragma warning restore 1522
			throw new System.ArgumentException(string.Format("Unable find Schema with id '{0}'.", schemaId) , nameof(schemaId));
		}

		private string ReplaceToSchemaName(string schemaNameOrId)
		{
			if (schemaNameOrId == null) throw new ArgumentNullException(nameof(schemaNameOrId));

#pragma warning disable 1522 // Empty switch block
			switch (schemaNameOrId)
			{
				case "ProjectSettings":
				case "55a4f32faca22e191098f3d9": return "ProjectSettings";
				case "Parameter":
				case "59f5b0a730bb84165c06b547": return "Parameter";
				case "ParameterValue":
				case "59f5b11030bb84165c06b54e": return "ParameterValue";
				case "Provision":
				case "59f5b1c830bb84165c06b556": return "Provision";
				case "Hero":
				case "59f5b29330bb84165c06b55c": return "Hero";
				case "Item":
				case "59f5b3f130bb84165c06b56b": return "Item";
				case "Location":
				case "59f5b57530bb84165c06b579": return "Location";
				case "Trinket":
				case "59f5b61630bb84165c06b57f": return "Trinket";
				case "Monster":
				case "59f5b7f330bb84165c06b58a": return "Monster";
				case "Loot":
				case "59f5b9dd30bb84165c06b59a": return "Loot";
				case "CombatEffect":
				case "59f5baaa30bb84165c06b5a0": return "CombatEffect";
				case "CurioCleansingOption":
				case "59f5bac130bb84165c06b5a4": return "CurioCleansingOption";
				case "Curio":
				case "59f5bbc230bb84165c06b5ae": return "Curio";
				case "Disease":
				case "59f5d3a7983a361970003662": return "Disease";
				case "Quirk":
				case "59f5d728983a361970003684": return "Quirk";
				case "Conditions":
				case "59f5dedf983a361970003697": return "Conditions";
				case "Weapon":
				case "59f9e745983a364298db5e22": return "Weapon";
				case "Armor":
				case "59f9e7b6983a364298db5e2c": return "Armor";
				case "ItemWithCount":
				case "5a1d78d107ff9a7b889cba7d": return "ItemWithCount";
				case "StartingSet":
				case "5a1d78de07ff9a7b889cba83": return "StartingSet";
			}
#pragma warning restore 1522

			return schemaNameOrId;
		}

		private IEnumerable<Document> EnumerateAll()
		{
			var i = 0;
			var end = 0;
			var _projectSettingsList = this.allDocuments._projectSettings.AsList;
			for (i = 0, end = _projectSettingsList.Count; i < end; i++)
			{
				yield return _projectSettingsList[i];
			}
			var _parametersList = this.allDocuments._parameters.AsList;
			for (i = 0, end = _parametersList.Count; i < end; i++)
			{
				yield return _parametersList[i];
			}
			var _parameterValuesList = this.allDocuments._parameterValues.AsList;
			for (i = 0, end = _parameterValuesList.Count; i < end; i++)
			{
				yield return _parameterValuesList[i];
			}
			var _provisionsList = this.allDocuments._provisions.AsList;
			for (i = 0, end = _provisionsList.Count; i < end; i++)
			{
				yield return _provisionsList[i];
			}
			var _herosList = this.allDocuments._heros.AsList;
			for (i = 0, end = _herosList.Count; i < end; i++)
			{
				yield return _herosList[i];
			}
			var _itemsList = this.allDocuments._items.AsList;
			for (i = 0, end = _itemsList.Count; i < end; i++)
			{
				yield return _itemsList[i];
			}
			var _locationsList = this.allDocuments._locations.AsList;
			for (i = 0, end = _locationsList.Count; i < end; i++)
			{
				yield return _locationsList[i];
			}
			var _trinketsList = this.allDocuments._trinkets.AsList;
			for (i = 0, end = _trinketsList.Count; i < end; i++)
			{
				yield return _trinketsList[i];
			}
			var _monstersList = this.allDocuments._monsters.AsList;
			for (i = 0, end = _monstersList.Count; i < end; i++)
			{
				yield return _monstersList[i];
			}
			var _lootsList = this.allDocuments._loots.AsList;
			for (i = 0, end = _lootsList.Count; i < end; i++)
			{
				yield return _lootsList[i];
			}
			var _combatEffectsList = this.allDocuments._combatEffects.AsList;
			for (i = 0, end = _combatEffectsList.Count; i < end; i++)
			{
				yield return _combatEffectsList[i];
			}
			var _curioCleansingOptionsList = this.allDocuments._curioCleansingOptions.AsList;
			for (i = 0, end = _curioCleansingOptionsList.Count; i < end; i++)
			{
				yield return _curioCleansingOptionsList[i];
			}
			var _curiosList = this.allDocuments._curios.AsList;
			for (i = 0, end = _curiosList.Count; i < end; i++)
			{
				yield return _curiosList[i];
			}
			var _diseasesList = this.allDocuments._diseases.AsList;
			for (i = 0, end = _diseasesList.Count; i < end; i++)
			{
				yield return _diseasesList[i];
			}
			var _quirksList = this.allDocuments._quirks.AsList;
			for (i = 0, end = _quirksList.Count; i < end; i++)
			{
				yield return _quirksList[i];
			}
			var _conditionsList = this.allDocuments._conditions.AsList;
			for (i = 0, end = _conditionsList.Count; i < end; i++)
			{
				yield return _conditionsList[i];
			}
			var _weaponsList = this.allDocuments._weapons.AsList;
			for (i = 0, end = _weaponsList.Count; i < end; i++)
			{
				yield return _weaponsList[i];
			}
			var _armorsList = this.allDocuments._armors.AsList;
			for (i = 0, end = _armorsList.Count; i < end; i++)
			{
				yield return _armorsList[i];
			}
			var _itemWithCountsList = this.allDocuments._itemWithCounts.AsList;
			for (i = 0, end = _itemWithCountsList.Count; i < end; i++)
			{
				yield return _itemWithCountsList[i];
			}
			var _startingSetsList = this.allDocuments._startingSets.AsList;
			for (i = 0, end = _startingSetsList.Count; i < end; i++)
			{
				yield return _startingSetsList[i];
			}
			yield break;
		}

		private IEnumerable<Document> EnumerateRoots()
		{
			var i = 0;
			var end = 0;
			var _projectSettingsList = this.rootDocuments._projectSettings.AsList;
			for (i = 0, end = _projectSettingsList.Count; i < end; i++)
			{
				yield return _projectSettingsList[i];
			}
			var _parametersList = this.rootDocuments._parameters.AsList;
			for (i = 0, end = _parametersList.Count; i < end; i++)
			{
				yield return _parametersList[i];
			}
			var _parameterValuesList = this.rootDocuments._parameterValues.AsList;
			for (i = 0, end = _parameterValuesList.Count; i < end; i++)
			{
				yield return _parameterValuesList[i];
			}
			var _provisionsList = this.rootDocuments._provisions.AsList;
			for (i = 0, end = _provisionsList.Count; i < end; i++)
			{
				yield return _provisionsList[i];
			}
			var _herosList = this.rootDocuments._heros.AsList;
			for (i = 0, end = _herosList.Count; i < end; i++)
			{
				yield return _herosList[i];
			}
			var _itemsList = this.rootDocuments._items.AsList;
			for (i = 0, end = _itemsList.Count; i < end; i++)
			{
				yield return _itemsList[i];
			}
			var _locationsList = this.rootDocuments._locations.AsList;
			for (i = 0, end = _locationsList.Count; i < end; i++)
			{
				yield return _locationsList[i];
			}
			var _trinketsList = this.rootDocuments._trinkets.AsList;
			for (i = 0, end = _trinketsList.Count; i < end; i++)
			{
				yield return _trinketsList[i];
			}
			var _monstersList = this.rootDocuments._monsters.AsList;
			for (i = 0, end = _monstersList.Count; i < end; i++)
			{
				yield return _monstersList[i];
			}
			var _lootsList = this.rootDocuments._loots.AsList;
			for (i = 0, end = _lootsList.Count; i < end; i++)
			{
				yield return _lootsList[i];
			}
			var _combatEffectsList = this.rootDocuments._combatEffects.AsList;
			for (i = 0, end = _combatEffectsList.Count; i < end; i++)
			{
				yield return _combatEffectsList[i];
			}
			var _curioCleansingOptionsList = this.rootDocuments._curioCleansingOptions.AsList;
			for (i = 0, end = _curioCleansingOptionsList.Count; i < end; i++)
			{
				yield return _curioCleansingOptionsList[i];
			}
			var _curiosList = this.rootDocuments._curios.AsList;
			for (i = 0, end = _curiosList.Count; i < end; i++)
			{
				yield return _curiosList[i];
			}
			var _diseasesList = this.rootDocuments._diseases.AsList;
			for (i = 0, end = _diseasesList.Count; i < end; i++)
			{
				yield return _diseasesList[i];
			}
			var _quirksList = this.rootDocuments._quirks.AsList;
			for (i = 0, end = _quirksList.Count; i < end; i++)
			{
				yield return _quirksList[i];
			}
			var _conditionsList = this.rootDocuments._conditions.AsList;
			for (i = 0, end = _conditionsList.Count; i < end; i++)
			{
				yield return _conditionsList[i];
			}
			var _weaponsList = this.rootDocuments._weapons.AsList;
			for (i = 0, end = _weaponsList.Count; i < end; i++)
			{
				yield return _weaponsList[i];
			}
			var _armorsList = this.rootDocuments._armors.AsList;
			for (i = 0, end = _armorsList.Count; i < end; i++)
			{
				yield return _armorsList[i];
			}
			var _itemWithCountsList = this.rootDocuments._itemWithCounts.AsList;
			for (i = 0, end = _itemWithCountsList.Count; i < end; i++)
			{
				yield return _itemWithCountsList[i];
			}
			var _startingSetsList = this.rootDocuments._startingSets.AsList;
			for (i = 0, end = _startingSetsList.Count; i < end; i++)
			{
				yield return _startingSetsList[i];
			}

			yield break;
		}

		private static T ChangeType<T>(object objValue)
		{
			if (objValue is T typeValue)
			{
				return typeValue;
			}
			else if (typeof(T).IsEnum && objValue is string enumValueString)
			{
				return (T)Enum.Parse(typeof(T), enumValueString, ignoreCase: true);
			}
			else if (typeof(T).IsEnum)
			{
				return (T)Enum.ToObject(typeof(T), objValue);
			}
			else if (typeof(T) == typeof(TimeSpan))
			{
				var timeSpanStr = Convert.ToString(objValue, CultureInfo.InvariantCulture);
				return (T)(object)TimeSpan.Parse(timeSpanStr);
			}
			else if (typeof(T) == typeof(DateTime))
			{
				var dateTimeStr = Convert.ToString(objValue, CultureInfo.InvariantCulture);
				return (T)(object)DateTime.ParseExact(dateTimeStr, Formatters.GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
			}
			else if (typeof(T) == typeof(DateTimeOffset))
			{
				var dateTimeOffsetStr = Convert.ToString(objValue, CultureInfo.InvariantCulture);
				return (T)(object)DateTimeOffset.ParseExact(dateTimeOffsetStr, Formatters.GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
			}
			else
			{
				return (T)Convert.ChangeType(objValue, typeof(T), CultureInfo.InvariantCulture);
			}
		}


		#region Read Game Data

		public Formatters.GameDataReader CreateReader(Stream gameDataStream, Formatters.GameDataLoadOptions options)
		{
			if (gameDataStream == null) throw new ArgumentNullException(nameof(gameDataStream));
			if (options == null) throw new ArgumentNullException(nameof(options));

			switch(options.Format)
			{
				case Formatters.Format.Json: return new Formatters.JsonGameDataReader(gameDataStream, options.Encoding, options.LeaveStreamsOpen);
				case Formatters.Format.MessagePack: return new Formatters.MessagePackGameDataReader(gameDataStream, options.LeaveStreamsOpen);
				default: throw new ArgumentException($"Unknown/Unsupported data format specified '{options.Format}'.", nameof(options));
			}
		}

		public void ReadGameData(Formatters.GameDataReader reader)
		{
			if (reader == null) throw new ArgumentNullException(nameof(reader));

			reader.ReadObjectBegin();
			while(reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var memberName = reader.ReadMember();
				switch(memberName)
				{
					case "ChangeNumber":
						this.changeNumber = (Int32)reader.Node.AsInt32;
						reader.NextToken();
						break;
					case "RevisionHash":
						this.revisionHash = (string)reader.Node.AsString;
						reader.NextToken();
						break;
					case "Collections":
						reader.ReadObjectBegin();
						while(reader.Node.Token != Formatters.ReaderToken.EndOfObject)
						{
							var collectionName = reader.ReadMember();
							switch (collectionName.Length)
							{
								case 4:
									switch(collectionName)
									{
										case "Hero":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._heros = this.ReadHeroCollection(reader, 3);
											break;
										}
										case "Item":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._items = this.ReadItemCollection(reader, 23);
											break;
										}
										case "Loot":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._loots = this.ReadLootCollection(reader, 100);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 5:
									switch(collectionName)
									{
										case "Curio":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._curios = this.ReadCurioCollection(reader, 5);
											break;
										}
										case "Quirk":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._quirks = this.ReadQuirkCollection(reader, 8);
											break;
										}
										case "Armor":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._armors = this.ReadArmorCollection(reader, 100);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 6:
									switch(collectionName)
									{
										case "Weapon":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._weapons = this.ReadWeaponCollection(reader, 100);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 7:
									switch(collectionName)
									{
										case "Trinket":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._trinkets = this.ReadTrinketCollection(reader, 6);
											break;
										}
										case "Monster":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._monsters = this.ReadMonsterCollection(reader, 6);
											break;
										}
										case "Disease":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._diseases = this.ReadDiseaseCollection(reader, 6);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 8:
									switch(collectionName)
									{
										case "Location":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._locations = this.ReadLocationCollection(reader, 7);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 9:
									switch(collectionName)
									{
										case "Parameter":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._parameters = this.ReadParameterCollection(reader, 39);
											break;
										}
										case "Provision":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._provisions = this.ReadProvisionCollection(reader, 10);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 10:
									switch(collectionName)
									{
										case "Conditions":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._conditions = this.ReadConditionsCollection(reader, 18);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 11:
									switch(collectionName)
									{
										case "StartingSet":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._startingSets = this.ReadStartingSetCollection(reader, 1);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 12:
									switch(collectionName)
									{
										case "CombatEffect":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._combatEffects = this.ReadCombatEffectCollection(reader, 100);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 13:
									switch(collectionName)
									{
										case "ItemWithCount":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._itemWithCounts = this.ReadItemWithCountCollection(reader, 100);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 14:
									switch(collectionName)
									{
										case "ParameterValue":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._parameterValues = this.ReadParameterValueCollection(reader, 100);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 15:
									switch(collectionName)
									{
										case "ProjectSettings":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._projectSettings = this.ReadProjectSettingsCollection(reader, 1);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 20:
									switch(collectionName)
									{
										case "CurioCleansingOption":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments._curioCleansingOptions = this.ReadCurioCleansingOptionCollection(reader, 100);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								default:
									reader.SkipAny();
									break;
							}
						}
						reader.ReadObjectEnd();
						return;
					default:
						reader.SkipAny();
						break;
				}
			}

			reader.ReadObjectEnd();

			// update language list
			var projectSettings = System.Linq.Enumerable.FirstOrDefault(this.rootDocuments._projectSettings.AsList);
			if (projectSettings != null && string.IsNullOrEmpty(projectSettings.Languages) == false)
			{
					var languages = new List<String>(projectSettings.Languages.Split(";,| ".ToCharArray(), StringSplitOptions.RemoveEmptyEntries));
					if (string.IsNullOrEmpty(projectSettings.PrimaryLanguage) == false)
					{
						this.languageSwitcher.PrimaryLanguageId = projectSettings.PrimaryLanguage;
					}
					else if (languages.Count > 0)
					{
						this.languageSwitcher.PrimaryLanguageId = languages[0];
					}
					else
					{
						this.languageSwitcher.PrimaryLanguageId = "en-US";
					}

					this.languageSwitcher.CurrentLanguageId = this.languageSwitcher.FallbackLanguageId = this.languageSwitcher.PrimaryLanguageId;
					languages.Remove(projectSettings.PrimaryLanguage);
					languages.Add(projectSettings.PrimaryLanguage);
					languages.Sort(StringComparer.OrdinalIgnoreCase);

					this.languages = new ReadOnlyCollection<String>(languages);
			}
		}

		private DocumentCollection<string,ProjectSetting> ReadProjectSettingsCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<ProjectSetting>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadProjectSettings(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<ProjectSetting>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,ProjectSetting>.Empty;
			}
			else
			{
				return new DocumentCollection<string,ProjectSetting>(collection, document => document.Id);
			}
		}

		private ProjectSetting ReadProjectSettings(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var name__ = default(string);
			var primaryLanguage__ = default(string);
			var languages__ = default(string);
			var copyright__ = default(string);
			var version__ = default(string);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "ProjectSettings");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Name":
							{
								reader.ThrowIfNull("value of Text type", "Name", "ProjectSettings");
								reader.ThrowIfNotValue();

								name__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 7:
					{
						switch (propertyName)
						{
							case "Version":
							{
								reader.ThrowIfNull("value of Text type", "Version", "ProjectSettings");
								reader.ThrowIfNotValue();

								version__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 9:
					{
						switch (propertyName)
						{
							case "Languages":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								languages__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							case "Copyright":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								copyright__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 15:
					{
						switch (propertyName)
						{
							case "PrimaryLanguage":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								primaryLanguage__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___projectSetting = new ProjectSetting(id__, name__, primaryLanguage__, languages__, copyright__, version__);
			return ___projectSetting;
		}

		private DocumentCollection<ParameterId,Parameter> ReadParameterCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Parameter>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadParameter(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Parameter>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<ParameterId,Parameter>.Empty;
			}
			else
			{
				return new DocumentCollection<ParameterId,Parameter>(collection, document => document.Id);
			}
		}

		private Parameter ReadParameter(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(ParameterId);
			var minValue__ = default(Nullable<float>);
			var maxValue__ = default(Nullable<float>);
			var minValueParameter__ = default(DocumentReference<Parameter>);
			var maxValueParameter__ = default(DocumentReference<Parameter>);
			var valueKind__ = default(ParameterValueKind);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of PickList type", "Id", "Parameter");
								reader.ThrowIfNotValue();

								id__ = (ParameterId)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 8:
					{
						switch (propertyName)
						{
							case "MinValue":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								minValue__ = (Nullable<float>)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							case "MaxValue":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								maxValue__ = (Nullable<float>)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 9:
					{
						switch (propertyName)
						{
							case "ValueKind":
							{
								reader.ThrowIfNull("value of PickList type", "ValueKind", "Parameter");
								reader.ThrowIfNotValue();

								valueKind__ = (ParameterValueKind)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 17:
					{
						switch (propertyName)
						{
							case "MinValueParameter":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								minValueParameter__ = this.ReadDocumentReference<Parameter>(reader, this.FindDocument);
								break;
							}
							case "MaxValueParameter":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								maxValueParameter__ = this.ReadDocumentReference<Parameter>(reader, this.FindDocument);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___parameter = new Parameter(id__, minValue__, maxValue__, minValueParameter__, maxValueParameter__, valueKind__);
			return ___parameter;
		}

		private DocumentCollection<int,ParameterValue> ReadParameterValueCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<ParameterValue>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadParameterValue(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<ParameterValue>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<int,ParameterValue>.Empty;
			}
			else
			{
				return new DocumentCollection<int,ParameterValue>(collection, document => document.Id);
			}
		}

		private ParameterValue ReadParameterValue(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(int);
			var parameter__ = default(DocumentReference<Parameter>);
			var @value__ = default(float);
			var condition__ = default(DocumentReference<Condition>);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Integer type", "Id", "ParameterValue");
								reader.ThrowIfNotValue();

								id__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 5:
					{
						switch (propertyName)
						{
							case "Value":
							{
								reader.ThrowIfNull("value of Number type", "Value", "ParameterValue");
								reader.ThrowIfNotValue();

								@value__ = (float)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 9:
					{
						switch (propertyName)
						{
							case "Parameter":
							{
								reader.ThrowIfNull("value of Reference type", "Parameter", "ParameterValue");
								parameter__ = this.ReadDocumentReference<Parameter>(reader, this.FindDocument);
								break;
							}
							case "Condition":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								condition__ = this.ReadDocumentReference<Condition>(reader, this.FindDocument);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___parameterValue = new ParameterValue(id__, parameter__, @value__, condition__);
			return ___parameterValue;
		}

		private DocumentCollection<string,Provision> ReadProvisionCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Provision>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadProvision(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Provision>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,Provision>.Empty;
			}
			else
			{
				return new DocumentCollection<string,Provision>(collection, document => document.Id);
			}
		}

		private Provision ReadProvision(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var cost__ = default(int);
			var item__ = default(Item);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "Provision");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Cost":
							{
								reader.ThrowIfNull("value of Integer type", "Cost", "Provision");
								reader.ThrowIfNotValue();

								cost__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							case "Item":
							{
								reader.ThrowIfNull("value of Document type", "Item", "Provision");
									item__ = this.ReadItem(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___provision = new Provision(id__, cost__, item__);
			return ___provision;
		}

		private DocumentCollection<string,Hero> ReadHeroCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Hero>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadHero(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Hero>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,Hero>.Empty;
			}
			else
			{
				return new DocumentCollection<string,Hero>(collection, document => document.Id);
			}
		}

		private Hero ReadHero(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var name__ = LocalizedString.Empty;
			var bio__ = LocalizedString.Empty;
			var religious__ = default(bool);
			var dislikeHeroes__ = DocumentReferenceCollection<Hero>.Empty;
			var provisions__ = default(DocumentReference<Provision>);
			var provisionsCount__ = default(int);
			var movementForward__ = default(int);
			var movementBackward__ = default(int);
			var protection__ = default(int);
			var accuracyModifier__ = default(int);
			var stunResistance__ = default(float);
			var blightResistance__ = default(float);
			var diseaseResistance__ = default(float);
			var deathBlowResistance__ = default(float);
			var moveResistance__ = default(float);
			var bleedResistance__ = default(float);
			var debuffResistance__ = default(float);
			var trapResistance__ = default(float);
			var armors__ = DocumentCollection<string,Armor>.Empty;
			var weapons__ = DocumentCollection<string,Weapon>.Empty;
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "Hero");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 3:
					{
						switch (propertyName)
						{
							case "Bio":
							{
								reader.ThrowIfNull("value of LocalizedText type", "Bio", "Hero");
								bio__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Name":
							{
								reader.ThrowIfNull("value of LocalizedText type", "Name", "Hero");
								name__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 6:
					{
						switch (propertyName)
						{
							case "Armors":
							{
								reader.ThrowIfNull("value of DocumentCollection type", "Armors", "Hero");
								armors__ = this.ReadArmorCollection(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 7:
					{
						switch (propertyName)
						{
							case "Weapons":
							{
								reader.ThrowIfNull("value of DocumentCollection type", "Weapons", "Hero");
								weapons__ = this.ReadWeaponCollection(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 9:
					{
						switch (propertyName)
						{
							case "Religious":
							{
								reader.ThrowIfNull("value of Logical type", "Religious", "Hero");
								reader.ThrowIfNotValue();

								religious__ = (bool)reader.Node.AsBoolean;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 10:
					{
						switch (propertyName)
						{
							case "Provisions":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								provisions__ = this.ReadDocumentReference<Provision>(reader, this.FindDocument);
								break;
							}
							case "Protection":
							{
								reader.ThrowIfNull("value of Integer type", "Protection", "Hero");
								reader.ThrowIfNotValue();

								protection__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 13:
					{
						switch (propertyName)
						{
							case "DislikeHeroes":
							{
								reader.ThrowIfNull("value of ReferenceCollection type", "DislikeHeroes", "Hero");
								dislikeHeroes__ = this.ReadDocumentReferenceCollection<Hero>(reader, this.FindDocument);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 14:
					{
						switch (propertyName)
						{
							case "StunResistance":
							{
								reader.ThrowIfNull("value of Number type", "StunResistance", "Hero");
								reader.ThrowIfNotValue();

								stunResistance__ = (float)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							case "MoveResistance":
							{
								reader.ThrowIfNull("value of Number type", "MoveResistance", "Hero");
								reader.ThrowIfNotValue();

								moveResistance__ = (float)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							case "TrapResistance":
							{
								reader.ThrowIfNull("value of Number type", "TrapResistance", "Hero");
								reader.ThrowIfNotValue();

								trapResistance__ = (float)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 15:
					{
						switch (propertyName)
						{
							case "ProvisionsCount":
							{
								reader.ThrowIfNull("value of Integer type", "ProvisionsCount", "Hero");
								reader.ThrowIfNotValue();

								provisionsCount__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							case "MovementForward":
							{
								reader.ThrowIfNull("value of Integer type", "MovementForward", "Hero");
								reader.ThrowIfNotValue();

								movementForward__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							case "BleedResistance":
							{
								reader.ThrowIfNull("value of Number type", "BleedResistance", "Hero");
								reader.ThrowIfNotValue();

								bleedResistance__ = (float)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 16:
					{
						switch (propertyName)
						{
							case "MovementBackward":
							{
								reader.ThrowIfNull("value of Integer type", "MovementBackward", "Hero");
								reader.ThrowIfNotValue();

								movementBackward__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							case "AccuracyModifier":
							{
								reader.ThrowIfNull("value of Integer type", "AccuracyModifier", "Hero");
								reader.ThrowIfNotValue();

								accuracyModifier__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							case "BlightResistance":
							{
								reader.ThrowIfNull("value of Number type", "BlightResistance", "Hero");
								reader.ThrowIfNotValue();

								blightResistance__ = (float)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							case "DebuffResistance":
							{
								reader.ThrowIfNull("value of Number type", "DebuffResistance", "Hero");
								reader.ThrowIfNotValue();

								debuffResistance__ = (float)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 17:
					{
						switch (propertyName)
						{
							case "DiseaseResistance":
							{
								reader.ThrowIfNull("value of Number type", "DiseaseResistance", "Hero");
								reader.ThrowIfNotValue();

								diseaseResistance__ = (float)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 19:
					{
						switch (propertyName)
						{
							case "DeathBlowResistance":
							{
								reader.ThrowIfNull("value of Number type", "DeathBlowResistance", "Hero");
								reader.ThrowIfNotValue();

								deathBlowResistance__ = (float)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___hero = new Hero(id__, name__, bio__, religious__, dislikeHeroes__, provisions__, provisionsCount__, movementForward__, movementBackward__, protection__, accuracyModifier__, stunResistance__, blightResistance__, diseaseResistance__, deathBlowResistance__, moveResistance__, bleedResistance__, debuffResistance__, trapResistance__, armors__, weapons__);
			return ___hero;
		}

		private DocumentCollection<string,Item> ReadItemCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Item>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadItem(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Item>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,Item>.Empty;
			}
			else
			{
				return new DocumentCollection<string,Item>(collection, document => document.Id);
			}
		}

		private Item ReadItem(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var name__ = LocalizedString.Empty;
			var description__ = LocalizedString.Empty;
			var stackSize__ = default(int);
			var goldValue__ = default(int);
			var activationEffects__ = DocumentCollection<int,ParameterValue>.Empty;
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "Item");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Name":
							{
								reader.ThrowIfNull("value of LocalizedText type", "Name", "Item");
								name__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 9:
					{
						switch (propertyName)
						{
							case "StackSize":
							{
								reader.ThrowIfNull("value of Integer type", "StackSize", "Item");
								reader.ThrowIfNotValue();

								stackSize__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							case "GoldValue":
							{
								reader.ThrowIfNull("value of Integer type", "GoldValue", "Item");
								reader.ThrowIfNotValue();

								goldValue__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 11:
					{
						switch (propertyName)
						{
							case "Description":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								description__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 17:
					{
						switch (propertyName)
						{
							case "ActivationEffects":
							{
								reader.ThrowIfNull("value of DocumentCollection type", "ActivationEffects", "Item");
								activationEffects__ = this.ReadParameterValueCollection(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___item = new Item(id__, name__, description__, stackSize__, goldValue__, activationEffects__);
			return ___item;
		}

		private DocumentCollection<string,Location> ReadLocationCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Location>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadLocation(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Location>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,Location>.Empty;
			}
			else
			{
				return new DocumentCollection<string,Location>(collection, document => document.Id);
			}
		}

		private Location ReadLocation(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var name__ = LocalizedString.Empty;
			var flags__ = default(Nullable<LocationFlags>);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "Location");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Name":
							{
								reader.ThrowIfNull("value of LocalizedText type", "Name", "Location");
								name__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 5:
					{
						switch (propertyName)
						{
							case "Flags":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								flags__ = (Nullable<LocationFlags>)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___location = new Location(id__, name__, flags__);
			return ___location;
		}

		private DocumentCollection<string,Trinket> ReadTrinketCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Trinket>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadTrinket(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Trinket>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,Trinket>.Empty;
			}
			else
			{
				return new DocumentCollection<string,Trinket>(collection, document => document.Id);
			}
		}

		private Trinket ReadTrinket(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var rarity__ = default(TrinketRarity);
			var originDungeon__ = default(DocumentReference<Location>);
			var heroRestriction__ = default(DocumentReference<Hero>);
			var item__ = default(Item);
			var effects__ = DocumentCollection<int,ParameterValue>.Empty;
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "Trinket");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Item":
							{
								reader.ThrowIfNull("value of Document type", "Item", "Trinket");
									item__ = this.ReadItem(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 6:
					{
						switch (propertyName)
						{
							case "Rarity":
							{
								reader.ThrowIfNull("value of PickList type", "Rarity", "Trinket");
								reader.ThrowIfNotValue();

								rarity__ = (TrinketRarity)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 7:
					{
						switch (propertyName)
						{
							case "Effects":
							{
								reader.ThrowIfNull("value of DocumentCollection type", "Effects", "Trinket");
								effects__ = this.ReadParameterValueCollection(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 13:
					{
						switch (propertyName)
						{
							case "OriginDungeon":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								originDungeon__ = this.ReadDocumentReference<Location>(reader, this.FindDocument);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 15:
					{
						switch (propertyName)
						{
							case "HeroRestriction":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								heroRestriction__ = this.ReadDocumentReference<Hero>(reader, this.FindDocument);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___trinket = new Trinket(id__, rarity__, originDungeon__, heroRestriction__, item__, effects__);
			return ___trinket;
		}

		private DocumentCollection<string,Monster> ReadMonsterCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Monster>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadMonster(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Monster>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,Monster>.Empty;
			}
			else
			{
				return new DocumentCollection<string,Monster>(collection, document => document.Id);
			}
		}

		private Monster ReadMonster(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var name__ = LocalizedString.Empty;
			var type__ = default(MonsterType);
			var secondType__ = default(Nullable<MonsterType>);
			var parameters__ = DocumentCollection<int,ParameterValue>.Empty;
			var locations__ = DocumentReferenceCollection<Location>.Empty;
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "Monster");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Name":
							{
								reader.ThrowIfNull("value of LocalizedText type", "Name", "Monster");
								name__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							case "Type":
							{
								reader.ThrowIfNull("value of PickList type", "Type", "Monster");
								reader.ThrowIfNotValue();

								type__ = (MonsterType)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 9:
					{
						switch (propertyName)
						{
							case "Locations":
							{
								reader.ThrowIfNull("value of ReferenceCollection type", "Locations", "Monster");
								locations__ = this.ReadDocumentReferenceCollection<Location>(reader, this.FindDocument);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 10:
					{
						switch (propertyName)
						{
							case "SecondType":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								secondType__ = (Nullable<MonsterType>)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							case "Parameters":
							{
								reader.ThrowIfNull("value of DocumentCollection type", "Parameters", "Monster");
								parameters__ = this.ReadParameterValueCollection(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___monster = new Monster(id__, name__, type__, secondType__, parameters__, locations__);
			return ___monster;
		}

		private DocumentCollection<int,Loot> ReadLootCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Loot>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadLoot(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Loot>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<int,Loot>.Empty;
			}
			else
			{
				return new DocumentCollection<int,Loot>(collection, document => document.Id);
			}
		}

		private Loot ReadLoot(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(int);
			var type__ = default(LootType);
			var amount__ = default(Nullable<int>);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Integer type", "Id", "Loot");
								reader.ThrowIfNotValue();

								id__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Type":
							{
								reader.ThrowIfNull("value of PickList type", "Type", "Loot");
								reader.ThrowIfNotValue();

								type__ = (LootType)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 6:
					{
						switch (propertyName)
						{
							case "Amount":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								amount__ = (Nullable<int>)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___loot = new Loot(id__, type__, amount__);
			return ___loot;
		}

		private DocumentCollection<int,CombatEffect> ReadCombatEffectCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<CombatEffect>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadCombatEffect(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<CombatEffect>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<int,CombatEffect>.Empty;
			}
			else
			{
				return new DocumentCollection<int,CombatEffect>(collection, document => document.Id);
			}
		}

		private CombatEffect ReadCombatEffect(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(int);
			var changes__ = DocumentCollection<int,ParameterValue>.Empty;
			var duration__ = default(Nullable<int>);
			var durationUnit__ = default(DurationUnit);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Integer type", "Id", "CombatEffect");
								reader.ThrowIfNotValue();

								id__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 7:
					{
						switch (propertyName)
						{
							case "Changes":
							{
								reader.ThrowIfNull("value of DocumentCollection type", "Changes", "CombatEffect");
								changes__ = this.ReadParameterValueCollection(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 8:
					{
						switch (propertyName)
						{
							case "Duration":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								duration__ = (Nullable<int>)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 12:
					{
						switch (propertyName)
						{
							case "DurationUnit":
							{
								reader.ThrowIfNull("value of PickList type", "DurationUnit", "CombatEffect");
								reader.ThrowIfNotValue();

								durationUnit__ = (DurationUnit)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___combatEffect = new CombatEffect(id__, changes__, duration__, durationUnit__);
			return ___combatEffect;
		}

		private DocumentCollection<int,CurioCleansingOption> ReadCurioCleansingOptionCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<CurioCleansingOption>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadCurioCleansingOption(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<CurioCleansingOption>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<int,CurioCleansingOption>.Empty;
			}
			else
			{
				return new DocumentCollection<int,CurioCleansingOption>(collection, document => document.Id);
			}
		}

		private CurioCleansingOption ReadCurioCleansingOption(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(int);
			var chance__ = default(float);
			var item__ = default(DocumentReference<Item>);
			var loot__ = DocumentCollection<int,Loot>.Empty;
			var quirkChance__ = default(Nullable<float>);
			var diseaseChance__ = default(Nullable<float>);
			var effects__ = DocumentCollection<int,ParameterValue>.Empty;
			var itemIsConsumed__ = default(bool);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Integer type", "Id", "CurioCleansingOption");
								reader.ThrowIfNotValue();

								id__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Item":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								item__ = this.ReadDocumentReference<Item>(reader, this.FindDocument);
								break;
							}
							case "Loot":
							{
								reader.ThrowIfNull("value of DocumentCollection type", "Loot", "CurioCleansingOption");
								loot__ = this.ReadLootCollection(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 6:
					{
						switch (propertyName)
						{
							case "Chance":
							{
								reader.ThrowIfNull("value of Number type", "Chance", "CurioCleansingOption");
								reader.ThrowIfNotValue();

								chance__ = (float)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 7:
					{
						switch (propertyName)
						{
							case "Effects":
							{
								reader.ThrowIfNull("value of DocumentCollection type", "Effects", "CurioCleansingOption");
								effects__ = this.ReadParameterValueCollection(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 11:
					{
						switch (propertyName)
						{
							case "QuirkChance":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								quirkChance__ = (Nullable<float>)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 13:
					{
						switch (propertyName)
						{
							case "DiseaseChance":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								diseaseChance__ = (Nullable<float>)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 14:
					{
						switch (propertyName)
						{
							case "ItemIsConsumed":
							{
								reader.ThrowIfNull("value of Logical type", "ItemIsConsumed", "CurioCleansingOption");
								reader.ThrowIfNotValue();

								itemIsConsumed__ = (bool)reader.Node.AsBoolean;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___curioCleansingOption = new CurioCleansingOption(id__, chance__, item__, loot__, quirkChance__, diseaseChance__, effects__, itemIsConsumed__);
			return ___curioCleansingOption;
		}

		private DocumentCollection<string,Curio> ReadCurioCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Curio>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadCurio(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Curio>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,Curio>.Empty;
			}
			else
			{
				return new DocumentCollection<string,Curio>(collection, document => document.Id);
			}
		}

		private Curio ReadCurio(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var type__ = default(CurioType);
			var name__ = LocalizedString.Empty;
			var description__ = LocalizedString.Empty;
			var cleansingOptions__ = DocumentCollection<int,CurioCleansingOption>.Empty;
			var placementRestictions__ = default(CurioPlacementRestictions);
			var locations__ = DocumentReferenceCollection<Location>.Empty;
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "Curio");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Type":
							{
								reader.ThrowIfNull("value of MultiPickList type", "Type", "Curio");
								reader.ThrowIfNotValue();

								type__ = (CurioType)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							case "Name":
							{
								reader.ThrowIfNull("value of LocalizedText type", "Name", "Curio");
								name__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 9:
					{
						switch (propertyName)
						{
							case "Locations":
							{
								reader.ThrowIfNull("value of ReferenceCollection type", "Locations", "Curio");
								locations__ = this.ReadDocumentReferenceCollection<Location>(reader, this.FindDocument);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 11:
					{
						switch (propertyName)
						{
							case "Description":
							{
								reader.ThrowIfNull("value of LocalizedText type", "Description", "Curio");
								description__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 16:
					{
						switch (propertyName)
						{
							case "CleansingOptions":
							{
								reader.ThrowIfNull("value of DocumentCollection type", "CleansingOptions", "Curio");
								cleansingOptions__ = this.ReadCurioCleansingOptionCollection(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 20:
					{
						switch (propertyName)
						{
							case "PlacementRestictions":
							{
								reader.ThrowIfNull("value of MultiPickList type", "PlacementRestictions", "Curio");
								reader.ThrowIfNotValue();

								placementRestictions__ = (CurioPlacementRestictions)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___curio = new Curio(id__, type__, name__, description__, cleansingOptions__, placementRestictions__, locations__);
			return ___curio;
		}

		private DocumentCollection<string,Disease> ReadDiseaseCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Disease>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadDisease(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Disease>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,Disease>.Empty;
			}
			else
			{
				return new DocumentCollection<string,Disease>(collection, document => document.Id);
			}
		}

		private Disease ReadDisease(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var name__ = LocalizedString.Empty;
			var effects__ = DocumentCollection<int,ParameterValue>.Empty;
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "Disease");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Name":
							{
								reader.ThrowIfNull("value of LocalizedText type", "Name", "Disease");
								name__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 7:
					{
						switch (propertyName)
						{
							case "Effects":
							{
								reader.ThrowIfNull("value of DocumentCollection type", "Effects", "Disease");
								effects__ = this.ReadParameterValueCollection(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___disease = new Disease(id__, name__, effects__);
			return ___disease;
		}

		private DocumentCollection<string,Quirk> ReadQuirkCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Quirk>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadQuirk(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Quirk>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,Quirk>.Empty;
			}
			else
			{
				return new DocumentCollection<string,Quirk>(collection, document => document.Id);
			}
		}

		private Quirk ReadQuirk(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var name__ = LocalizedString.Empty;
			var isPositive__ = default(bool);
			var effects__ = DocumentCollection<int,ParameterValue>.Empty;
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "Quirk");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Name":
							{
								reader.ThrowIfNull("value of LocalizedText type", "Name", "Quirk");
								name__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 7:
					{
						switch (propertyName)
						{
							case "Effects":
							{
								reader.ThrowIfNull("value of DocumentCollection type", "Effects", "Quirk");
								effects__ = this.ReadParameterValueCollection(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 10:
					{
						switch (propertyName)
						{
							case "IsPositive":
							{
								reader.ThrowIfNull("value of Logical type", "IsPositive", "Quirk");
								reader.ThrowIfNotValue();

								isPositive__ = (bool)reader.Node.AsBoolean;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___quirk = new Quirk(id__, name__, isPositive__, effects__);
			return ___quirk;
		}

		private DocumentCollection<string,Condition> ReadConditionsCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Condition>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadConditions(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Condition>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,Condition>.Empty;
			}
			else
			{
				return new DocumentCollection<string,Condition>(collection, document => document.Id);
			}
		}

		private Condition ReadConditions(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var description__ = LocalizedString.Empty;
			var check__ = default(ConditionsCheckFormula);
			var unboundCheck__ = default(IReadOnlyDictionary<string,object>);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "Conditions");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 5:
					{
						switch (propertyName)
						{
							case "Check":
							{
								reader.ThrowIfNull("value of Formula type", "Check", "Conditions");
								check__ = new ConditionsCheckFormula(reader.ReadObject());
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 11:
					{
						switch (propertyName)
						{
							case "Description":
							{
								reader.ThrowIfNull("value of LocalizedText type", "Description", "Conditions");
								description__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 12:
					{
						switch (propertyName)
						{
							case "UnboundCheck":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								unboundCheck__ = reader.ReadObject();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___condition = new Condition(id__, description__, check__, unboundCheck__);
			if (___condition.Check != null) {
				___condition.Check.Context.@this = ___condition;
			}
			return ___condition;
		}

		private DocumentCollection<string,Weapon> ReadWeaponCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Weapon>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadWeapon(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Weapon>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,Weapon>.Empty;
			}
			else
			{
				return new DocumentCollection<string,Weapon>(collection, document => document.Id);
			}
		}

		private Weapon ReadWeapon(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var name__ = LocalizedString.Empty;
			var damageFrom__ = default(int);
			var damageTo__ = default(int);
			var criticalStrikeChance__ = default(float);
			var speed__ = default(int);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "Weapon");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Name":
							{
								reader.ThrowIfNull("value of LocalizedText type", "Name", "Weapon");
								name__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 5:
					{
						switch (propertyName)
						{
							case "Speed":
							{
								reader.ThrowIfNull("value of Integer type", "Speed", "Weapon");
								reader.ThrowIfNotValue();

								speed__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 8:
					{
						switch (propertyName)
						{
							case "DamageTo":
							{
								reader.ThrowIfNull("value of Integer type", "DamageTo", "Weapon");
								reader.ThrowIfNotValue();

								damageTo__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 10:
					{
						switch (propertyName)
						{
							case "DamageFrom":
							{
								reader.ThrowIfNull("value of Integer type", "DamageFrom", "Weapon");
								reader.ThrowIfNotValue();

								damageFrom__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 20:
					{
						switch (propertyName)
						{
							case "CriticalStrikeChance":
							{
								reader.ThrowIfNull("value of Number type", "CriticalStrikeChance", "Weapon");
								reader.ThrowIfNotValue();

								criticalStrikeChance__ = (float)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___weapon = new Weapon(id__, name__, damageFrom__, damageTo__, criticalStrikeChance__, speed__);
			return ___weapon;
		}

		private DocumentCollection<string,Armor> ReadArmorCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<Armor>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadArmor(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<Armor>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<string,Armor>.Empty;
			}
			else
			{
				return new DocumentCollection<string,Armor>(collection, document => document.Id);
			}
		}

		private Armor ReadArmor(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(string);
			var name__ = LocalizedString.Empty;
			var dodge__ = default(float);
			var hitPoints__ = default(int);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Text type", "Id", "Armor");
								reader.ThrowIfNotValue();

								id__ = (string)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Name":
							{
								reader.ThrowIfNull("value of LocalizedText type", "Name", "Armor");
								name__ = this.ReadLocalizedString(reader, languageSwitcher);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 5:
					{
						switch (propertyName)
						{
							case "Dodge":
							{
								reader.ThrowIfNull("value of Number type", "Dodge", "Armor");
								reader.ThrowIfNotValue();

								dodge__ = (float)reader.Node.AsSingle;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 9:
					{
						switch (propertyName)
						{
							case "HitPoints":
							{
								reader.ThrowIfNull("value of Integer type", "HitPoints", "Armor");
								reader.ThrowIfNotValue();

								hitPoints__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___armor = new Armor(id__, name__, dodge__, hitPoints__);
			return ___armor;
		}

		private DocumentCollection<int,ItemWithCount> ReadItemWithCountCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<ItemWithCount>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadItemWithCount(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<ItemWithCount>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<int,ItemWithCount>.Empty;
			}
			else
			{
				return new DocumentCollection<int,ItemWithCount>(collection, document => document.Id);
			}
		}

		private ItemWithCount ReadItemWithCount(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(int);
			var item__ = default(DocumentReference<Item>);
			var count__ = default(int);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Integer type", "Id", "ItemWithCount");
								reader.ThrowIfNotValue();

								id__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Item":
							{
								reader.ThrowIfNull("value of Reference type", "Item", "ItemWithCount");
								item__ = this.ReadDocumentReference<Item>(reader, this.FindDocument);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 5:
					{
						switch (propertyName)
						{
							case "Count":
							{
								reader.ThrowIfNull("value of Integer type", "Count", "ItemWithCount");
								reader.ThrowIfNotValue();

								count__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___itemWithCount = new ItemWithCount(id__, item__, count__);
			return ___itemWithCount;
		}

		private DocumentCollection<int,StartingSet> ReadStartingSetCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			var collection = default(List<StartingSet>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadStartingSet(reader);
				if (document == null)
				{
					continue; // patched out
				}
				if (collection == null)
				{
					collection = new List<StartingSet>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			reader.ReadArrayEnd();
			if (collection == null)
			{
				return DocumentCollection<int,StartingSet>.Empty;
			}
			else
			{
				return new DocumentCollection<int,StartingSet>(collection, document => document.Id);
			}
		}

		private StartingSet ReadStartingSet(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var id__ = default(int);
			var items__ = DocumentCollection<int,ItemWithCount>.Empty;
			var heroes__ = DocumentReferenceCollection<Hero>.Empty;
			var location__ = default(DocumentReference<Location>);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								if (reader.IsNull())
								{
									reader.SkipRestOfObject(nextToken: false);
									return null; // patched out
								}
								reader.ThrowIfNull("value of Integer type", "Id", "StartingSet");
								reader.ThrowIfNotValue();

								id__ = (int)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 5:
					{
						switch (propertyName)
						{
							case "Items":
							{
								reader.ThrowIfNull("value of DocumentCollection type", "Items", "StartingSet");
								items__ = this.ReadItemWithCountCollection(reader);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 6:
					{
						switch (propertyName)
						{
							case "Heroes":
							{
								reader.ThrowIfNull("value of ReferenceCollection type", "Heroes", "StartingSet");
								heroes__ = this.ReadDocumentReferenceCollection<Hero>(reader, this.FindDocument);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 8:
					{
						switch (propertyName)
						{
							case "Location":
							{
								reader.ThrowIfNull("value of Reference type", "Location", "StartingSet");
								location__ = this.ReadDocumentReference<Location>(reader, this.FindDocument);
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var ___startingSet = new StartingSet(id__, items__, heroes__, location__);
			return ___startingSet;
		}
		private LocalizedString ReadLocalizedString(Formatters.GameDataReader reader, LocalizedString.LanguageSwitcher languageSwitcher, bool nextToken = true)
		{
			if (languageSwitcher == null) throw new ArgumentNullException(nameof(languageSwitcher));

			var locStringDictionary = default(List<KeyValuePair<string, string>>);
			reader.ReadObjectBegin();
			while(reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var key = reader.ReadMember();
				var value = reader.ReadAny()?.ToString();
				if (string.IsNullOrEmpty(key) || string.IsNullOrEmpty(value))
				{
					continue;
				}
				if (locStringDictionary == null)
				{
					locStringDictionary = new List<KeyValuePair<string, string>>(10);
				}
				locStringDictionary.Add(new KeyValuePair<string, string>(key, value));
			}
			reader.ReadObjectEnd(nextToken);

			if (locStringDictionary == null)
			{
				return LocalizedString.Empty;
			}
			else
			{
				return new LocalizedString(locStringDictionary, languageSwitcher);
			}
		}
		private DocumentReferenceCollection<DocumentT> ReadDocumentReferenceCollection<DocumentT>(Formatters.GameDataReader reader, Func<string, object, Document> findDocument, bool nextToken = true) where DocumentT : Document
		{
			var referenceCollection = default(List<DocumentReference<DocumentT>>);
			reader.ReadArrayBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray)
			{
				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var documentReference = this.ReadDocumentReference<DocumentT>(reader, findDocument);
				if (documentReference == null)
				{
					continue;
				}

				if (referenceCollection == null) { referenceCollection = new List<DocumentReference<DocumentT>>(5); }
				referenceCollection.Add(documentReference);
			}
			reader.ReadArrayEnd(nextToken);
			if (referenceCollection == null)
			{
				return DocumentReferenceCollection<DocumentT>.Empty;
			}
			else
			{
				return new DocumentReferenceCollection<DocumentT>(referenceCollection);
			}
		}
		private DocumentReference<DocumentT> ReadDocumentReference<DocumentT>(Formatters.GameDataReader reader, Func<string, object, Document> findDocument, bool nextToken = true) where DocumentT : Document
		{
			if (findDocument == null) throw new ArgumentNullException(nameof(findDocument));

			var reference = default(DocumentReference<DocumentT>);
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var key = reader.ReadMember();
				if (key == "Id")
				{
					reference = new DocumentReference<DocumentT>(reader.ReadAny(), findDocument);
				}
				else
				{
					reader.SkipAny();
				}
			}

			 // TODO maybe throw exception if reference is null (broken)?

			reader.ReadObjectEnd(nextToken);
			return reference;
		}

		#endregion // Read Game Data
		#region Visitors
		public void ApplyVisitor(Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			foreach (var document in this.EnumerateRoots())
			{
				visitor.Visit(document);
			}
		}

		private void ResolveAllReferences()
		{
			var dereferencingVisitor = new DereferencingVisitor();
			this.ApplyVisitor(dereferencingVisitor);
		}

		private void FindAllDocuments()
		{
			var findingVisitor = new FindingVisitor();
			this.ApplyVisitor(findingVisitor);

			if (findingVisitor.AllProjectSettings?.Count > 0)
			{
				this.allDocuments._projectSettings = new DocumentCollection<string,ProjectSetting>(findingVisitor.AllProjectSettings, document => document.Id);
			}
			if (findingVisitor.AllParameter?.Count > 0)
			{
				this.allDocuments._parameters = new DocumentCollection<ParameterId,Parameter>(findingVisitor.AllParameter, document => document.Id);
			}
			if (findingVisitor.AllParameterValue?.Count > 0)
			{
				this.allDocuments._parameterValues = new DocumentCollection<int,ParameterValue>(findingVisitor.AllParameterValue, document => document.Id);
			}
			if (findingVisitor.AllProvision?.Count > 0)
			{
				this.allDocuments._provisions = new DocumentCollection<string,Provision>(findingVisitor.AllProvision, document => document.Id);
			}
			if (findingVisitor.AllHero?.Count > 0)
			{
				this.allDocuments._heros = new DocumentCollection<string,Hero>(findingVisitor.AllHero, document => document.Id);
			}
			if (findingVisitor.AllItem?.Count > 0)
			{
				this.allDocuments._items = new DocumentCollection<string,Item>(findingVisitor.AllItem, document => document.Id);
			}
			if (findingVisitor.AllLocation?.Count > 0)
			{
				this.allDocuments._locations = new DocumentCollection<string,Location>(findingVisitor.AllLocation, document => document.Id);
			}
			if (findingVisitor.AllTrinket?.Count > 0)
			{
				this.allDocuments._trinkets = new DocumentCollection<string,Trinket>(findingVisitor.AllTrinket, document => document.Id);
			}
			if (findingVisitor.AllMonster?.Count > 0)
			{
				this.allDocuments._monsters = new DocumentCollection<string,Monster>(findingVisitor.AllMonster, document => document.Id);
			}
			if (findingVisitor.AllLoot?.Count > 0)
			{
				this.allDocuments._loots = new DocumentCollection<int,Loot>(findingVisitor.AllLoot, document => document.Id);
			}
			if (findingVisitor.AllCombatEffect?.Count > 0)
			{
				this.allDocuments._combatEffects = new DocumentCollection<int,CombatEffect>(findingVisitor.AllCombatEffect, document => document.Id);
			}
			if (findingVisitor.AllCurioCleansingOption?.Count > 0)
			{
				this.allDocuments._curioCleansingOptions = new DocumentCollection<int,CurioCleansingOption>(findingVisitor.AllCurioCleansingOption, document => document.Id);
			}
			if (findingVisitor.AllCurio?.Count > 0)
			{
				this.allDocuments._curios = new DocumentCollection<string,Curio>(findingVisitor.AllCurio, document => document.Id);
			}
			if (findingVisitor.AllDisease?.Count > 0)
			{
				this.allDocuments._diseases = new DocumentCollection<string,Disease>(findingVisitor.AllDisease, document => document.Id);
			}
			if (findingVisitor.AllQuirk?.Count > 0)
			{
				this.allDocuments._quirks = new DocumentCollection<string,Quirk>(findingVisitor.AllQuirk, document => document.Id);
			}
			if (findingVisitor.AllConditions?.Count > 0)
			{
				this.allDocuments._conditions = new DocumentCollection<string,Condition>(findingVisitor.AllConditions, document => document.Id);
			}
			if (findingVisitor.AllWeapon?.Count > 0)
			{
				this.allDocuments._weapons = new DocumentCollection<string,Weapon>(findingVisitor.AllWeapon, document => document.Id);
			}
			if (findingVisitor.AllArmor?.Count > 0)
			{
				this.allDocuments._armors = new DocumentCollection<string,Armor>(findingVisitor.AllArmor, document => document.Id);
			}
			if (findingVisitor.AllItemWithCount?.Count > 0)
			{
				this.allDocuments._itemWithCounts = new DocumentCollection<int,ItemWithCount>(findingVisitor.AllItemWithCount, document => document.Id);
			}
			if (findingVisitor.AllStartingSet?.Count > 0)
			{
				this.allDocuments._startingSets = new DocumentCollection<int,StartingSet>(findingVisitor.AllStartingSet, document => document.Id);
			}
		}

		public class Visitor
		{
			#region Visit Methods

			public virtual void Visit(Document document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document is ProjectSetting ___projectSetting)
				{
					this.Visit(___projectSetting);
				}
				else
				if (document is Parameter ___parameter)
				{
					this.Visit(___parameter);
				}
				else
				if (document is ParameterValue ___parameterValue)
				{
					this.Visit(___parameterValue);
				}
				else
				if (document is Provision ___provision)
				{
					this.Visit(___provision);
				}
				else
				if (document is Hero ___hero)
				{
					this.Visit(___hero);
				}
				else
				if (document is Item ___item)
				{
					this.Visit(___item);
				}
				else
				if (document is Location ___location)
				{
					this.Visit(___location);
				}
				else
				if (document is Trinket ___trinket)
				{
					this.Visit(___trinket);
				}
				else
				if (document is Monster ___monster)
				{
					this.Visit(___monster);
				}
				else
				if (document is Loot ___loot)
				{
					this.Visit(___loot);
				}
				else
				if (document is CombatEffect ___combatEffect)
				{
					this.Visit(___combatEffect);
				}
				else
				if (document is CurioCleansingOption ___curioCleansingOption)
				{
					this.Visit(___curioCleansingOption);
				}
				else
				if (document is Curio ___curio)
				{
					this.Visit(___curio);
				}
				else
				if (document is Disease ___disease)
				{
					this.Visit(___disease);
				}
				else
				if (document is Quirk ___quirk)
				{
					this.Visit(___quirk);
				}
				else
				if (document is Condition ___condition)
				{
					this.Visit(___condition);
				}
				else
				if (document is Weapon ___weapon)
				{
					this.Visit(___weapon);
				}
				else
				if (document is Armor ___armor)
				{
					this.Visit(___armor);
				}
				else
				if (document is ItemWithCount ___itemWithCount)
				{
					this.Visit(___itemWithCount);
				}
				else
				if (document is StartingSet ___startingSet)
				{
					this.Visit(___startingSet);
				}
				else
				{
					throw new ArgumentException($"Unknown document type '{document.GetType()}'.", nameof(document));
				}
			}
			public virtual void Visit(ProjectSetting document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			public virtual void Visit(Parameter document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			public virtual void Visit(ParameterValue document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			public virtual void Visit(Provision document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document.Item != null)
				{
					this.Visit((Document) document.Item);
				}
			}
			public virtual void Visit(Hero document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document.Armors != null)
				{
					foreach (var subDocument in document.Armors)
					{
						this.Visit((Document) subDocument);
					}
				}
				if (document.Weapons != null)
				{
					foreach (var subDocument in document.Weapons)
					{
						this.Visit((Document) subDocument);
					}
				}
			}
			public virtual void Visit(Item document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document.ActivationEffects != null)
				{
					foreach (var subDocument in document.ActivationEffects)
					{
						this.Visit((Document) subDocument);
					}
				}
			}
			public virtual void Visit(Location document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			public virtual void Visit(Trinket document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document.Item != null)
				{
					this.Visit((Document) document.Item);
				}
				if (document.Effects != null)
				{
					foreach (var subDocument in document.Effects)
					{
						this.Visit((Document) subDocument);
					}
				}
			}
			public virtual void Visit(Monster document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document.Parameters != null)
				{
					foreach (var subDocument in document.Parameters)
					{
						this.Visit((Document) subDocument);
					}
				}
			}
			public virtual void Visit(Loot document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			public virtual void Visit(CombatEffect document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document.Changes != null)
				{
					foreach (var subDocument in document.Changes)
					{
						this.Visit((Document) subDocument);
					}
				}
			}
			public virtual void Visit(CurioCleansingOption document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document.Loot != null)
				{
					foreach (var subDocument in document.Loot)
					{
						this.Visit((Document) subDocument);
					}
				}
				if (document.Effects != null)
				{
					foreach (var subDocument in document.Effects)
					{
						this.Visit((Document) subDocument);
					}
				}
			}
			public virtual void Visit(Curio document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document.CleansingOptions != null)
				{
					foreach (var subDocument in document.CleansingOptions)
					{
						this.Visit((Document) subDocument);
					}
				}
			}
			public virtual void Visit(Disease document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document.Effects != null)
				{
					foreach (var subDocument in document.Effects)
					{
						this.Visit((Document) subDocument);
					}
				}
			}
			public virtual void Visit(Quirk document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document.Effects != null)
				{
					foreach (var subDocument in document.Effects)
					{
						this.Visit((Document) subDocument);
					}
				}
			}
			public virtual void Visit(Condition document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			public virtual void Visit(Weapon document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			public virtual void Visit(Armor document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			public virtual void Visit(ItemWithCount document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			public virtual void Visit(StartingSet document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document.Items != null)
				{
					foreach (var subDocument in document.Items)
					{
						this.Visit((Document) subDocument);
					}
				}
			}
			#endregion
		}

		private class FindingVisitor : Visitor
		{
			public List<ProjectSetting> AllProjectSettings;
			public List<Parameter> AllParameter;
			public List<ParameterValue> AllParameterValue;
			public List<Provision> AllProvision;
			public List<Hero> AllHero;
			public List<Item> AllItem;
			public List<Location> AllLocation;
			public List<Trinket> AllTrinket;
			public List<Monster> AllMonster;
			public List<Loot> AllLoot;
			public List<CombatEffect> AllCombatEffect;
			public List<CurioCleansingOption> AllCurioCleansingOption;
			public List<Curio> AllCurio;
			public List<Disease> AllDisease;
			public List<Quirk> AllQuirk;
			public List<Condition> AllConditions;
			public List<Weapon> AllWeapon;
			public List<Armor> AllArmor;
			public List<ItemWithCount> AllItemWithCount;
			public List<StartingSet> AllStartingSet;
			#region Visit Methods

			public override void Visit(ProjectSetting document)
			{
				if (this.AllProjectSettings == null)
				{
					this.AllProjectSettings = new List<ProjectSetting>(6);
				}
				this.AllProjectSettings.Add(document);

				base.Visit(document);
			}
			public override void Visit(Parameter document)
			{
				if (this.AllParameter == null)
				{
					this.AllParameter = new List<Parameter>(44);
				}
				this.AllParameter.Add(document);

				base.Visit(document);
			}
			public override void Visit(ParameterValue document)
			{
				if (this.AllParameterValue == null)
				{
					this.AllParameterValue = new List<ParameterValue>(83);
				}
				this.AllParameterValue.Add(document);

				base.Visit(document);
			}
			public override void Visit(Provision document)
			{
				if (this.AllProvision == null)
				{
					this.AllProvision = new List<Provision>(15);
				}
				this.AllProvision.Add(document);

				base.Visit(document);
			}
			public override void Visit(Hero document)
			{
				if (this.AllHero == null)
				{
					this.AllHero = new List<Hero>(8);
				}
				this.AllHero.Add(document);

				base.Visit(document);
			}
			public override void Visit(Item document)
			{
				if (this.AllItem == null)
				{
					this.AllItem = new List<Item>(44);
				}
				this.AllItem.Add(document);

				base.Visit(document);
			}
			public override void Visit(Location document)
			{
				if (this.AllLocation == null)
				{
					this.AllLocation = new List<Location>(12);
				}
				this.AllLocation.Add(document);

				base.Visit(document);
			}
			public override void Visit(Trinket document)
			{
				if (this.AllTrinket == null)
				{
					this.AllTrinket = new List<Trinket>(11);
				}
				this.AllTrinket.Add(document);

				base.Visit(document);
			}
			public override void Visit(Monster document)
			{
				if (this.AllMonster == null)
				{
					this.AllMonster = new List<Monster>(11);
				}
				this.AllMonster.Add(document);

				base.Visit(document);
			}
			public override void Visit(Loot document)
			{
				if (this.AllLoot == null)
				{
					this.AllLoot = new List<Loot>(17);
				}
				this.AllLoot.Add(document);

				base.Visit(document);
			}
			public override void Visit(CombatEffect document)
			{
				if (this.AllCombatEffect == null)
				{
					this.AllCombatEffect = new List<CombatEffect>(50);
				}
				this.AllCombatEffect.Add(document);

				base.Visit(document);
			}
			public override void Visit(CurioCleansingOption document)
			{
				if (this.AllCurioCleansingOption == null)
				{
					this.AllCurioCleansingOption = new List<CurioCleansingOption>(19);
				}
				this.AllCurioCleansingOption.Add(document);

				base.Visit(document);
			}
			public override void Visit(Curio document)
			{
				if (this.AllCurio == null)
				{
					this.AllCurio = new List<Curio>(10);
				}
				this.AllCurio.Add(document);

				base.Visit(document);
			}
			public override void Visit(Disease document)
			{
				if (this.AllDisease == null)
				{
					this.AllDisease = new List<Disease>(11);
				}
				this.AllDisease.Add(document);

				base.Visit(document);
			}
			public override void Visit(Quirk document)
			{
				if (this.AllQuirk == null)
				{
					this.AllQuirk = new List<Quirk>(13);
				}
				this.AllQuirk.Add(document);

				base.Visit(document);
			}
			public override void Visit(Condition document)
			{
				if (this.AllConditions == null)
				{
					this.AllConditions = new List<Condition>(23);
				}
				this.AllConditions.Add(document);

				base.Visit(document);
			}
			public override void Visit(Weapon document)
			{
				if (this.AllWeapon == null)
				{
					this.AllWeapon = new List<Weapon>(20);
				}
				this.AllWeapon.Add(document);

				base.Visit(document);
			}
			public override void Visit(Armor document)
			{
				if (this.AllArmor == null)
				{
					this.AllArmor = new List<Armor>(20);
				}
				this.AllArmor.Add(document);

				base.Visit(document);
			}
			public override void Visit(ItemWithCount document)
			{
				if (this.AllItemWithCount == null)
				{
					this.AllItemWithCount = new List<ItemWithCount>(10);
				}
				this.AllItemWithCount.Add(document);

				base.Visit(document);
			}
			public override void Visit(StartingSet document)
			{
				if (this.AllStartingSet == null)
				{
					this.AllStartingSet = new List<StartingSet>(6);
				}
				this.AllStartingSet.Add(document);

				base.Visit(document);
			}
			#endregion
		}

		private class DereferencingVisitor : Visitor
		{
			#region Visit Methods

			public override void Visit(ProjectSetting document)
			{
				base.Visit(document);
			}
			public override void Visit(Parameter document)
			{
				if (document.MinValueParameterRaw != null)
				{
					document.MinValueParameterRaw.Dereference();
				}
				if (document.MaxValueParameterRaw != null)
				{
					document.MaxValueParameterRaw.Dereference();
				}
				base.Visit(document);
			}
			public override void Visit(ParameterValue document)
			{
				if (document.ParameterRaw != null)
				{
					document.ParameterRaw.Dereference();
				}
				if (document.ConditionRaw != null)
				{
					document.ConditionRaw.Dereference();
				}
				base.Visit(document);
			}
			public override void Visit(Provision document)
			{
				base.Visit(document);
			}
			public override void Visit(Hero document)
			{
				if (document.DislikeHeroesRaw != null)
				{
					document.DislikeHeroesRaw.Dereference();
				}
				if (document.ProvisionsRaw != null)
				{
					document.ProvisionsRaw.Dereference();
				}
				base.Visit(document);
			}
			public override void Visit(Item document)
			{
				base.Visit(document);
			}
			public override void Visit(Location document)
			{
				base.Visit(document);
			}
			public override void Visit(Trinket document)
			{
				if (document.OriginDungeonRaw != null)
				{
					document.OriginDungeonRaw.Dereference();
				}
				if (document.HeroRestrictionRaw != null)
				{
					document.HeroRestrictionRaw.Dereference();
				}
				base.Visit(document);
			}
			public override void Visit(Monster document)
			{
				if (document.LocationsRaw != null)
				{
					document.LocationsRaw.Dereference();
				}
				base.Visit(document);
			}
			public override void Visit(Loot document)
			{
				base.Visit(document);
			}
			public override void Visit(CombatEffect document)
			{
				base.Visit(document);
			}
			public override void Visit(CurioCleansingOption document)
			{
				if (document.ItemRaw != null)
				{
					document.ItemRaw.Dereference();
				}
				base.Visit(document);
			}
			public override void Visit(Curio document)
			{
				if (document.LocationsRaw != null)
				{
					document.LocationsRaw.Dereference();
				}
				base.Visit(document);
			}
			public override void Visit(Disease document)
			{
				base.Visit(document);
			}
			public override void Visit(Quirk document)
			{
				base.Visit(document);
			}
			public override void Visit(Condition document)
			{
				base.Visit(document);
			}
			public override void Visit(Weapon document)
			{
				base.Visit(document);
			}
			public override void Visit(Armor document)
			{
				base.Visit(document);
			}
			public override void Visit(ItemWithCount document)
			{
				if (document.ItemRaw != null)
				{
					document.ItemRaw.Dereference();
				}
				base.Visit(document);
			}
			public override void Visit(StartingSet document)
			{
				if (document.HeroesRaw != null)
				{
					document.HeroesRaw.Dereference();
				}
				if (document.LocationRaw != null)
				{
					document.LocationRaw.Dereference();
				}
				base.Visit(document);
			}
			#endregion
		}

		#endregion

	}
}
// file path is Document.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;


#pragma warning disable 0660, 0661
	public abstract partial class Document
	{
		public Document Parent { get; private set; }

		public static bool operator ==(Document value1, Document value2)
		{
			if (ReferenceEquals(value1, value2)) return true;
			if (ReferenceEquals(value1, null) || ReferenceEquals(value2, null)) return false;

			return Equals(value1, value2);
		}
		public static bool operator !=(Document value1, Document value2)
		{
			if (ReferenceEquals(value1, value2)) return false;
			if (ReferenceEquals(value1, null) || ReferenceEquals(value2, null)) return true;

			return Equals(value1, value2) == false;
		}

		protected static void SetParent(Document document, Document parent)
		{
			if (ReferenceEquals(document, null)) return;

			document.Parent = parent;
		}

		protected static bool AreEquals<T>(T value1, T value2)
		{
			return EqualityComparer<T>.Default.Equals(value1, value2);
		}
		protected static int GetHashCodeFor<T>(T value)
		{
			return EqualityComparer<T>.Default.GetHashCode(value);
		}
	}
#pragma warning restore 0660, 0661

}
// file path is DocumentReference.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;


	public sealed partial class DocumentReference<T> where T : Document
	{
		[NonSerialized]
		private T value;
		[NonSerialized]
		private Func<string, object, Document> findFunc;

		public object Id { get; }

		public DocumentReference(object idValue, Func<string, object, Document> findFunc)
		{
			if (idValue == null) throw new ArgumentNullException(nameof(idValue));
			if (findFunc == null) throw new ArgumentNullException(nameof(findFunc));

			this.findFunc = findFunc;
			this.Id = idValue;
		}

		public T Dereference()
		{
			if (this.value != null)
			{
				return this.value;
			}

			if (this.findFunc != null)
			{
				return this.value = (T)this.findFunc(typeof(T).Name, this.Id);
			}
			else
			{
				throw new InvalidOperationException($"Broken {typeof(T).Name} reference with id {this.Id}. Consider calling Resolve() before using Dereference().");
			}
		}

		public static implicit operator T(DocumentReference<T> reference)
		{
			return reference.Dereference();
		}

		internal void SetFindFunc(Func<string, object, Document> findFunc)
		{
			if (findFunc == null) throw new ArgumentNullException(nameof(findFunc));

#pragma warning disable 0162 // C# Unreachable code detected
			this.value = null;
			// ReSharper disable once ConditionIsAlwaysTrueOrFalse
			if (true)
			{
				this.findFunc = findFunc;
			}
			else
			{
				this.value = (T)findFunc(typeof(T).Name, this.Id);
			}
#pragma warning restore 0162
		}

		public override bool Equals(object value)
		{
			if (!(value is DocumentReference<T> other))
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}

			return Equals(this.Id, other.Id);
		}

		public override int GetHashCode()
		{
			var hashCode = this.Id != null ? this.Id.GetHashCode() : 0;
			return hashCode;
		}

		public override string ToString()
		{
			return $"id: {this.Id}, schema: {typeof(T).Name}";
		}
	}

}
// file path is DocumentReferenceCollection.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;


	[Serializable, DebuggerDisplay("DocumentReferenceCollection, Count: {" + nameof(Count) + "}")]
	public partial class DocumentReferenceCollection<DocumentT>: IReadOnlyList<DocumentReference<DocumentT>>, IEquatable<DocumentReferenceCollection<DocumentT>> where DocumentT : Document
	{
		public static readonly DocumentReferenceCollection<DocumentT> Empty = new DocumentReferenceCollection<DocumentT>(Array.Empty<DocumentReference<DocumentT>>());

		private readonly IReadOnlyList<DocumentReference<DocumentT>> list;
		[NonSerialized]
		private object documentCollectionById;
		[NonSerialized]
		private IReadOnlyList<DocumentT> documentList;

		public DocumentReferenceCollection(IReadOnlyList<DocumentReference<DocumentT>> list)
		{
			if (list == null) throw new ArgumentNullException(nameof(list));

			this.list = list;
		}

		/// <inheritdoc />
		public int Count => this.list.Count;
		/// <inheritdoc />
		public DocumentReference<DocumentT> this[int index] => this.list[index];

		public IReadOnlyList<DocumentT> Dereference()
		{
			if (this.documentList != null)
			{
				return this.documentList;
			}
			var documents = new DocumentT[this.Count];
			for (var i = 0; i < this.list.Count; i++)
			{
				documents[i] = this.list[i].Dereference();
			}
			return this.documentList = documents;
		}
		public DocumentCollection<IdT, DocumentT> Dereference<IdT>(Func<DocumentT, IdT> idSelectFunc)
		{
			if (idSelectFunc == null) throw new ArgumentNullException(nameof(idSelectFunc));

			if (this.documentCollectionById == null && this.Count == 0)
			{
				this.documentCollectionById = DocumentCollection<IdT, DocumentT>.Empty;
			}
			else if((this.documentCollectionById as DocumentCollection<IdT, DocumentT>) == null)
			{
				var documents = this.Dereference();
				this.documentCollectionById = new DocumentCollection<IdT, DocumentT>(documents, idSelectFunc);
			}
			return (DocumentCollection<IdT, DocumentT>)this.documentCollectionById;
		}

		/// <inheritdoc />
		IEnumerator<DocumentReference<DocumentT>> IEnumerable<DocumentReference<DocumentT>>.GetEnumerator()
		{
			return this.list.GetEnumerator();
		}
		/// <inheritdoc />
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable)this.list).GetEnumerator();
		}
		/// <inheritdoc />
		public bool Equals(DocumentReferenceCollection<DocumentT> other)
		{
			if (ReferenceEquals(null, other)) return false;
			if (ReferenceEquals(this, other)) return true;

			return this.list.SequenceEqual(other.list);
		}
		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			if (obj.GetType() != this.GetType()) return false;

			return this.Equals((DocumentReferenceCollection<DocumentT>)obj);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.list.Aggregate(0, (acc, next) => unchecked(next.GetHashCode() * 17 + acc));
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return this.list.ToString();
		}
	}

}
// file path is DocumentCollection.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;


	[Serializable, DebuggerDisplay("DocumentCollection, Count: {" + nameof(Count) + "}")]
	public partial class DocumentCollection<KeyT, DocumentT> : IReadOnlyDictionary<KeyT, DocumentT>, IEquatable<DocumentCollection<KeyT, DocumentT>> where DocumentT : Document
	{
		public static readonly DocumentCollection<KeyT, DocumentT> Empty = new DocumentCollection<KeyT, DocumentT>(Array.Empty<DocumentT>(), new Dictionary<KeyT, DocumentT>(), new Dictionary<Delegate, object>());

		private readonly IReadOnlyList<DocumentT> documents;
		private readonly IReadOnlyDictionary<KeyT, DocumentT> documentsByKey;
		private readonly Dictionary<Delegate, object> byPropertyDictionary;

		public IReadOnlyList<DocumentT> AsList => this.documents;
		/// <inheritdoc />
		public DocumentT this[KeyT key] => this.documentsByKey[key];
		/// <inheritdoc />
		public IEnumerable<KeyT> Keys => this.documentsByKey.Keys;
		/// <inheritdoc />
		public IEnumerable<DocumentT> Values => this.documentsByKey.Values;
		/// <inheritdoc cref="IReadOnlyCollection{T}.Count" />
		public int Count => this.documentsByKey.Count;

		private DocumentCollection(IReadOnlyList<DocumentT> documents, IReadOnlyDictionary<KeyT, DocumentT> documentsByKey, Dictionary<Delegate, object> byPropertyDictionary)
		{
			if (documents == null) throw new ArgumentNullException(nameof(documents));
			if (documentsByKey == null) throw new ArgumentNullException(nameof(documentsByKey));
			if (byPropertyDictionary == null) throw new ArgumentNullException(nameof(byPropertyDictionary));

			this.documents = documents;
			this.documentsByKey = documentsByKey;
			this.byPropertyDictionary = byPropertyDictionary;
		}
		public DocumentCollection(IEnumerable<DocumentT> documents, Func<DocumentT, KeyT> selectKeyFunc, IEqualityComparer<KeyT> idComparer = default)
		{
			if (documents == null) throw new ArgumentNullException(nameof(documents));
			if (selectKeyFunc == null) throw new ArgumentNullException(nameof(selectKeyFunc));

			this.documents = documents as IReadOnlyList<DocumentT> ?? documents.ToList();
			var documentByKey = new Dictionary<KeyT, DocumentT>(this.documents.Count, idComparer ?? EqualityComparer<KeyT>.Default);
			foreach (var document in this.documents)
			{
				if (document == null)
				{
					continue;
				}

				var key = selectKeyFunc(document);
				if (ReferenceEquals(key, null))
				{
					continue;
				}

				documentByKey[key] = document;
			}

			this.documentsByKey = documentByKey;
			this.byPropertyDictionary = new Dictionary<Delegate, object>();
		}

		/// <inheritdoc />
		IEnumerator<KeyValuePair<KeyT, DocumentT>> IEnumerable<KeyValuePair<KeyT, DocumentT>>.GetEnumerator()
		{
			return this.documentsByKey.GetEnumerator();
		}
		/// <inheritdoc />
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable)this.documentsByKey).GetEnumerator();
		}

		/// <inheritdoc />
		public bool ContainsKey(KeyT key)
		{
			return this.documentsByKey.ContainsKey(key);
		}
		/// <inheritdoc />
		public bool TryGetValue(KeyT key, out DocumentT value)
		{
			return this.documentsByKey.TryGetValue(key, out value);
		}

		public DocumentT GetAt(int index)
		{
			return this.documents[index];
		}
		public DocumentT Get(KeyT key)
		{
			if (!this.TryGetValue(key, out var document))
			{
				throw new ArgumentException($"Unable find {typeof(DocumentT).Name} with unique attribute '{key}'.",nameof(key));
			}
			return document;
		}
		public DocumentT Find(KeyT key)
		{
			this.TryGetValue(key, out var document);
			return document;
		}

		public DocumentCollection<NewKeyT, DocumentT> WithOtherKey<NewKeyT>(Func<DocumentT, NewKeyT> selectKeyFunc, IEqualityComparer<NewKeyT> idComparer = default)
		{
			if (selectKeyFunc == null) throw new ArgumentNullException(nameof(selectKeyFunc));

			if (this.Count == 0)
			{
				return DocumentCollection<NewKeyT, DocumentT>.Empty;
			}

			lock (this.byPropertyDictionary)
			{
				if (this.byPropertyDictionary.TryGetValue(selectKeyFunc, out var documentCollectionObj) &&
					documentCollectionObj is DocumentCollection<NewKeyT, DocumentT> existingDocumentCollection)
				{
					return existingDocumentCollection;
				}
			}

			var newDocumentByKey = new Dictionary<NewKeyT, DocumentT>(idComparer ?? EqualityComparer<NewKeyT>.Default);
			foreach (var document in this.documents)
			{
				if (document == null)
				{
					continue;
				}

				var key = selectKeyFunc(document);
				if (ReferenceEquals(key, null))
				{
					continue;
				}

				newDocumentByKey[key] = document;
			}

			lock (this.byPropertyDictionary)
			{
				var newDocumentCollection = new DocumentCollection<NewKeyT, DocumentT>(this.documents, newDocumentByKey, this.byPropertyDictionary);
				this.byPropertyDictionary[selectKeyFunc] = newDocumentCollection;
				return newDocumentCollection;
			}
		}

		/// <inheritdoc />
		public IEnumerator<DocumentT> GetEnumerator()
		{
			return this.documents.GetEnumerator();
		}

		/// <inheritdoc />
		public bool Equals(DocumentCollection<KeyT, DocumentT> other)
		{
			if (ReferenceEquals(null, other)) return false;
			if (ReferenceEquals(this, other)) return true;

			return this.documents.SequenceEqual(other.documents);
		}
		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			if (obj.GetType() != this.GetType()) return false;

			return this.Equals((DocumentCollection<KeyT, DocumentT>)obj);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.documents.Aggregate(0, (acc, next) => unchecked(next.GetHashCode() * 17 + acc));
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return this.documentsByKey.ToString();
		}
	}

}
// file path is DocumentCollectionExtensions.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

		public static class DocumentCollectionExtensions
		{
		}
}
// file path is LocalizedString.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;


	[Serializable, DebuggerDisplay("LocalizedString, Count: {" + nameof(Count) + "}")]
	public sealed partial class LocalizedString : IReadOnlyDictionary<string, string>
	{
		public static readonly LocalizedString Empty = new LocalizedString(Array.Empty<KeyValuePair<string, string>>(), new LanguageSwitcher());

		private static readonly StringComparer LanguageIdComparer = StringComparer.OrdinalIgnoreCase;

		public sealed class LanguageSwitcher
		{
			public string CurrentLanguageId;
			public string FallbackLanguageId;
			public string PrimaryLanguageId;
		}

		private readonly LanguageSwitcher languageSwitcher;
		private readonly string[] keys;
		private readonly string[] values;
		private string currentValue;
		private string currentValueLanguageId;

		/// <inheritdoc />
		public int Count => this.keys.Length;
		public string Value => this.GetOrUpdateCurrentValue();
		public string CurrentLanguageId => this.languageSwitcher.CurrentLanguageId;

		/// <inheritdoc cref="IDictionary{TKey,TValue}.this" />
		public string this[string key]
		{
			get
			{
				var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, key, LanguageIdComparer);
				return languageIndex < 0 ? null : this.values[languageIndex];
			}
		}

		public LocalizedString(IReadOnlyList<KeyValuePair<string, string>> textByLanguageId, LanguageSwitcher languageSwitcher)
		{
			if (textByLanguageId == null) throw new ArgumentNullException(nameof(textByLanguageId));
			if (languageSwitcher == null) throw new ArgumentNullException(nameof(languageSwitcher));

			this.languageSwitcher = languageSwitcher;

			this.keys = new string[textByLanguageId.Count];
			this.values = new string[textByLanguageId.Count];
			for (var i = 0; i < textByLanguageId.Count; i++)
			{
				this.keys[i] = textByLanguageId[i].Key;
				this.values[i] = textByLanguageId[i].Value;
			}
		}

		private string GetOrUpdateCurrentValue()
		{
			var currentLanguageId = this.languageSwitcher.CurrentLanguageId;
			var fallbackLanguageId = this.languageSwitcher.FallbackLanguageId;
			var primaryLanguageId = this.languageSwitcher.PrimaryLanguageId;
			if (currentLanguageId != this.currentValueLanguageId)
			{
				this.currentValueLanguageId = currentLanguageId;
				this.currentValue = this[currentLanguageId] ?? this[fallbackLanguageId] ?? this[primaryLanguageId] ?? string.Empty;
			}
			return this.currentValue;
		}

		public static implicit operator string(LocalizedString str)
		{
			if (str == null) return null;
			return str.Value;
		}

		/// <inheritdoc />
		public override bool Equals(object value)
		{
			var other = value as LocalizedString;
			if (other == null)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (this.keys.Length != other.keys.Length)
			{
				return false;
			}

			for (var i = 0; i < this.keys.Length; i++)
			{
				if (LanguageIdComparer.Equals(this.keys[i], other.keys[i]) == false)
				{
					return false;
				}

				if (string.Equals(this.values[i], other.values[i], StringComparison.OrdinalIgnoreCase) == false)
				{
					return false;
				}
			}

			return true;
		}

		/// <inheritdoc />
		public override int GetHashCode()
		{
			var hashCode = 0;
			foreach (var value in this.values)
			{
				hashCode += unchecked((value ?? "").GetHashCode());
			}
			return hashCode;
		}

		/// <inheritdoc />
		public IEnumerable<string> Keys => this.keys;
		/// <inheritdoc />
		public IEnumerable<string> Values => this.values;

		/// <inheritdoc />
		bool IReadOnlyDictionary<string, string>.TryGetValue(string key, out string value)
		{
			return ((IReadOnlyDictionary<string, string>)this).TryGetValue(key, out value);
		}
		/// <inheritdoc />
		bool IReadOnlyDictionary<string, string>.ContainsKey(string key)
		{
			return ((IReadOnlyDictionary<string, string>)this).ContainsKey(key);
		}

		public bool TryGetValue(string key, out string value)
		{
			var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, key, LanguageIdComparer);
			if (languageIndex >= 0)
			{
				value = this.values[languageIndex];
				return value != null;
			}
			else
			{
				value = null;
				return false;
			}
		}

		/// <inheritdoc />
		IEnumerator<KeyValuePair<string, string>> IEnumerable<KeyValuePair<string, string>>.GetEnumerator()
		{
			for (var i = 0; i < this.keys.Length; i++)
			{
				yield return new KeyValuePair<string, string>(this.keys[i], this.values[i]);
			}
		}
		/// <inheritdoc />
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
		{
			for (var i = 0; i < this.keys.Length; i++)
			{
				yield return new KeyValuePair<string, string>(this.keys[i], this.values[i]);
			}
		}

		public static bool operator ==(LocalizedString value1, LocalizedString value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(LocalizedString value1, LocalizedString value2)
		{
			return Equals(value1, value2) == false;
		}

		public override string ToString()
		{
			return this.Value;
		}
	}

}
// file path is Formatters.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	public static class Formatters
	{
	 

	#region EndianBitConverter by Jon Skeet and Marc Gravell
	/* "Miscellaneous Utility Library" Software Licence

	Version 1.0

	Copyright (c) 2004-2008 Jon Skeet and Marc Gravell.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions
	are met:

	1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.

	2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.

	3. The end-user documentation included with the redistribution, if
	any, must include the following acknowledgment:

	"This product includes software developed by Jon Skeet
	and Marc Gravell. Contact skeet@pobox.com, or see
	http://www.pobox.com/~skeet/)."

	Alternately, this acknowledgment may appear in the software itself,
	if and wherever such third-party acknowledgments normally appear.

	4. The name "Miscellaneous Utility Library" must not be used to endorse
	or promote products derived from this software without prior written
	permission. For written permission, please contact skeet@pobox.com.

	5. Products derived from this software may not be called
	"Miscellaneous Utility Library", nor may "Miscellaneous Utility Library"
	appear in their name, without prior written permission of Jon Skeet.

	THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED
	WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	IN NO EVENT SHALL JON SKEET BE LIABLE FOR ANY DIRECT, INDIRECT,
	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
	*/
	public enum Endianness
	{
		LittleEndian,
		BigEndian
	}

	public abstract class EndianBitConverter
	{
		#region Endianness of this converter

		public abstract bool IsLittleEndian();

		public abstract Endianness Endianness { get; }

		#endregion

		#region Factory properties

		public static readonly LittleEndianBitConverter Little = new LittleEndianBitConverter();
		public static readonly BigEndianBitConverter Big = new BigEndianBitConverter();

		#endregion

		#region Double/primitive conversions

		public long DoubleToInt64Bits(double value)
		{
			return BitConverter.DoubleToInt64Bits(value);
		}

		public double Int64BitsToDouble(long value)
		{
			return BitConverter.Int64BitsToDouble(value);
		}

		public int SingleToInt32Bits(float value)
		{
			return new Int32SingleUnion(value).AsInt32;
		}

		public float Int32BitsToSingle(int value)
		{
			return new Int32SingleUnion(value).AsSingle;
		}

		#endregion

		#region To(PrimitiveType) conversions

		public bool ToBoolean(byte[] value, int startIndex)
		{
			CheckByteArgument(value, startIndex, 1);
			return BitConverter.ToBoolean(value, startIndex);
		}

		public char ToChar(byte[] value, int startIndex)
		{
			return unchecked((char)(CheckedFromBytes(value, startIndex, 2)));
		}

		public double ToDouble(byte[] value, int startIndex)
		{
			return Int64BitsToDouble(ToInt64(value, startIndex));
		}

		public float ToSingle(byte[] value, int startIndex)
		{
			return Int32BitsToSingle(ToInt32(value, startIndex));
		}

		public short ToInt16(byte[] value, int startIndex)
		{
			return unchecked((short)(CheckedFromBytes(value, startIndex, 2)));
		}

		public int ToInt32(byte[] value, int startIndex)
		{
			return unchecked((int)(CheckedFromBytes(value, startIndex, 4)));
		}

		public long ToInt64(byte[] value, int startIndex)
		{
			return CheckedFromBytes(value, startIndex, 8);
		}

		public ushort ToUInt16(byte[] value, int startIndex)
		{
			return unchecked((ushort)(CheckedFromBytes(value, startIndex, 2)));
		}

		public uint ToUInt32(byte[] value, int startIndex)
		{
			return unchecked((uint)(CheckedFromBytes(value, startIndex, 4)));
		}

		public ulong ToUInt64(byte[] value, int startIndex)
		{
			return unchecked((ulong)(CheckedFromBytes(value, startIndex, 8)));
		}

		private static void CheckByteArgument(byte[] value, int startIndex, int bytesRequired)
		{
			if (value == null)
			{
				throw new ArgumentNullException(nameof(value));
			}
			if (startIndex < 0 || startIndex > value.Length - bytesRequired)
			{
				throw new ArgumentOutOfRangeException(nameof(startIndex));
			}
		}

		private long CheckedFromBytes(byte[] value, int startIndex, int bytesToConvert)
		{
			CheckByteArgument(value, startIndex, bytesToConvert);
			return FromBytes(value, startIndex, bytesToConvert);
		}

		protected abstract long FromBytes(byte[] value, int startIndex, int bytesToConvert);

		#endregion

		#region ToString conversions

		public static string ToString(byte[] value)
		{
			return BitConverter.ToString(value);
		}

		public static string ToString(byte[] value, int startIndex)
		{
			return BitConverter.ToString(value, startIndex);
		}

		public static string ToString(byte[] value, int startIndex, int length)
		{
			return BitConverter.ToString(value, startIndex, length);
		}

		#endregion

		#region	Decimal conversions

		public decimal ToDecimal(byte[] value, int startIndex)
		{
			// HACK: This always assumes four parts, each in their own endianness,
			// starting with the first part at the start of the byte array.
			// On the other hand, there's no real format specified...
			var parts = new int[4];
			for (var i = 0; i < 4; i++)
			{
				parts[i] = ToInt32(value, startIndex + i * 4);
			}
			return new decimal(parts);
		}

		public byte[] GetBytes(decimal value)
		{
			var bytes = new byte[16];
			var parts = decimal.GetBits(value);
			for (var i = 0; i < 4; i++)
			{
				CopyBytesImpl(parts[i], 4, bytes, i * 4);
			}
			return bytes;
		}

		public void CopyBytes(decimal value, byte[] buffer, int index)
		{
			var parts = decimal.GetBits(value);
			for (var i = 0; i < 4; i++)
			{
				CopyBytesImpl(parts[i], 4, buffer, i * 4 + index);
			}
		}

		#endregion

		#region GetBytes conversions

		private byte[] GetBytes(long value, int bytes)
		{
			var buffer = new byte[bytes];
			CopyBytes(value, bytes, buffer, 0);
			return buffer;
		}

		public byte[] GetBytes(bool value)
		{
			return BitConverter.GetBytes(value);
		}

		public byte[] GetBytes(char value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(double value)
		{
			return GetBytes(DoubleToInt64Bits(value), 8);
		}

		public byte[] GetBytes(short value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(int value)
		{
			return GetBytes(value, 4);
		}

		public byte[] GetBytes(long value)
		{
			return GetBytes(value, 8);
		}

		public byte[] GetBytes(float value)
		{
			return GetBytes(SingleToInt32Bits(value), 4);
		}

		public byte[] GetBytes(ushort value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(uint value)
		{
			return GetBytes(value, 4);
		}

		public byte[] GetBytes(ulong value)
		{
			return GetBytes(unchecked((long)value), 8);
		}

		#endregion

		#region CopyBytes conversions

		private void CopyBytes(long value, int bytes, byte[] buffer, int index)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException(nameof(buffer), "Byte array must not be null");
			}
			if (buffer.Length < index + bytes)
			{
				throw new ArgumentOutOfRangeException(nameof(buffer), "Buffer not big enough for value");
			}
			CopyBytesImpl(value, bytes, buffer, index);
		}

		protected abstract void CopyBytesImpl(long value, int bytes, byte[] buffer, int index);

		public void CopyBytes(bool value, byte[] buffer, int index)
		{
			CopyBytes(value ? 1 : 0, 1, buffer, index);
		}

		public void CopyBytes(char value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(double value, byte[] buffer, int index)
		{
			CopyBytes(DoubleToInt64Bits(value), 8, buffer, index);
		}

		public void CopyBytes(short value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(int value, byte[] buffer, int index)
		{
			CopyBytes(value, 4, buffer, index);
		}

		public void CopyBytes(long value, byte[] buffer, int index)
		{
			CopyBytes(value, 8, buffer, index);
		}

		public void CopyBytes(float value, byte[] buffer, int index)
		{
			CopyBytes(SingleToInt32Bits(value), 4, buffer, index);
		}

		public void CopyBytes(ushort value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(uint value, byte[] buffer, int index)
		{
			CopyBytes(value, 4, buffer, index);
		}

		public void CopyBytes(ulong value, byte[] buffer, int index)
		{
			CopyBytes(unchecked((long)value), 8, buffer, index);
		}

		#endregion

		#region Private struct used for Single/Int32 conversions

		[StructLayout(LayoutKind.Explicit)]
		private readonly struct Int32SingleUnion
		{
			[FieldOffset(0)]
			private readonly int i;

			[FieldOffset(0)]
			private readonly float f;

			internal Int32SingleUnion(int i)
			{
				this.f = 0; // Just to keep the compiler happy
				this.i = i;
			}

			internal Int32SingleUnion(float f)
			{
				this.i = 0; // Just to keep the compiler happy
				this.f = f;
			}

			internal int AsInt32 => i;

			internal float AsSingle => f;
		}

		#endregion
	}

	public sealed class BigEndianBitConverter : EndianBitConverter
	{
		public override bool IsLittleEndian()
		{
			return false;
		}

		public override Endianness Endianness => Endianness.BigEndian;

		protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
		{
			var endOffset = index + bytes - 1;
			for (var i = 0; i < bytes; i++)
			{
				buffer[endOffset - i] = unchecked((byte)(value & 0xff));
				value = value >> 8;
			}
		}

		protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
		{
			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[startIndex + i]);
			}
			return ret;
		}
	}

	public sealed class LittleEndianBitConverter : EndianBitConverter
	{
		public override bool IsLittleEndian()
		{
			return true;
		}

		public override Endianness Endianness => Endianness.LittleEndian;

		protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
		{
			for (var i = 0; i < bytes; i++)
			{
				buffer[i + index] = unchecked((byte)(value & 0xff));
				value = value >> 8;
			}
		}

		protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
		{
			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[startIndex + bytesToConvert - 1 - i]);
			}
			return ret;
		}
	}

	/* end of Jon Skeet and Marc Gravell code */
	#endregion


	public enum Format
	{
		Json,
		MessagePack
	}


	public class GameDataLoadOptions
	{
		public Format Format { get; set; }
		public IReadOnlyList<Stream> Patches { get; set; }
		public Encoding Encoding { get; set; }
		public bool LeaveStreamsOpen { get; set; }

		public GameDataLoadOptions()
		{
			this.Format = Format.Json;
			this.Patches = Array.Empty<Stream>();
			this.Encoding = Encoding.UTF8;
			this.LeaveStreamsOpen = false;
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return $"Format: {this.Format}, Patches: {string.Join(", ", this.Patches)}, Encoding: {this.Encoding.WebName}, Leave Open: {this.LeaveStreamsOpen}";
		}
	}


	public abstract partial class GameDataReader : IDisposable
	{
		public static readonly string[] DateTimeFormats = new string[] { "yyyy-MM-ddTHH:mm:ss.fffZ", "o" };

		public abstract ReaderNode Node { get; }

		public abstract int LineNumber { get; }
		public abstract int ColumnNumber { get; }

		public abstract bool NextToken();

		public bool IsEndOfStream()
		{
			return this.Node.Token == ReaderToken.EndOfStream;
		}
		public bool IsNull()
		{
			return this.Node.Token == ReaderToken.Null;
		}
		public void ThrowIfNotValue()
		{
			if (this.Node.Token != ReaderToken.Value)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.Value);
			}
		}
		public void ThrowIfNull(string expected, string propertyName, string schemaName)
		{
			if (this.Node.Token == ReaderToken.Null)
			{
				throw ReaderException.UnexpectedNullValue(expected, propertyName, schemaName, this);
			}
		}

		public object ReadAny(bool nextToken = true)
		{
			// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
			switch(this.Node.Token)
			{
				case ReaderToken.BeginArray: return this.ReadArray(nextToken);
				case ReaderToken.BeginObject: return this.ReadObject(nextToken);
				case ReaderToken.Null: if (nextToken) this.NextToken(); return null;
				case ReaderToken.Value: var value = this.Node.AsObject; if (nextToken) this.NextToken(); return value;
				default: throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Value);
			}
		}
		public List<object> ReadArray(bool nextToken = true)
		{
			var list = new List<object>();
			this.ReadArrayBegin();
			while(this.Node.Token != ReaderToken.EndOfArray)
			{
				var value = this.ReadAny();
				list.Add(value);
			}
			this.ReadArrayEnd( nextToken);
			return list;
		}
		public IndexedDictionary<string, object> ReadObject(bool nextToken = true)
		{
			var dictionary = new IndexedDictionary<string, object>();
			this.ReadObjectBegin();
			while(this.Node.Token != ReaderToken.EndOfObject)
			{
				var key = this.ReadMember();
				var value = this.ReadAny();
				dictionary[key] = value;
			}
			this.ReadObjectEnd(nextToken);
			return dictionary;
		}
		public void SkipAny(bool nextToken = true)
		{
			// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
			switch(this.Node.Token)
			{
				case ReaderToken.BeginArray: this.SkipArray(nextToken); break;
				case ReaderToken.BeginObject: this.SkipObject(nextToken); break;
				case ReaderToken.Member: if (nextToken) this.NextToken(); break;
				case ReaderToken.Null: if (nextToken) this.NextToken(); break;
				case ReaderToken.Value: if (nextToken) this.NextToken(); break;
				default: throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Value);
			}
		}
		public void SkipArray(bool nextToken = true)
		{
			this.ReadArrayBegin();
			while(this.Node.Token != ReaderToken.EndOfArray)
			{
				this.SkipAny();
			}
			this.ReadArrayEnd( nextToken);
		}
		public void SkipObject(bool nextToken = true)
		{
			this.ReadObjectBegin();
			while(this.Node.Token != ReaderToken.EndOfObject)
			{
				this.SkipAny();
				this.SkipAny();
			}
			this.ReadObjectEnd(nextToken);
		}
		public void SkipRestOfObject(bool nextToken = true)
		{
			while (this.Node.Token != ReaderToken.EndOfObject)
			{
				this.SkipAny();
			}

			this.ReadObjectEnd(nextToken);
		}

		public void ReadArrayBegin(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.BeginArray)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray);
			}
			if (this.IsEndOfStream())
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfArray);
			}

			if (nextToken)
				this.NextToken();
		}
		public void ReadArrayEnd(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.EndOfArray)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfArray);
			}

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}
		}
		public void ReadObjectBegin(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.BeginObject)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.BeginObject);
			}

			if (this.IsEndOfStream())
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfObject);
			}

			if (nextToken)
			{
				this.NextToken();
			}
		}
		public void ReadObjectEnd(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.EndOfObject)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfObject);
			}

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}
		}
		public string ReadMember(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.Member && this.Node.Token != ReaderToken.Value)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.Member, ReaderToken.Value);
			}

			var memberName = this.Node.AsString;

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}

			return memberName;
		}

		public string DebugPrintTokens()
		{
			var output = new StringBuilder();
			var stack = new Stack<ReaderToken>();
			stack.Push(ReaderToken.None);
			while (this.NextToken())
			{
				var strValue = Convert.ToString(this.Node.Token, CultureInfo.InvariantCulture) +
					(this.Node.HasValue ? "[" + this.Node.AsString + "]" : "");

				if (stack.Peek() != ReaderToken.Member)
				{
					var endingTokenIndent = this.Node.Token == ReaderToken.EndOfObject || this.Node.Token == ReaderToken.EndOfArray ? -1 : 0;
					output.Append(Environment.NewLine);
					for (var i = 0; i < System.Linq.Enumerable.Count(stack, t => t != ReaderToken.Member && t != ReaderToken.None) + endingTokenIndent; i++)
					{
						output.Append("\t");
					}
				}
				else output.Append(" ");

				output.Append(strValue);

				if (this.Node.Token == ReaderToken.EndOfObject || this.Node.Token == ReaderToken.EndOfArray || stack.Peek() == ReaderToken.Member)
				{
					stack.Pop();
				}
				if (this.Node.Token == ReaderToken.BeginObject || this.Node.Token == ReaderToken.BeginArray || this.Node.Token == ReaderToken.Member)
				{
					stack.Push(this.Node.Token);
				}
			}

			return output.ToString();
		}

		/// <inheritdoc />
		public abstract void Dispose();

		public override string ToString()
		{
			return this.Node.ToString();
		}

	}


	[Serializable, DebuggerDisplay("IndexedDictionary, Count: {" + nameof(Count) + "}")]
	public sealed class IndexedDictionary<KeyT, ValueT> : IDictionary<KeyT, ValueT>, IReadOnlyDictionary<KeyT, ValueT>, IDictionary
	{
		public struct Enumerator : IEnumerator<KeyValuePair<KeyT, ValueT>>, IDictionaryEnumerator
		{
			private List<KeyT>.Enumerator innerEnumerator;
			private readonly IndexedDictionary<KeyT, ValueT> dictionary;

			public Enumerator(IndexedDictionary<KeyT, ValueT> dictionary)
			{
				this.dictionary = dictionary;
				this.innerEnumerator = dictionary.keys.GetEnumerator();
				this.Current = new KeyValuePair<KeyT, ValueT>();
			}

			public KeyValuePair<KeyT, ValueT> Current { get; private set; }
			object IEnumerator.Current => this.Current;
			public object Key => this.Current.Key;
			public object Value => this.Current.Value;
			public DictionaryEntry Entry => ToEntry(this.Current);

			public bool MoveNext()
			{
				if (!this.innerEnumerator.MoveNext()) return false;

				var key = this.innerEnumerator.Current;

				Debug.Assert(!ReferenceEquals(key, null), "key is null");

				this.Current = new KeyValuePair<KeyT, ValueT>(key, this.dictionary.dictionary[key]);
				return true;
			}
			public void Reset()
			{
				this.innerEnumerator = this.dictionary.keys.GetEnumerator();
			}
			public void Dispose()
			{
				this.innerEnumerator.Dispose();
			}
		}

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] private readonly Dictionary<KeyT, ValueT> dictionary;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly List<KeyT> keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never), NonSerialized] private ReadOnlyCollection<KeyT> keysReadOnly;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)] public ReadOnlyCollection<KeyT> Keys => this.keysReadOnly ?? (this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys));
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] public Dictionary<KeyT, ValueT>.ValueCollection Values => this.dictionary.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool ICollection<KeyValuePair<KeyT, ValueT>>.IsReadOnly => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection<KeyT> IDictionary<KeyT, ValueT>.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] IEnumerable<ValueT> IReadOnlyDictionary<KeyT, ValueT>.Values => this.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] IEnumerable<KeyT> IReadOnlyDictionary<KeyT, ValueT>.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection<ValueT> IDictionary<KeyT, ValueT>.Values => this.dictionary.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection IDictionary.Values => this.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection IDictionary.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool IDictionary.IsReadOnly => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool IDictionary.IsFixedSize => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] object ICollection.SyncRoot => this.dictionary;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool ICollection.IsSynchronized => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		object IDictionary.this[object key]
		{
			get => this[CastKey(key)];
			set => this[CastKey(key)] = CastValue(value);
		}

		public int Count => this.dictionary.Count;

		public ValueT this[KeyT key]
		{
			get => this.dictionary[key];
			set
			{
				if (this.dictionary.ContainsKey(key) == false) this.keys.Add(key);
				this.dictionary[key] = value;
			}
		}

		public IndexedDictionary()
		{
			this.dictionary = new Dictionary<KeyT, ValueT>();
			this.keys = new List<KeyT>();
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(int count)
		{
			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));

			if (count == 0) count = 30;

			this.dictionary = new Dictionary<KeyT, ValueT>(count);
			this.keys = new List<KeyT>(count);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(IDictionary<KeyT, ValueT> dictionary)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

			this.dictionary = new Dictionary<KeyT, ValueT>(dictionary);
			this.keys = new List<KeyT>(dictionary.Keys);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(IEnumerable<KeyValuePair<KeyT, ValueT>> pairs)
		{
			if (pairs == null) throw new ArgumentNullException(nameof(pairs));

			this.dictionary = new Dictionary<KeyT, ValueT>();
			this.keys = new List<KeyT>();
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);

			foreach (var pair in pairs)
			{
				this.Add(pair.Key, pair.Value);
			}
		}
		public IndexedDictionary(IDictionary<KeyT, ValueT> dictionary, ICollection<KeyT> keys)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));
			if (keys == null) throw new ArgumentNullException(nameof(keys));

			this.dictionary = new Dictionary<KeyT, ValueT>(dictionary);
			this.keys = new List<KeyT>(keys);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}

		public void Add(KeyT key, ValueT value)
		{
			this.dictionary.Add(key, value);
			this.keys.Add(key);
		}
		public void Add(IndexedDictionary<KeyT, ValueT> other)
		{
			if (other == null) throw new ArgumentNullException(nameof(other));

			if (this.Count == 0)
			{
				this.keys.AddRange(other.keys);
				foreach (var kv in other.dictionary)
				{
					this.dictionary.Add(kv.Key, kv.Value);
				}
			}
			else
			{
				foreach (var kv in other.dictionary)
				{
					this.dictionary.Add(kv.Key, kv.Value);
					this.keys.Add(kv.Key);
				}
			}
		}

		public void Insert(int index, KeyT key, ValueT value)
		{
			// Dictionary operation first, so exception thrown if key already exists.
			this.dictionary.Add(key, value);
			this.keys.Insert(index, key);
		}
		public bool ContainsKey(KeyT key)
		{
			return this.dictionary.ContainsKey(key);
		}
		public bool ContainsKey(KeyT key, IEqualityComparer<KeyT> keyComparer)
		{
			if (keyComparer == null) throw new ArgumentNullException(nameof(keyComparer));

			foreach (var k in this.keys)
			{
				if (keyComparer.Equals(k, key))
				{
					return true;
				}
			}

			return false;
		}
		public bool ContainsValue(ValueT value)
		{
			foreach (var kv in this.dictionary)
			{
				if (Equals(value, kv.Value))
				{
					return true;
				}
			}

			return false;
		}
		public bool ContainsValue(ValueT value, IEqualityComparer comparer)
		{
			if (comparer == null) throw new ArgumentNullException(nameof(comparer));

			foreach (var kv in this.dictionary)
			{
				if (comparer.Equals(value, kv.Value))
				{
					return true;
				}
			}

			return false;
		}
		public bool Remove(KeyT key)
		{
			var wasInDictionary = this.dictionary.Remove(key);
			this.keys.Remove(key);

			return wasInDictionary;
		}

		public bool TryGetValue(KeyT key, out ValueT value)
		{
			return this.dictionary.TryGetValue(key, out value);
		}

		public int IndexOf(KeyT key)
		{
			return this.keys.IndexOf(key);
		}
		public void RemoveAt(int index)
		{
			if (index >= this.Count || index < 0) throw new ArgumentOutOfRangeException(nameof(index));

			var key = this.keys[index];
			this.dictionary.Remove(key);
			this.keys.RemoveAt(index);
		}
		public void SortKeys(IComparer<KeyT> comparer)
		{
			if (comparer == null) throw new ArgumentNullException(nameof(comparer));

			this.keys.Sort(comparer);
		}

		public void Clear()
		{
			this.dictionary.Clear();
			this.keys.Clear();
		}

		bool IDictionary.Contains(object key)
		{
			return this.ContainsKey(CastKey(key));
		}
		void IDictionary.Add(object key, object value)
		{
			this.Add(CastKey(key), CastValue(value));
		}
		void IDictionary.Remove(object key)
		{
			this.Remove(CastKey(key));
		}
		void ICollection.CopyTo(Array array, int index)
		{
			foreach (var pair in this)
			{
				array.SetValue(ToEntry(pair), index++);
			}
		}

		void ICollection<KeyValuePair<KeyT, ValueT>>.Add(KeyValuePair<KeyT, ValueT> item)
		{
			this.Add(item.Key, item.Value);
		}
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Contains(KeyValuePair<KeyT, ValueT> item)
		{
			return this.dictionary.TryGetValue(item.Key, out var value) && Equals(value, item.Value);
		}
		void ICollection<KeyValuePair<KeyT, ValueT>>.CopyTo(KeyValuePair<KeyT, ValueT>[] array, int arrayIndex)
		{
			foreach (var pair in this)
			{
				array[arrayIndex++] = pair;
			}
		}
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Remove(KeyValuePair<KeyT, ValueT> item)
		{
			if (((ICollection<KeyValuePair<KeyT, ValueT>>)this).Contains(item) == false)
			{
				return false;
			}

			return this.Remove(item.Key);
		}
		IEnumerator<KeyValuePair<KeyT, ValueT>> IEnumerable<KeyValuePair<KeyT, ValueT>>.GetEnumerator()
		{
			return this.GetEnumerator();
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		private static ValueT CastValue(object value)
		{
			if (value == null) return default;

			return (ValueT)value;
		}
		private static KeyT CastKey(object key)
		{
			if (key == null) throw new ArgumentNullException(nameof(key));

			return (KeyT)key;
		}
		private static DictionaryEntry ToEntry(KeyValuePair<KeyT, ValueT> value)
		{
			return new DictionaryEntry(value.Key, value.Value);
		}

		public override string ToString()
		{
			return "Count: " + Convert.ToString(this.Count, CultureInfo.InvariantCulture);
		}
	}


	public class IndexedString : IComparable<IndexedString>
	{
		public readonly string Value;
		public readonly ulong[] Octets;

		public IndexedString(string value)
		{
			this.Value = value;
			this.Octets = new ulong[8];
			for (var i = 0; i < 8; i++)
			{
				this.Octets[i] = GetUInt64(value, 8 * i);
			}
		}

		public int CompareTo(IndexedString otherString)
		{
			if (this.Value.Length != otherString.Value.Length)
			{
				return this.Value.Length.CompareTo(otherString.Value.Length);
			}

			for (var i = 0; i < this.Octets.Length; i++)
			{
				var comp = this.Octets[i].CompareTo(otherString.Octets[i]);
				if (comp != 0)
				{
					return comp;
				}
			}

			return 0;
		}

		private static ulong GetUInt64(string chars, int offset)
		{
			if (offset >= chars.Length)
			{
				return 0;
			}

			var result = 0L;
			var bytesToConvert = Math.Min(chars.Length - offset, 8);
			for (var i = 0; i < bytesToConvert; i++)
			{
				result = unchecked((result << 8) | chars[offset + bytesToConvert - 1 - i]);
			}

			return unchecked((ulong)result);
		}
	}


	public interface IStrongBox
	{
		bool AsBoolean { get; }
		byte AsByte { get; }
		short AsInt16 { get; }
		int AsInt32 { get; }
		long AsInt64 { get; }
		sbyte AsSByte { get; }
		ushort AsUInt16 { get; }
		uint AsUInt32 { get; }
		ulong AsUInt64 { get; }
		float AsSingle { get; }
		double AsDouble { get; }
		decimal AsDecimal { get; }
		DateTimeOffset AsDateTimeOffset { get; }
		DateTime AsDateTime { get; }
		TimeSpan AsTimeSpan { get; }
		Type ValueType { get; }
		object AsObject { get; }

		void Store<T>(T value);
	}


	public sealed class JsonGameDataReader : GameDataReader
	{
		private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue / 2;
		private const int CHAR_SIZE = 2;

		const int LEXER_STATE_COMPLETE = -1;
		const int LEXER_STATE_START = 0;
		const int LEXER_STATE_LEXEME = 1;
		const int LEXER_STATE_QUOTED = 2;
		const int LEXER_STATE_QUOTED_ESCAPE = 3;
		const int LEXER_STATE_COMMENT_BEGINNING = 4;
		const int LEXER_STATE_COMMENT_SINGLE_LINE = 5;
		const int LEXER_STATE_COMMENT_MULTILINE = 6;
		const int LEXER_STATE_COMMENT_MULTILINE_ENDING = 7;

		private const int NUMBER_FLOAT = 2;
		private const int NUMBER_FLOAT_WITH_EXP = 3;
		private const int NUMBER_INTEGER = 0;
		private const int NUMBER_NEGATIVE_INTEGER = 1;
		private const int NUMBER_NOT = -1;

		private static readonly int Int32MaxLength = int.MaxValue.ToString().Length;
		private static readonly int Int64MaxLength = long.MaxValue.ToString().Length;

		private readonly ArraySegment<char> lexemeTrue = new ArraySegment<char>(JsonNotation.True.ToCharArray(), 0, 4);
		private readonly ArraySegment<char> lexemeFalse = new ArraySegment<char>(JsonNotation.False.ToCharArray(), 0, 5);
		private readonly ArraySegment<char> lexemeNull = new ArraySegment<char>(JsonNotation.Null.ToCharArray(), 0, 4);

		private readonly bool leaveOpen;
		private readonly TextReader textReader;
		private readonly Stack<ReaderToken> structure;

		// tokenizing
		private readonly char[] buffer;
		private int bufferOffset;
		private int bufferAvailable;
		private int lineNum = 1;
		private int colNum = 1;

		// parsing
		private ReaderNode node;
		private ArraySegment<char> rawJson;

		private StrongBox<bool> trueBox;
		private StrongBox<bool> falseBox;
		private StrongBox<int> intBox;
		private StrongBox<DateTime> dateBox;
		private JsonValueBox jsonValueBox;

		public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

		// statistics
		public override int LineNumber => this.lineNum;
		public override int ColumnNumber => this.colNum;

		public JsonGameDataReader(Stream stream, Encoding encoding, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
			: this(new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: true, leaveOpen: leaveOpen, bufferSize: bufferSize), leaveOpen, bufferSize)
		{

		}
		public JsonGameDataReader(TextReader textReader, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
		{
			if (textReader == null) throw new ArgumentNullException(nameof(textReader));
			if (bufferSize <= 0) throw new ArgumentOutOfRangeException(nameof(bufferSize));

			this.structure = new Stack<ReaderToken>();
			this.buffer = new char[bufferSize];
			this.textReader = textReader;
			this.leaveOpen = leaveOpen;
		}

		public override bool NextToken()
		{
			this.rawJson = default;
			this.node = default;

			var fragments = default(ArraySegment<char>[]);
			var state = LEXER_STATE_COMPLETE;
			var lexemeSize = 0;
			var memberOrValueToken = ReaderToken.Value;

			if (this.structure.Count > 0)
			{
				// ReSharper disable once SwitchStatementMissingSomeCases
				switch (this.structure.Peek())
				{
					case ReaderToken.Member:
						this.structure.Pop();
						break;
					case ReaderToken.BeginObject:
						this.structure.Push(memberOrValueToken = ReaderToken.Member);
						break;
				}
			}

			var lexeme = this.NextLexeme(ref state);
			if (lexeme.Count == 0)
			{
				this.node = new ReaderNode(ReaderToken.EndOfStream);
				return false;
			}
			if (state != LEXER_STATE_COMPLETE)
			{
				var firstFragment = Copy(ref lexeme);
				var secondFragment = this.NextLexeme(ref state);

				if (state == LEXER_STATE_COMPLETE)
				{
					if (secondFragment.Count == 0)
					{
						lexeme = firstFragment;
						lexemeSize = lexeme.Count;
					}
					else
					{
						fragments = new[] { firstFragment, secondFragment };
						lexemeSize = firstFragment.Count + secondFragment.Count;
					}
				}
				else
				{
					var fragmentIndex = 0;
					fragments = new ArraySegment<char>[8];
					fragments[fragmentIndex++] = firstFragment;
					fragments[fragmentIndex++] = Copy(ref secondFragment);
					lexemeSize = firstFragment.Count + secondFragment.Count;

					do
					{
						lexeme = this.NextLexeme(ref state);

						if (lexeme.Count == 0)
						{
							break;
						}
						if (fragmentIndex == fragments.Length)
						{
							Array.Resize(ref fragments, (int)(fragments.Length * 1.5));
						}

						fragments[fragmentIndex++] = Copy(ref lexeme);
						lexemeSize += lexeme.Count;

					} while (state != LEXER_STATE_COMPLETE);
				}
			}
			else
			{
				lexemeSize = lexeme.Count;
			}

			if (lexemeSize == 1)
			{
				this.rawJson = fragments != null ? fragments[0] : lexeme;
				System.Diagnostics.Debug.Assert(this.rawJson.Array != null, "this.rawJson.Array");
				switch (this.rawJson.Array[this.rawJson.Offset])
				{
					case JsonNotation.Const0: this.node = new ReaderNode(memberOrValueToken, this.Box(0)); return true;
					case JsonNotation.Const1: this.node = new ReaderNode(memberOrValueToken, this.Box(1)); return true;
					case JsonNotation.Const2: this.node = new ReaderNode(memberOrValueToken, this.Box(2)); return true;
					case JsonNotation.Const3: this.node = new ReaderNode(memberOrValueToken, this.Box(3)); return true;
					case JsonNotation.Const4: this.node = new ReaderNode(memberOrValueToken, this.Box(4)); return true;
					case JsonNotation.Const5: this.node = new ReaderNode(memberOrValueToken, this.Box(5)); return true;
					case JsonNotation.Const6: this.node = new ReaderNode(memberOrValueToken, this.Box(6)); return true;
					case JsonNotation.Const7: this.node = new ReaderNode(memberOrValueToken, this.Box(7)); return true;
					case JsonNotation.Const8: this.node = new ReaderNode(memberOrValueToken, this.Box(8)); return true;
					case JsonNotation.Const9: this.node = new ReaderNode(memberOrValueToken, this.Box(9)); return true;
					case JsonNotation.BeginArray:
						this.structure.Push(ReaderToken.BeginArray);
						this.node = new ReaderNode(ReaderToken.BeginArray);
						return true;
					case JsonNotation.BeginObject:
						this.structure.Push(ReaderToken.BeginObject);
						this.node = new ReaderNode(ReaderToken.BeginObject);
						return true;
					case JsonNotation.EndArray:
						this.structure.Pop();
						this.node = new ReaderNode(ReaderToken.EndOfArray);
						return true;
					case JsonNotation.EndObject:
						this.structure.Pop();
						this.structure.Pop();
						this.node = new ReaderNode(ReaderToken.EndOfObject);
						return true;
					default: throw ReaderException.UnknownNotation(this, new string(this.rawJson.Array, this.rawJson.Offset, this.rawJson.Count));
				}
			}
			if (lexemeSize == 4)
			{
				if (Match(ref lexeme, fragments, 0, this.lexemeTrue))
				{
					this.rawJson = this.lexemeTrue;
					this.node = new ReaderNode(memberOrValueToken, this.Box(true));
					return true;
				}
				if (Match(ref lexeme, fragments, 0, this.lexemeNull))
				{
					this.rawJson = this.lexemeNull;
					this.node = new ReaderNode(ReaderToken.Null);
					return true;
				}
			}
			if (lexemeSize == 5 && Match(ref lexeme, fragments, 0, this.lexemeFalse))
			{
				this.rawJson = this.lexemeFalse;
				this.node = new ReaderNode(memberOrValueToken, this.Box(false));
				return true;
			}

			// combine fragments into one lexeme
			if (fragments != null)
			{
				var combined = new char[lexemeSize];
				var offset = 0;
				foreach (var fragment in fragments)
				{
					if (fragment.Array == null) break;
					Buffer.BlockCopy(fragment.Array, fragment.Offset * CHAR_SIZE, combined, offset * CHAR_SIZE, fragment.Count * CHAR_SIZE);
					offset += fragment.Count;
				}
				lexeme = new ArraySegment<char>(combined, 0, offset);
				//fragments = null;
			}

			this.rawJson = lexeme;
			System.Diagnostics.Debug.Assert(lexeme.Array != null, "lexeme.Array");
			if (lexeme.Array[lexeme.Offset] == JsonNotation.Quote) // start with quote
			{
				if (lexeme.Array[lexeme.Offset + lexeme.Count - 1] != JsonNotation.Quote) // not ending with quote
					throw ReaderException.UnterminatedStringLiteral(this);

				if (lexemeSize == 2)
				{
					this.node = new ReaderNode(memberOrValueToken, string.Empty);
					return true;
				}

				this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme));
				return true;
			}

			switch (GetNumberType(ref lexeme))
			{
				case NUMBER_INTEGER:
					var integerType = lexeme.Count < Int32MaxLength
						? typeof(int)
						: lexeme.Count < Int64MaxLength ? typeof(long) : typeof(ulong);
					this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme, integerType));
					return true;
				case NUMBER_NEGATIVE_INTEGER:
					var signedIntegerType = lexeme.Count < Int32MaxLength + 1 ? typeof(int) : typeof(long);
					this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme, signedIntegerType));
					return true;
				case NUMBER_FLOAT:
				case NUMBER_FLOAT_WITH_EXP:
					this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme, typeof(double)));
					return true;
				default:
					System.Diagnostics.Debug.Assert(this.rawJson.Array != null, "rawJsonArray");
					throw ReaderException.UnknownNotation(this, new string(this.rawJson.Array, this.rawJson.Offset, this.rawJson.Count));
			}
		}

		private object Box(ref ArraySegment<char> lexeme, Type type = default)
		{
			var jsonValueBox = this.jsonValueBox ?? (this.jsonValueBox = new JsonValueBox());
			jsonValueBox.Store(lexeme, type ?? typeof(string));
			return jsonValueBox;
		}
		private object Box(int value)
		{
			var intBox = this.intBox ?? (this.intBox = new StrongBox<int>(CultureInfo.InvariantCulture));
			intBox.Store(value);
			return intBox;
		}
		private object Box(DateTime value)
		{
			var dateBox = this.dateBox ?? (this.dateBox = new StrongBox<DateTime>(CultureInfo.InvariantCulture));
			dateBox.Store(value);
			return dateBox;
		}
		private object Box(bool value)
		{
			if (value)
			{
				return this.trueBox ?? (this.trueBox = new StrongBox<bool>(true, CultureInfo.InvariantCulture));
			}
			return this.falseBox ?? (this.falseBox = new StrongBox<bool>(false, CultureInfo.InvariantCulture));
		}

		private static bool Match(ref ArraySegment<char> lexeme, ArraySegment<char>[] fragments, int offset, ArraySegment<char> matchTo)
		{
			var lexemeArray = lexeme.Array;
			System.Diagnostics.Debug.Assert(lexemeArray != null, "lexemeArray != null");

			var matchToArray = matchTo.Array;
			System.Diagnostics.Debug.Assert(matchToArray != null, "matchToArray != null");

			var count = matchTo.Count;
			if (fragments == null)
			{
				for (var i = 0; i < count; i++)
				{
					if (lexemeArray[lexeme.Offset + i] != matchToArray[matchTo.Offset + i])
						return false;
				}

				return true;
			}
			var mo = 0;
			foreach (var fg in fragments)
			{
				if (fg.Array == null) break;

				for (var i = 0; i < fg.Count; i++)
				{
					if (fg.Array[fg.Offset + i] != matchToArray[mo])
						return false;

					mo++;
				}
			}

			return true;
		}
		private static int GetNumberType(ref ArraySegment<char> lexeme)
		{
			const int INT_PART = 0;
			const int FRAC_PART = 1;
			const int EXP_PART = 2;
			const char POINT = '.';
			const char EXPONENT = 'E';
			const char EXPONENT_ALT = 'e';
			const char PLUS = '+';
			const char MINUS = '-';
			const char DIGIT_START = '0';
			const char DIGIT_END = '9';

			var isNegative = false;
			var buffer = lexeme.Array;
			var offset = lexeme.Offset;
			var count = lexeme.Offset + lexeme.Count;

			System.Diagnostics.Debug.Assert(buffer != null, "buffer != null");

			var part = INT_PART;

			for (var i = offset; i < count; i++)
			{
				var character = buffer[i];

				switch (part)
				{
					case INT_PART:
						switch (character)
						{
							case MINUS:
								if (i != offset)
								{
									return NUMBER_NOT;
								}
								isNegative = true;
								break;
							case PLUS:
								if (i != offset)
								{
									return NUMBER_NOT;
								}
								break;
							case POINT:
								if (i == offset)
								{
									return NUMBER_NOT; // decimal point as first character
								}
								part = FRAC_PART;
								break;
							default:
								if (character == EXPONENT || character == EXPONENT_ALT)
								{
									if (i == offset)
									{
										return NUMBER_NOT; // exponent at first character
									}
									part = EXP_PART;
								}
								else if (character < DIGIT_START && character > DIGIT_END)
								{
									return NUMBER_NOT; // non digit character in integer part
								}
								break;
						}
						break;
					case FRAC_PART:
						if (character == EXPONENT || character == EXPONENT_ALT)
						{
							if (i == offset)
							{
								return NUMBER_NOT; // exponent at first character
							}
							part = EXP_PART;
						}
						else if (character < DIGIT_START && character > DIGIT_END)
						{
							return NUMBER_NOT; // non digit character in fraction part
						}
						break;
					case EXP_PART:
						if (character == PLUS || character == MINUS)
						{
							if (buffer[i - 1] != EXPONENT && buffer[i - 1] != EXPONENT_ALT)
							{
								return NUMBER_NOT; // sign not at start of exponent part
							}
						}
						else if (character < DIGIT_START && character > DIGIT_END)
						{
							return NUMBER_NOT; // non digit character in integer part
						}
						break;
				}
			}

			switch (part)
			{
				case INT_PART: return isNegative ? NUMBER_NEGATIVE_INTEGER : NUMBER_INTEGER;
				case FRAC_PART: return NUMBER_FLOAT;
				case EXP_PART: return NUMBER_FLOAT_WITH_EXP;
				default: return NUMBER_NOT;
			}
		}
		private static ArraySegment<char> Copy(ref ArraySegment<char> lexeme)
		{
			var lexemeArray = lexeme.Array;

			var newLexemeArray = new char[lexeme.Count];
			var newLexeme = new ArraySegment<char>(newLexemeArray, 0, lexeme.Count);

			System.Diagnostics.Debug.Assert(lexemeArray != null, "lexemeArray != null");

			Buffer.BlockCopy(lexemeArray, lexeme.Offset * CHAR_SIZE, newLexemeArray, 0, lexeme.Count * CHAR_SIZE);
			return newLexeme;
		}
		private static bool IsWhiteSpaceLatin(char character)
		{
			return character == ' ' || character >= '\t' && character <= '\r' || (character == '' || character == '\x0085');
		}
		private ArraySegment<char> NextLexeme(ref int state)
		{
			this.ResetBufferIfNeeded();

			var buffer = this.buffer;
			var lexemeStartIndex = this.bufferOffset;
			var lexemeLength = 0;

			start:
			if (this.bufferAvailable == 0 && this.ReadToBuffer() == 0)
			{
				state = LEXER_STATE_COMPLETE;
				return new ArraySegment<char>(this.buffer, lexemeStartIndex, lexemeLength);
			}

			if (state == LEXER_STATE_COMPLETE)
				state = LEXER_STATE_START;

			var bufferEnd = this.bufferOffset + this.bufferAvailable;
			for (var i = this.bufferOffset; i < bufferEnd; i++)
			{
				this.colNum++;
				switch (state)
				{
					case LEXER_STATE_START:
						switch (buffer[i])
						{
							case JsonNotation.Newline: this.lineNum++; this.colNum = 1; goto case JsonNotation.Space;
							case JsonNotation.Space:
							case JsonNotation.Return:
							case JsonNotation.Tab:
							case JsonNotation.IdentifierSeparator:
								continue; // insignificant whitespaces
							case JsonNotation.ValueSeparator:
								if (this.structure.Peek() == ReaderToken.BeginObject) throw ReaderException.ReadingBrokenDocument(this, "A value is expected");

								continue;
							case JsonNotation.Comment:
								state = LEXER_STATE_COMMENT_BEGINNING;
								continue;
							case JsonNotation.EndArray:
							case JsonNotation.EndObject:
							case JsonNotation.BeginObject:
							case JsonNotation.BeginArray:
								state = LEXER_STATE_COMPLETE;
								this.bufferOffset = i + 1;
								this.bufferAvailable = bufferEnd - i - 1;
								return new ArraySegment<char>(buffer, i, 1);
							case JsonNotation.Quote:
								lexemeStartIndex = i;
								state = LEXER_STATE_QUOTED;
								continue;
							default:
								if (IsWhiteSpaceLatin(buffer[i]))
								{
									goto case JsonNotation.Space;
								}
								lexemeStartIndex = i;
								state = LEXER_STATE_LEXEME;
								continue;
						}
					case LEXER_STATE_LEXEME:
						switch (buffer[i])
						{
							// lexeme terminators
							case JsonNotation.Space:
							case JsonNotation.Newline:
							case JsonNotation.Return:
							case JsonNotation.Tab:
							case JsonNotation.IdentifierSeparator:
							case JsonNotation.ValueSeparator:
							case JsonNotation.EndArray:
							case JsonNotation.EndObject:
							case JsonNotation.BeginObject:
							case JsonNotation.BeginArray:
								state = LEXER_STATE_COMPLETE;
								this.bufferOffset = i;
								this.bufferAvailable = bufferEnd - i;
								return new ArraySegment<char>(buffer, lexemeStartIndex, i - lexemeStartIndex);
							default:
								if (IsWhiteSpaceLatin(buffer[i]))
								{
									goto case JsonNotation.Space;
								}
								continue;
						}
					case LEXER_STATE_QUOTED:
					case LEXER_STATE_QUOTED_ESCAPE:
						switch (buffer[i])
						{
							case JsonNotation.Newline:
							case JsonNotation.Return:
								throw ReaderException.UnterminatedStringLiteral(this);
							case JsonNotation.Quote:
								if (state == LEXER_STATE_QUOTED_ESCAPE)
								{
									state = LEXER_STATE_QUOTED;
									continue;
								}

								state = LEXER_STATE_COMPLETE;
								this.bufferOffset = i + 1;
								this.bufferAvailable = bufferEnd - i - 1;
								return new ArraySegment<char>(buffer, lexemeStartIndex, i - lexemeStartIndex + 1);
							case JsonNotation.Escape:
								state = LEXER_STATE_QUOTED_ESCAPE; // skips escaped quotes - \"
								continue;
							default:
								if (state == LEXER_STATE_QUOTED_ESCAPE)
								{
									state = LEXER_STATE_QUOTED;
								}
								continue;
						}
					case LEXER_STATE_COMMENT_BEGINNING:
						switch (buffer[i])
						{
							case JsonNotation.Comment:
								state = LEXER_STATE_COMMENT_SINGLE_LINE;
								continue;
							case JsonNotation.CommentMultiline:
								state = LEXER_STATE_COMMENT_MULTILINE;
								continue;
							default:
								throw ReaderException.UnknownNotation(this, JsonNotation.Comment + buffer[i].ToString());
						}
					case LEXER_STATE_COMMENT_SINGLE_LINE:
						switch (buffer[i])
						{
							case JsonNotation.Newline:
							case JsonNotation.Return:
								state = LEXER_STATE_START;
								continue;
							default: continue;
						}
					case LEXER_STATE_COMMENT_MULTILINE_ENDING:
					case LEXER_STATE_COMMENT_MULTILINE:
						switch (buffer[i])
						{
							case JsonNotation.CommentMultiline:
								state = LEXER_STATE_COMMENT_MULTILINE_ENDING;
								continue;
							case JsonNotation.Comment:
								if (state == LEXER_STATE_COMMENT_MULTILINE_ENDING)
									state = LEXER_STATE_START;
								continue;
							default: continue;
						}

				}
			}

			if (state == LEXER_STATE_START || state == LEXER_STATE_COMMENT_BEGINNING || state == LEXER_STATE_COMMENT_MULTILINE ||
				state == LEXER_STATE_COMMENT_MULTILINE_ENDING || state == LEXER_STATE_COMMENT_SINGLE_LINE)
			{
				// no lexemes found in current buffer
				this.bufferOffset = this.bufferAvailable = lexemeStartIndex = lexemeLength = 0;
				goto start; // restart
			}

			lexemeLength = bufferEnd - lexemeStartIndex;

			// buffer contains only fragment of lexeme
			// lexeme parsing is not complete so there is 2 options:
			// 1) try to fill buffer and retry parsing
			// 2) return fragment to caller

			if (lexemeLength < this.buffer.Length / 2)
			{
				// if fragment is small then move fragment to the start of the buffer and re-start parsing
				if (lexemeStartIndex != 0)
				{
					Buffer.BlockCopy(this.buffer, lexemeStartIndex * CHAR_SIZE, this.buffer, 0, lexemeLength * CHAR_SIZE);
					lexemeStartIndex = 0;
				}

				this.bufferOffset = lexemeLength;
				this.bufferAvailable = 0;

				goto start; // restart
			}
			else
			{
				// if fragment is huge then return it to caller

				// set buffer is consumed
				this.bufferOffset = this.bufferAvailable = 0;

				return new ArraySegment<char>(this.buffer, lexemeStartIndex, lexemeLength);
			}
		}
		private void ResetBufferIfNeeded()
		{
			if (this.bufferAvailable == 0)
			{
				this.bufferOffset = 0;
			}
		}
		private int ReadToBuffer()
		{
			if (this.bufferOffset + this.bufferAvailable >= this.buffer.Length)
			{
				throw new InvalidOperationException("Unable to read to buffer because there is not space available. This will cause zero read and erroneous 'End Of Stream' message.");
			}

			var offset = this.bufferOffset + this.bufferAvailable;
			var count = this.buffer.Length - offset;
			var read = this.textReader.Read(this.buffer, offset, count);
			this.bufferAvailable += read;
			return read;
		}

		public override void Dispose()
		{
			if (!this.leaveOpen)
			{
				this.textReader.Dispose();
			}
		}

		private sealed class JsonValueBox : IStrongBox
		{
			private ArraySegment<char> value;
			private Type valueType;

			public Type ValueType => this.valueType;

			public bool AsBoolean => Convert.ToBoolean(this.LoadString(), CultureInfo.InvariantCulture);
			public byte AsByte => checked((byte)this.LoadUInt32());
			public short AsInt16 => checked((short)this.LoadInt32());
			public int AsInt32 => this.LoadInt32();
			public long AsInt64 => this.LoadInt64();
			public sbyte AsSByte => checked((sbyte)this.LoadInt32());
			public ushort AsUInt16 => checked((ushort)this.LoadUInt32());
			public uint AsUInt32 => this.LoadUInt32();
			public ulong AsUInt64 => this.LoadUInt64();
			public float AsSingle => Convert.ToSingle(this.LoadString(), CultureInfo.InvariantCulture);
			public double AsDouble => Convert.ToDouble(this.LoadString(), CultureInfo.InvariantCulture);
			public decimal AsDecimal => Convert.ToDecimal(this.LoadString(), CultureInfo.InvariantCulture);
			public DateTimeOffset AsDateTimeOffset => DateTimeOffset.ParseExact(this.LoadString(), GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
			public DateTime AsDateTime => DateTime.ParseExact(this.LoadString(), GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
			public TimeSpan AsTimeSpan => TimeSpan.Parse(this.LoadString(), CultureInfo.InvariantCulture);
			public object AsObject => this.LoadString();

			private uint LoadUInt32()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToUInt32(array, offset, count);
			}
			private ulong LoadUInt64()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToUInt64(array, offset, count);
			}
			private int LoadInt32()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToInt32(array, offset, count);
			}
			private long LoadInt64()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToInt64(array, offset, count);
			}
			private string LoadString()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.UnEscapeBuffer(array, offset, count, false);
			}

			public void Store<T>(T value)
			{
				this.value = (ArraySegment<char>)(object)value;
				this.valueType = typeof(string);
			}

			public void Store(ArraySegment<char> value, Type valueType)
			{
				if (valueType == null) throw new ArgumentNullException(nameof(valueType));

				this.value = value;
				this.valueType = valueType;
			}

			public override string ToString()
			{
				return this.LoadString();
			}
		}

		private static class JsonUtils
		{
			public static string UnEscapeBuffer(char[] charsToUnEscape, int offset, int count, bool strict)
			{
				if (charsToUnEscape == null) throw new ArgumentNullException(nameof(charsToUnEscape));
				if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
				if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
				if (offset + count > charsToUnEscape.Length) throw new ArgumentOutOfRangeException(nameof(offset));

				var unEscapedCount = GetUnEscapedCount(charsToUnEscape, offset, count);
				if (unEscapedCount == count)
				{
					return new string(charsToUnEscape, offset, count);
				}

				var resultBuilder = new StringBuilder(unEscapedCount);
				var plainStart = offset;
				var plainLen = 0;
				var end = offset + count;
				for (var i = offset; i < end; i++)
				{
					var ch = charsToUnEscape[i];
					if (ch != '\\')
					{
						plainLen++;
						continue;
					}

					if (i + 1 >= end)
					{
						if (strict)
						{
							throw ReaderException.UnknownEscapeSequence("\\\0", null);
						}
						else
						{
							plainLen++;
							break; // u
						}
					}

					var sequenceLength = 1;
					// append unencoded chunk
					if (plainLen != 0)
					{
						resultBuilder.Append(charsToUnEscape, plainStart, plainLen);
						plainLen = 0;
					}

					var sequenceKind = charsToUnEscape[i + 1];
					switch (sequenceKind)
					{
						case 'n':
							resultBuilder.Append('\n');
							break;
						case 'r':
							resultBuilder.Append('\r');
							break;
						case 'b':
							resultBuilder.Append('\b');
							break;
						case 'f':
							resultBuilder.Append('\f');
							break;
						case 't':
							resultBuilder.Append('\t');
							break;
						case '\\':
							resultBuilder.Append('\\');
							break;
						case '/':
							resultBuilder.Append('/');
							break;
						case '\'':
							resultBuilder.Append('\'');
							break;
						case '\"':
							resultBuilder.Append('\"');
							break;

						// unicode symbol
						case 'u':
							resultBuilder.Append((char)HexStringToUInt32(charsToUnEscape, i + 2, 4));
							sequenceLength = 5;
							break;

						// latin hex encoded symbol
						case 'x':
							resultBuilder.Append((char)HexStringToUInt32(charsToUnEscape, i + 2, 2));
							sequenceLength = 3;
							break;

						// latin dec encoded symbol
						case '1':
						case '2':
						case '3':
						case '4':
						case '5':
						case '6':
						case '7':
						case '8':
						case '9':
						case '0':
							resultBuilder.Append((char)StringToInt32(charsToUnEscape, i + 1, 3));
							sequenceLength = 3;
							break;
						default:
							if (!strict)
							{
								resultBuilder.Append(sequenceKind);
								break;
							}
							else
							{
								throw ReaderException.UnknownEscapeSequence("\\" + sequenceKind, null);
							}
					}

					// set next chunk start right after this escape
					plainStart = i + sequenceLength + 1;
					i += sequenceLength;
				}

				// append last unencoded chunk
				if (plainLen != 0)
				{
					resultBuilder.Append(charsToUnEscape, plainStart, plainLen);
				}

				return resultBuilder.ToString();
			}
			private static int GetUnEscapedCount(char[] charsToUnEscape, int offset, int count)
			{
				if (charsToUnEscape == null) throw new ArgumentNullException(nameof(charsToUnEscape));
				if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
				if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
				if (offset + count > charsToUnEscape.Length) throw new ArgumentOutOfRangeException(nameof(offset));

				var newCount = 0;
				var end = offset + count;
				for (var i = offset; i < end; i++)
				{
					var ch = charsToUnEscape[i];
					newCount++;
					if (ch != '\\')
					{
						continue;
					}

					var toSkip = 1;
					var sequenceKind = charsToUnEscape[i + 1];
					switch (sequenceKind)
					{
						// unicode symbol
						case 'u':
							toSkip = 5;
							break;

						// latin hex encoded symbol
						case 'x':
							toSkip = 3;
							break;
						// latin dec encoded symbol
						case '1':
						case '2':
						case '3':
						case '4':
						case '5':
						case '6':
						case '7':
						case '8':
						case '9':
						case '0':
							toSkip = 3;
							break;
						default:
							toSkip = 1;
							break;
					}
					i += toSkip;
				}
				return newCount;
			}

			public static uint HexStringToUInt32(char[] buffer, int offset, int count)
			{
				const uint ZERO = '0';
				const uint a = 'a';
				const uint A = 'A';

				var result = 0u;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					var d = 0u;
					if (c >= '0' && c <= '9')
						d = (c - ZERO);
					else if (c >= 'a' && c <= 'f')
						d = 10u + (c - a);
					else if (c >= 'A' && c <= 'F')
						d = 10u + (c - A);
					else
						throw new FormatException();

					result = 16u * result + d;
				}

				return result;
			}

			public static long StringToInt64(char[] buffer, int offset, int count)
			{
				const ulong ZERO = '0';

				var result = 0UL;
				var neg = false;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (i == 0 && c == '-')
					{
						neg = true;
						continue;
					}
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10UL * result + (c - ZERO));
				}

				if (neg)
					return -(long)(result);
				return (long)result;
			}
			public static int StringToInt32(char[] buffer, int offset, int count)
			{
				const uint ZERO = '0';

				var result = 0u;
				var neg = false;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (i == 0 && c == '-')
					{
						neg = true;
						continue;
					}
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10u * result + (c - ZERO));
				}

				if (neg)
					return -(int)(result);
				return (int)result;
			}
			public static ulong StringToUInt64(char[] buffer, int offset, int count)
			{
				const ulong ZERO = '0';

				var result = 0UL;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10UL * result + (c - ZERO));
				}

				return result;
			}
			public static uint StringToUInt32(char[] buffer, int offset, int count)
			{
				const uint ZERO = '0';

				var result = 0U;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10 * result + (c - ZERO));
				}

				return result;
			}
		}

		private static class JsonNotation
		{
			public const char Tab = '\t';
			public const char Space = ' ';
			public const char Newline = '\n';
			public const char Return = '\r';
			public const char IdentifierSeparator = ':';
			public const char ValueSeparator = ',';
			public const char BeginArray = '[';
			public const char EndArray = ']';
			public const char BeginObject = '{';
			public const char EndObject = '}';
			public const char Escape = '\\';
			public const char Comment = '/';
			public const char CommentMultiline = '*';
			public const char Quote = '\"';
			public const char Const0 = '0';
			public const char Const1 = '1';
			public const char Const2 = '2';
			public const char Const3 = '3';
			public const char Const4 = '4';
			public const char Const5 = '5';
			public const char Const6 = '6';
			public const char Const7 = '7';
			public const char Const8 = '8';
			public const char Const9 = '9';
			public const string True = "true";
			public const string False = "false";
			public const string Null = "null";
		}
	}


	public sealed class MessagePackGameDataReader : GameDataReader
	{
		private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue;
		private const int MAX_BINARY_LENGTH = 16 * 1024 * 1024;
		private const int MAX_STRING_LENGTH = 16 * 1024 * 1024;

		private struct Map
		{
			public ReaderToken Token;
			public long Counter;
		}

		private readonly Stream inputStream;
		private readonly bool leaveOpen;
		private readonly byte[] buffer;
		private readonly EndianBitConverter bitConverter;
		private readonly Stack<Map> maps;
		private ReaderNode node;
		private int bufferOffset;
		private int bufferRead;
		private int bufferAvailable;
		private int totalBytesRead;

		private StrongBox<int> int32Box;
		private StrongBox<uint> uInt32Box;
		private StrongBox<long> int64Box;
		private StrongBox<ulong> uInt64Box;
		private StrongBox<float> singleBox;
		private StrongBox<double> doubleBox;
		private StrongBox<decimal> decimalBox;
		private StrongBox<DateTime> dateBox;
		private StrongBox<DateTimeOffset> dateOffsetBox;
		private StrongBox<TimeSpan> timeSpanBox;
		private StrongBox<Guid> guidBox;
		private StrongBox<bool> trueBox;
		private StrongBox<bool> falseBox;

		public override int LineNumber => 0;
		public override int ColumnNumber => this.totalBytesRead;
		public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

		public MessagePackGameDataReader(Stream stream, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
		{
			if (stream == null) throw new ArgumentNullException(nameof(stream));

			if (bufferSize < DEFAULT_BUFFER_SIZE)
				bufferSize = DEFAULT_BUFFER_SIZE;

			this.inputStream = stream;
			this.leaveOpen = leaveOpen;
			this.buffer = new byte[bufferSize];
			this.bufferOffset = 0;
			this.bufferRead = 0;
			this.bufferAvailable = 0;
			this.bitConverter = EndianBitConverter.Big;
			this.maps = new Stack<Map>();
		}

		public override bool NextToken()
		{
			if (this.maps.Count > 0 && this.maps.Peek().Counter == 0)
			{
				var closingToken = this.maps.Pop();
				this.node = new ReaderNode(closingToken.Token);

				this.DecrementClosingTokenCounter();
				return true;
			}

			if (!this.ReadToBuffer(1, throwOnEos: false))
			{
				this.node = new ReaderNode(ReaderToken.EndOfStream);
				return false;
			}

			var formatValue = this.buffer[this.bufferOffset];
			if (formatValue >= (byte)MessagePackType.FixArrayStart && formatValue <= (byte)MessagePackType.FixArrayEnd)
			{
				var arrayCount = formatValue - (byte)MessagePackType.FixArrayStart;

				this.maps.Push(new Map { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
				this.node = new ReaderNode(ReaderToken.BeginArray);
			}
			else if (formatValue >= (byte)MessagePackType.FixStrStart && formatValue <= (byte)MessagePackType.FixStrEnd)
			{
				var strCount = formatValue - (byte)MessagePackType.FixStrStart;
				var strBytes = this.ReadBytes(strCount);

				var token = ReaderToken.Value;
				if (this.maps.Count > 0)
				{
					var closingToken = this.maps.Peek();
					if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
						token = ReaderToken.Member;
				}

				var strValue = default(string);

				System.Diagnostics.Debug.Assert(strBytes.Array != null, "strBytes.Array != null");

				strValue = Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count);

				this.node = new ReaderNode(token, strValue);
			}
			else if (formatValue >= (byte)MessagePackType.FixMapStart && formatValue <= (byte)MessagePackType.FixMapEnd)
			{
				var mapCount = formatValue - (byte)MessagePackType.FixMapStart;
				this.maps.Push(new Map { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
				this.node = new ReaderNode(ReaderToken.BeginObject);
			}
			else if (formatValue >= (byte)MessagePackType.NegativeFixIntStart)
			{
				this.node = new ReaderNode(ReaderToken.Value, this.Box(unchecked((sbyte)formatValue)));
			}
			else if (formatValue <= (byte)MessagePackType.PositiveFixIntEnd)
			{
				this.node = new ReaderNode(ReaderToken.Value, this.Box(formatValue));
			}
			else
			{
				switch ((MessagePackType)formatValue)
				{
					case MessagePackType.Nil:
						this.node = new ReaderNode(ReaderToken.Null);
						break;
					case MessagePackType.Array16:
					case MessagePackType.Array32:
						var arrayCount = 0L;
						if (formatValue == (int)MessagePackType.Array16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							arrayCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Array32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							arrayCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						if (arrayCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of array");

						this.maps.Push(new Map { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
						this.node = new ReaderNode(ReaderToken.BeginArray);
						break;
					case MessagePackType.Map16:
					case MessagePackType.Map32:
						var mapCount = 0L;
						if (formatValue == (int)MessagePackType.Map16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							mapCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Map32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							mapCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						if (mapCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of map");

						this.maps.Push(new Map { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
						this.node = new ReaderNode(ReaderToken.BeginObject);
						break;
					case MessagePackType.Str16:
					case MessagePackType.Str32:
					case MessagePackType.Str8:
						var strBytesCount = 0L;
						if (formatValue == (int)MessagePackType.Str8)
						{
							this.ReadToBuffer(1, throwOnEos: true);
							strBytesCount = this.buffer[this.bufferOffset];
						}
						else if (formatValue == (int)MessagePackType.Str16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							strBytesCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Str32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							strBytesCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						var token = ReaderToken.Value;
						if (this.maps.Count > 0)
						{
							var closingToken = this.maps.Peek();
							if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
								token = ReaderToken.Member;
						}

						if (strBytesCount > MAX_STRING_LENGTH) throw ReaderException.StringLiteralIsTooLong(this, (int)strBytesCount, MAX_STRING_LENGTH);

						var strBytes = this.ReadBytes(strBytesCount);
						System.Diagnostics.Debug.Assert(strBytes.Array != null, "strBytes.Array != null");
						var stringValue = Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count);
						this.node = new ReaderNode(token, stringValue);
						break;
					case MessagePackType.Bin32:
					case MessagePackType.Bin16:
					case MessagePackType.Bin8:
						var bytesCount = 0L;
						if (formatValue == (int)MessagePackType.Bin8)
						{
							this.ReadToBuffer(1, throwOnEos: true);
							bytesCount = this.buffer[this.bufferOffset];
						}
						else if (formatValue == (int)MessagePackType.Bin16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							bytesCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Bin32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							bytesCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						if (bytesCount > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, (int)bytesCount, MAX_BINARY_LENGTH);
						if (bytesCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of binary data");

						var bytes = this.ReadBytes(bytesCount, forceNewBuffer: true);
						System.Diagnostics.Debug.Assert(bytes.Array != null, "bytes.Array != null");
						this.node = new ReaderNode(ReaderToken.Value, bytes.Array);
						break;
					case MessagePackType.FixExt1:
					case MessagePackType.FixExt16:
					case MessagePackType.FixExt2:
					case MessagePackType.FixExt4:
					case MessagePackType.FixExt8:
					case MessagePackType.Ext32:
					case MessagePackType.Ext16:
					case MessagePackType.Ext8:
						var extLength = 0L;
						if (formatValue == (int)MessagePackType.FixExt1)
							extLength = 1;
						else if (formatValue == (int)MessagePackType.FixExt2)
							extLength = 2;
						else if (formatValue == (int)MessagePackType.FixExt4)
							extLength = 4;
						else if (formatValue == (int)MessagePackType.FixExt8)
							extLength = 8;
						else if (formatValue == (int)MessagePackType.FixExt16)
							extLength = 16;
						if (formatValue == (int)MessagePackType.Ext8)
						{
							this.ReadToBuffer(1, throwOnEos: true);
							extLength = this.buffer[this.bufferOffset];
						}
						else if (formatValue == (int)MessagePackType.Ext16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							extLength = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Ext32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							extLength = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						this.ReadToBuffer(1, throwOnEos: true);
						var extType = this.buffer[this.bufferOffset];

						if (extLength > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, (int)extLength, MAX_BINARY_LENGTH);

						var data = this.ReadBytes(extLength, forceNewBuffer: true);
						System.Diagnostics.Debug.Assert(data.Array != null, "data.Array != null");
						if (!this.TryReadExtType(extType, data, out this.node))
							this.node = new ReaderNode(ReaderToken.Value, data.Array);
						break;
					case MessagePackType.False:
						this.node = new ReaderNode(ReaderToken.Value, this.Box(false));
						break;
					case MessagePackType.True:
						this.node = new ReaderNode(ReaderToken.Value, this.Box(true));
						break;
					case MessagePackType.Float32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToSingle(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Float64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToDouble(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int16:
						this.ReadToBuffer(2, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToInt16(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToInt32(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToInt64(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int8:
						this.ReadToBuffer(1, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(unchecked((sbyte)this.buffer[this.bufferOffset])));
						break;
					case MessagePackType.UInt16:
						this.ReadToBuffer(2, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box((uint)this.bitConverter.ToUInt16(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.UInt32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToUInt32(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.UInt64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToUInt64(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.UInt8:
						this.ReadToBuffer(1, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box((uint)this.buffer[this.bufferOffset]));
						break;
					case MessagePackType.PositiveFixIntStart:
					case MessagePackType.PositiveFixIntEnd:
					case MessagePackType.FixMapStart:
					case MessagePackType.FixMapEnd:
					case MessagePackType.FixArrayStart:
					case MessagePackType.FixArrayEnd:
					case MessagePackType.FixStrStart:
					case MessagePackType.FixStrEnd:
					case MessagePackType.Unused:
					case MessagePackType.NegativeFixIntStart:
					case MessagePackType.NegativeFixIntEnd:
					default: throw ReaderException.UnknownMessagePackType(((MessagePackType)formatValue).ToString(), this);
				}
			}

			this.DecrementClosingTokenCounter();

			return true;
		}

		private bool ReadToBuffer(int bytesRequired, bool throwOnEos)
		{
			this.bufferAvailable -= this.bufferRead;
			this.bufferOffset += this.bufferRead;
			this.bufferRead = 0;

			if (this.bufferAvailable < bytesRequired)
			{
				if (this.bufferAvailable > 0)
					Buffer.BlockCopy(this.buffer, this.bufferOffset, this.buffer, 0, this.bufferAvailable);

				this.bufferOffset = 0;
				while (this.bufferAvailable < bytesRequired)
				{
					var read = this.inputStream.Read(this.buffer, this.bufferAvailable, this.buffer.Length - this.bufferAvailable);
					this.bufferAvailable += read;

					if (read != 0 || this.bufferAvailable >= bytesRequired)
						continue;

					if (throwOnEos)
						throw ReaderException.UnexpectedEndOfStream(this);

					return false;
				}
			}

			this.bufferRead = bytesRequired;
			this.totalBytesRead += bytesRequired;
			return true;
		}
		private ArraySegment<byte> ReadBytes(long bytesRequired, bool forceNewBuffer = false)
		{
			if (bytesRequired > int.MaxValue) throw new ArgumentOutOfRangeException(nameof(bytesRequired));

			this.bufferAvailable -= this.bufferRead;
			this.bufferOffset += this.bufferRead;
			this.bufferRead = 0;

			if (this.bufferAvailable >= bytesRequired && !forceNewBuffer)
			{
				var bytes = new ArraySegment<byte>(this.buffer, this.bufferOffset, (int)bytesRequired);

				this.bufferAvailable -= (int)bytesRequired;
				this.bufferOffset += (int)bytesRequired;
				this.totalBytesRead += (int)bytesRequired;

				return bytes;
			}
			else
			{
				var bytes = new byte[bytesRequired];
				var bytesOffset = 0;
				if (this.bufferAvailable > 0 && bytesOffset < bytes.Length)
				{
					var bytesToCopy = Math.Min(bytes.Length, this.bufferAvailable);
					Buffer.BlockCopy(this.buffer, this.bufferOffset, bytes, bytesOffset, bytesToCopy);

					bytesOffset += bytesToCopy;
					this.bufferOffset += bytesToCopy;

					this.bufferAvailable -= bytesToCopy;
					this.totalBytesRead += bytesToCopy;
				}

				if (this.bufferAvailable == 0)
					this.bufferOffset = 0;

				while (bytesOffset < bytes.Length)
				{
					var read = this.inputStream.Read(bytes, bytesOffset, bytes.Length - bytesOffset);

					bytesOffset += read;
					this.totalBytesRead += read;

					if (read == 0 && bytesOffset < bytes.Length)
						throw ReaderException.UnexpectedEndOfStream(this);
				}

				return new ArraySegment<byte>(bytes, 0, bytes.Length);
			}
		}
		private bool TryReadExtType(byte extType, ArraySegment<byte> data, out ReaderNode node)
		{
			const byte EXTENSION_TYPE_TIMESTAMP = 255;
			const byte EXTENSION_TYPE_DATE_TIME = 40;
			const byte EXTENSION_TYPE_DATE_TIME_OFFSET = 41;
			const byte EXTENSION_TYPE_DECIMAL = 42;
			const byte EXTENSION_TYPE_GUID = 43;
			const byte GUID_SIZE = 16;
			const byte DECIMAL_SIZE = 16;
			const byte DATE_TIME_SIZE = 16;
			const byte DATE_TIME_OFFSET_SIZE = 16;

			node = default;
			switch (extType)
			{
				case EXTENSION_TYPE_TIMESTAMP:
					unchecked
					{
						var seconds = 0L;
						var nanoSeconds = 0u;
						switch (data.Count)
						{
							case 4:
								seconds = this.bitConverter.ToInt32(data.Array, data.Offset);
								break;
							case 8:
								var data64 = this.bitConverter.ToUInt64(data.Array, data.Offset);
								seconds = (int)(data64 & 0x00000003ffffffffL);
								nanoSeconds = (uint)(data64 >> 34 & uint.MaxValue);
								break;
							case 12:
								nanoSeconds = this.bitConverter.ToUInt32(data.Array, data.Offset);
								seconds = this.bitConverter.ToInt64(data.Array, data.Offset + 4);
								break;
							default:
								return false;
						}
						node = new ReaderNode(ReaderToken.Value, this.Box(TimeSpan.FromSeconds(seconds).Add(TimeSpan.FromTicks(nanoSeconds / 100))));
						return true;
					}
				case EXTENSION_TYPE_DATE_TIME:
					if (data.Count != DATE_TIME_SIZE)
						return false;
					System.Diagnostics.Debug.Assert(data.Array != null, "data.Array != null");
					var dateTime = new DateTime(this.bitConverter.ToInt64(data.Array, data.Offset + 1), (DateTimeKind)data.Array[data.Offset]);
					node = new ReaderNode(ReaderToken.Value, this.Box(dateTime));
					return true;
				case EXTENSION_TYPE_DATE_TIME_OFFSET:
					if (data.Count != DATE_TIME_OFFSET_SIZE)
						return false;
					var offset = new TimeSpan(this.bitConverter.ToInt64(data.Array, data.Offset + 8));
					var ticks = this.bitConverter.ToInt64(data.Array, data.Offset);
					var dateTimeOffset = new DateTimeOffset(ticks, offset);
					node = new ReaderNode(ReaderToken.Value, this.Box(dateTimeOffset));
					return true;
				case EXTENSION_TYPE_DECIMAL:
					if (data.Count != DECIMAL_SIZE)
						return false;
					var decimalValue = this.bitConverter.ToDecimal(data.Array, data.Offset);
					node = new ReaderNode(ReaderToken.Value, this.Box(decimalValue));
					return true;
				case EXTENSION_TYPE_GUID:
					if (data.Count != GUID_SIZE)
						return false;

					var buffer = data.Array;
					System.Diagnostics.Debug.Assert(buffer != null, "buffer != null");
					unchecked
					{
						var guidValue = new Guid
						(
								(uint)(buffer[data.Offset + 3] << 24 | buffer[data.Offset + 2] << 16 | buffer[data.Offset + 1] << 8 | buffer[data.Offset + 0]),
								(ushort)(buffer[data.Offset + 5] << 8 | buffer[data.Offset + 4]),
								(ushort)(buffer[data.Offset + 7] << 8 | buffer[data.Offset + 6]),
								buffer[data.Offset + 8],
								buffer[data.Offset + 9],
								buffer[data.Offset + 10],
								buffer[data.Offset + 11],
								buffer[data.Offset + 12],
								buffer[data.Offset + 13],
								buffer[data.Offset + 14],
								buffer[data.Offset + 15]
						);

						node = new ReaderNode(ReaderToken.Value, this.Box(guidValue));
						return true;
					}
				default:
					return false;
			}
		}

		private object Box(int value)
		{
			var int32Box = this.int32Box ?? (this.int32Box = new StrongBox<int>(CultureInfo.InvariantCulture));
			int32Box.Store(value);
			return int32Box;
		}
		private object Box(uint value)
		{
			var uInt32Box = this.uInt32Box ?? (this.uInt32Box = new StrongBox<uint>(CultureInfo.InvariantCulture));
			uInt32Box.Store(value);
			return uInt32Box;
		}
		private object Box(long value)
		{
			var int64Box = this.int64Box ?? (this.int64Box = new StrongBox<Int64>(CultureInfo.InvariantCulture));
			int64Box.Store(value);
			return int64Box;
		}
		private object Box(ulong value)
		{
			var uInt64Box = this.uInt64Box ?? (this.uInt64Box = new StrongBox<UInt64>(CultureInfo.InvariantCulture));
			uInt64Box.Store(value);
			return uInt64Box;
		}
		private object Box(float value)
		{
			var singleBox = this.singleBox ?? (this.singleBox = new StrongBox<float>(CultureInfo.InvariantCulture));
			singleBox.Store(value);
			return singleBox;
		}
		private object Box(double value)
		{
			var doubleBox = this.doubleBox ?? (this.doubleBox = new StrongBox<double>(CultureInfo.InvariantCulture));
			doubleBox.Store(value);
			return doubleBox;
		}
		private object Box(decimal value)
		{
			var decimalBox = this.decimalBox ?? (this.decimalBox = new StrongBox<decimal>(CultureInfo.InvariantCulture));
			decimalBox.Store(value);
			return decimalBox;
		}
		private object Box(DateTime value)
		{
			var dateBox = this.dateBox ?? (this.dateBox = new StrongBox<DateTime>(CultureInfo.InvariantCulture));
			dateBox.Store(value);
			return dateBox;
		}
		private object Box(DateTimeOffset value)
		{
			var dateOffsetBox = this.dateOffsetBox ?? (this.dateOffsetBox = new StrongBox<DateTimeOffset>(CultureInfo.InvariantCulture));
			dateOffsetBox.Store(value);
			return dateOffsetBox;
		}
		private object Box(TimeSpan value)
		{
			var timeSpanBox = this.timeSpanBox ?? (this.timeSpanBox = new StrongBox<TimeSpan>(CultureInfo.InvariantCulture));
			timeSpanBox.Store(value);
			return timeSpanBox;
		}
		private object Box(Guid value)
		{
			var guidBox = this.guidBox ?? (this.guidBox = new StrongBox<Guid>(CultureInfo.InvariantCulture));
			guidBox.Store(value);
			return guidBox;
		}
		private object Box(bool value)
		{
			if (value)
			{
				return this.trueBox ?? (this.trueBox = new StrongBox<bool>(true, CultureInfo.InvariantCulture));
			}
			return this.falseBox ?? (this.falseBox = new StrongBox<bool>(false, CultureInfo.InvariantCulture));
		}

		private void DecrementClosingTokenCounter()
		{
			if (this.maps.Count > 0)
			{
				var closingToken = this.maps.Pop();
				closingToken.Counter--;
				this.maps.Push(closingToken);
			}
		}

		public override void Dispose()
		{
			if (!this.leaveOpen)
			{
				this.inputStream.Dispose();
			}
		}


		private enum MessagePackType : byte
		{
			PositiveFixIntStart = 0x00,
			PositiveFixIntEnd = 0x7f,
			FixMapStart = 0x80,
			FixMapEnd = 0x8f,
			FixArrayStart = 0x90,
			FixArrayEnd = 0x9f,
			FixStrStart = 0xa0,
			FixStrEnd = 0xbf,
			Nil = 0xc0,
			Unused = 0xc1,
			False = 0xc2,
			True = 0xc3,
			Bin8 = 0xc4,
			Bin16 = 0xc5,
			Bin32 = 0xc6,
			Ext8 = 0xc7,
			Ext16 = 0xc8,
			Ext32 = 0xc9,
			Float32 = 0xca,
			Float64 = 0xcb,
			UInt8 = 0xcc,
			UInt16 = 0xcd,
			UInt32 = 0xce,
			UInt64 = 0xcf,
			Int8 = 0xd0,
			Int16 = 0xd1,
			Int32 = 0xd2,
			Int64 = 0xd3,
			FixExt1 = 0xd4,
			FixExt2 = 0xd5,
			FixExt4 = 0xd6,
			FixExt8 = 0xd7,
			FixExt16 = 0xd8,
			Str8 = 0xd9,
			Str16 = 0xda,
			Str32 = 0xdb,
			Array16 = 0xdc,
			Array32 = 0xdd,
			Map16 = 0xde,
			Map32 = 0xdf,
			NegativeFixIntStart = 0xe0,
			NegativeFixIntEnd = 0xff
		}

		private enum MessagePackExtentionType : byte
		{
			None = 0,
			DateTime = 40,
			DateTimeOffset = 41,
			Decimal = 42
		}
	}


	public class PatchingGameDataReader : GameDataReader
	{
		private readonly GameDataReader reader;
		private readonly Func<string, string> replaceWithSchemaName;
		private readonly bool leaveOpen;
		private readonly IEnumerator<ReaderNode> overrideEnumerator;
		private ReaderNode currentReaderNode;

		/// <inheritdoc />
		public override ReaderNode Node => this.currentReaderNode;
		/// <inheritdoc />
		public override int LineNumber => this.reader.LineNumber;
		/// <inheritdoc />
		public override int ColumnNumber => this.reader.ColumnNumber;

		public PatchingGameDataReader(GameDataReader reader, IReadOnlyDictionary<string, object> gameDataPatch, Func<string, string> replaceWithSchemaName, bool leaveOpen = false)
		{
			if (reader == null) throw new ArgumentNullException(nameof(reader));
			if (gameDataPatch == null) throw new ArgumentNullException(nameof(gameDataPatch));
			if (replaceWithSchemaName == null) throw new ArgumentNullException(nameof(replaceWithSchemaName));

			this.reader = reader;
			this.replaceWithSchemaName = replaceWithSchemaName;
			this.leaveOpen = leaveOpen;
			this.overrideEnumerator = this.MergeWithObject(new MemberTrackingDictionary<string, object>(gameDataPatch), 1).GetEnumerator();
		}

		/// <inheritdoc />
		public override bool NextToken()
		{
			if (!this.overrideEnumerator.MoveNext())
			{
				this.currentReaderNode = new ReaderNode(ReaderToken.EndOfStream);
				return false;
			}

			this.currentReaderNode = this.overrideEnumerator.Current;
			return true;
		}
		/// <inheritdoc />
		public override void Dispose()
		{
			if (!this.leaveOpen)
			{
				this.reader.Dispose();
			}
		}

		private IEnumerable<ReaderNode> MergeWithObject(MemberTrackingDictionary<string, object> documentPatch, int depth)
		{
			var lastMemberName = "";
			while (this.reader.NextToken())
			{
				switch (this.reader.Node.Token)
				{
					case ReaderToken.Member:
						lastMemberName = this.reader.Node.AsString;
						break; // pass original value
					case ReaderToken.Null:
					case ReaderToken.Value:
						if (!documentPatch.TryGetValue(lastMemberName, out var overrideValue))
						{
							lastMemberName = string.Empty;
							break; // pass original value
						}

						lastMemberName = string.Empty;

						foreach (var readerNode in this.Iterate(overrideValue))
						{
							yield return readerNode;
						}

						continue;
					case ReaderToken.BeginArray:
					case ReaderToken.BeginObject:
						if (depth == 2) // collections
						{
							lastMemberName = this.replaceWithSchemaName(lastMemberName);
						}

						if (!documentPatch.TryGetValue(lastMemberName, out var overrideBeginObject))
						{
							yield return this.reader.Node;  // pass ObjectBegin/ArrayBegin

							// pass original array/object
							foreach (var readerNode in this.PassRestOfContainer(nextToken: false))
							{
								yield return readerNode;
							}

							lastMemberName = string.Empty;
							continue;
						}

						lastMemberName = string.Empty;
						if (overrideBeginObject is IReadOnlyDictionary<string, object> dictionary)
						{
							yield return this.reader.Node; // pass ObjectBegin/ArrayBegin

							if (this.reader.Node.Token == ReaderToken.BeginArray)
							{
								foreach (var readerNode in this.MergeWithArray(new MemberTrackingDictionary<string, object>(dictionary), depth + 1))
								{
									yield return readerNode;
								}
							}
							else
							{
								foreach (var readerNode in this.MergeWithObject(new MemberTrackingDictionary<string, object>(dictionary), depth + 1))
								{
									yield return readerNode;
								}
							}
							continue;
						}

						foreach (var readerNode in this.Iterate(overrideBeginObject))
						{
							yield return readerNode;
						}

						this.reader.SkipAny(nextToken: false);
						continue;
					case ReaderToken.EndOfArray:
					case ReaderToken.EndOfObject:
						// iterate rest of documentPatch
						foreach (var keyValue in documentPatch.EnumerateUntouched())
						{
							yield return new ReaderNode(ReaderToken.Member, keyValue.Key);

							foreach (var readerNode in this.Iterate(keyValue.Value))
							{
								yield return readerNode;
							}
						}

						break;
					case ReaderToken.None:
					case ReaderToken.Comment:
					case ReaderToken.EndOfStream:
						break;
					default:
						throw new ArgumentOutOfRangeException();
				}

				yield return this.reader.Node;
			}
		}

		private IEnumerable<ReaderNode> MergeWithArray(MemberTrackingDictionary<string, object> collectionPatch, int depth)
		{
			while (this.reader.NextToken())
			{
				switch (this.reader.Node.Token)
				{
					case ReaderToken.Null:
					case ReaderToken.Value:
						break; // pass original value
					case ReaderToken.BeginArray:
						yield return new ReaderNode(ReaderToken.BeginArray);

						// pass original array as is
						foreach (var readerNode in this.PassRestOfContainer(nextToken: false))
						{
							yield return readerNode;
						}

						continue;
					case ReaderToken.BeginObject:
						this.reader.ReadObjectBegin();
						var firstMemberName = this.reader.ReadMember();
						var nextTokenIsIdValue = this.reader.Node.Token == ReaderToken.Value;

						if (firstMemberName == "Id" &&
							nextTokenIsIdValue &&
							collectionPatch.TryGetValue(this.reader.Node.AsString, out var documentPatchObj))
						{
							if (documentPatchObj is IReadOnlyDictionary<string, object> documentPatch)
							{
								yield return new ReaderNode(ReaderToken.BeginObject);
								yield return new ReaderNode(ReaderToken.Member);
								yield return this.reader.Node; // Id value

								foreach (var readerNode in this.MergeWithObject(new MemberTrackingDictionary<string, object>(documentPatch), depth + 1))
								{
									yield return readerNode;
								}

								continue;
							}
							else
							{
								this.reader.SkipRestOfObject(nextToken: false); // document deleted in patch
								continue;
							}
						}

						if (firstMemberName == "Id" && depth != 3 /* document collections */)
						{
							this.reader.SkipRestOfObject(nextToken: false); // document deleted in patch, doesn't apply in /Collections/<SchemaName>/
							continue;
						}
						else
						{
							yield return new ReaderNode(ReaderToken.BeginObject);
							yield return new ReaderNode(ReaderToken.Member);
							yield return this.reader.Node; // Id value

							// continue iterate this document
							foreach (var readerNode in this.PassRestOfContainer(nextToken: false))
							{
								yield return readerNode;
							}

							continue;
						}
					case ReaderToken.EndOfArray:
						// iterate rest of collectionPatch
						foreach (var keyValue in collectionPatch.EnumerateUntouched())
						{
							foreach (var readerNode in this.Iterate(keyValue.Value))
							{
								yield return readerNode;
							}
						}

						break; // pass original EndOfArray
					case ReaderToken.None:
					case ReaderToken.Member:
					case ReaderToken.EndOfObject:
					case ReaderToken.Comment:
					case ReaderToken.EndOfStream:
						break;
					default:
						throw new ArgumentOutOfRangeException();
				}

				yield return this.reader.Node;
			}
		}

		private IEnumerable<ReaderNode> PassRestOfContainer(bool nextToken = true)
		{
			var depth = 1;
			while (depth > 0 && this.reader.NextToken())
			{
				switch (this.reader.Node.Token)
				{
					case ReaderToken.BeginArray:
					case ReaderToken.BeginObject:
						depth++;
						break;
					case ReaderToken.EndOfArray:
					case ReaderToken.EndOfObject:
						depth--;
						break;
				}

				yield return this.reader.Node;
			}

			if (nextToken)
			{
				this.reader.NextToken();
			}
		}

		private IEnumerable<ReaderNode> Iterate(IReadOnlyDictionary<string, object> dictionary)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

			yield return new ReaderNode(ReaderToken.BeginObject, dictionary.Count);

			foreach (var kv in dictionary)
			{
				yield return new ReaderNode(ReaderToken.Member, kv.Key);

				var value = kv.Value;
				foreach (var tokenAndValue in this.Iterate(value))
				{
					yield return tokenAndValue;
				}
			}

			yield return new ReaderNode(ReaderToken.EndOfObject, dictionary.Count);
		}
		private IEnumerable<ReaderNode> Iterate(IReadOnlyList<object> list)
		{
			if (list == null) throw new ArgumentNullException(nameof(list));

			var count = list?.Count ?? 0;
			yield return new ReaderNode(ReaderToken.BeginArray, count);

			count = 0;
			foreach (var value in list)
			{
				foreach (var node in this.Iterate(value))
				{
					yield return node;
				}

				count++;
			}

			yield return new ReaderNode(ReaderToken.EndOfArray, count);
		}
		private IEnumerable<ReaderNode> Iterate(object value)
		{
			switch (value)
			{
				case null:
					yield return new ReaderNode(ReaderToken.Null);

					break;
				case IReadOnlyDictionary<string, object> dictionary:
					foreach (var tokenAndValue in this.Iterate(dictionary))
					{
						yield return tokenAndValue;
					}

					break;
				case IReadOnlyList<object> enumerable:
					foreach (var tokenAndValue in this.Iterate(enumerable))
					{
						yield return tokenAndValue;
					}

					break;
				default:
					yield return new ReaderNode(ReaderToken.Value, value);

					break;
			}
		}

		private struct MemberTrackingDictionary<KeyT, ValueT> : IReadOnlyDictionary<KeyT, ValueT>
		{
			private readonly IReadOnlyDictionary<KeyT, ValueT> dictionary;
			private readonly HashSet<KeyT> usedKeys;
			private ulong usedKeysIndexes;

			/// <inheritdoc />
			public int Count => this.dictionary.Count;
			/// <inheritdoc />
			public ValueT this[KeyT key] => this.dictionary[this.MarkKeyUsed(key)];

			/// <inheritdoc />
			public IEnumerable<KeyT> Keys => this.dictionary.Keys;
			/// <inheritdoc />
			public IEnumerable<ValueT> Values => this.dictionary.Values;

			public MemberTrackingDictionary(IReadOnlyDictionary<KeyT, ValueT> dictionary)
			{
				if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

				this.dictionary = dictionary;
				this.usedKeysIndexes = 0;
				var isIndexed = this.dictionary.Count <= 63 && this.dictionary is IndexedDictionary<KeyT, ValueT>;
				this.usedKeys = isIndexed ? null : new HashSet<KeyT>();
			}

			/// <inheritdoc />
			public bool ContainsKey(KeyT key)
			{
				return this.dictionary.ContainsKey(this.MarkKeyUsed(key));
			}
			/// <inheritdoc />
			public bool TryGetValue(KeyT key, out ValueT value)
			{
				return this.dictionary.TryGetValue(this.MarkKeyUsed(key), out value);
			}

			/// <inheritdoc />
			public IEnumerator<KeyValuePair<KeyT, ValueT>> GetEnumerator()
			{
				return this.dictionary.GetEnumerator();
			}
			/// <inheritdoc />
			IEnumerator IEnumerable.GetEnumerator()
			{
				return ((IEnumerable)this.dictionary).GetEnumerator();
			}

			public IEnumerable<KeyValuePair<KeyT, ValueT>> EnumerateUntouched()
			{
				if (this.usedKeys != null)
				{
					foreach (var kv in this.dictionary)
					{
						if (this.usedKeys.Contains(kv.Key))
						{
							continue;
						}

						yield return kv;
					}
				}
				else
				{
					var indexedDictionary = ((IndexedDictionary<KeyT, ValueT>)this.dictionary);
					for (var index = 0; index < indexedDictionary.Count; index++)
					{
						if ((this.usedKeysIndexes & (1UL << index)) != 0)
						{
							continue;
						}

						var key = indexedDictionary.Keys[index];
						yield return new KeyValuePair<KeyT, ValueT>(key, indexedDictionary[key]);
					}
				}
			}

			private KeyT MarkKeyUsed(KeyT key)
			{
				if (this.usedKeys != null)
				{
					this.usedKeys.Add(key);
				}
				else
				{
					var index = ((IndexedDictionary<KeyT, ValueT>)this.dictionary).IndexOf(key);
					if (index >= 0)
					{
						this.usedKeysIndexes |= 1UL << index;
					}
				}

				return key;
			}

			/// <inheritdoc />
			public override string ToString()
			{
				return this.dictionary.ToString();
			}
		}
	}


	[Serializable]
	public class ReaderException : SerializationException
	{
		public int Code { get; set; }
		public int LineNumber { get; set; }
		public int ColumnNumber { get; set; }

		private ReaderException(string message, GameDataReader gameDataReader)
			: base(message)
		{
			if (message == null) throw new ArgumentNullException(nameof(message));

			if (gameDataReader != null)
				this.Update(gameDataReader);
		}

		protected ReaderException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			if (info == null) throw new ArgumentNullException(nameof(info));

			this.LineNumber = info.GetInt32("LineNumber");
			this.ColumnNumber = info.GetInt32("ColumnNumber");
		}

		private void Update(GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			this.LineNumber = gameDataReader.LineNumber;
			this.ColumnNumber = gameDataReader.ColumnNumber;
		}

		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null) throw new ArgumentNullException(nameof(info));

			info.AddValue("Code", this.Code);
			info.AddValue("LineNumber", this.LineNumber);
			info.AddValue("ColumnNumber", this.ColumnNumber);

			base.GetObjectData(info, context);
		}

		public static Exception UnexpectedEndOfStream(GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException("Unexpected end of stream.", gameDataReader);
		}
		public static Exception UnexpectedToken(GameDataReader gameDataReader, params ReaderToken[] expectedTokens)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));
			if (expectedTokens == null) throw new ArgumentNullException(nameof(expectedTokens));

			var tokensStr = default(string);
			if (expectedTokens.Length == 0)
			{
				tokensStr = "<no tokens>";
			}
			else
			{
				var tokens = Array.ConvertAll(expectedTokens, c => c.ToString());
				tokensStr = String.Join(", ", tokens);
			}

			return new ReaderException($"Expected one of there '{tokensStr}' but found '{gameDataReader.Node.Token}'({gameDataReader.Node.ValueType?.Name ?? "<null>"}).",
				gameDataReader);
		}
		public static Exception UnknownEscapeSequence(string escape, GameDataReader gameDataReader)
		{
			if (escape == null) throw new ArgumentNullException(nameof(escape));
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"An unknown escape sequence '{escape}'.", gameDataReader);
		}
		public static Exception UnterminatedStringLiteral(GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException("An unterminated string literal.", gameDataReader);
		}
		public static Exception UnknownNotation(GameDataReader gameDataReader, string notation)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"An unknown notation '{notation}'.", gameDataReader);
		}
		public static Exception StringLiteralIsTooLong(GameDataReader gameDataReader, int size, int maxSize)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"String literal is too long '{size}'. Maximum size is {maxSize}.", gameDataReader);
		}
		public static Exception BinaryDataIsTooLong(GameDataReader gameDataReader, int size, int maxSize)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"Binary data is too long '{size}'. Maximum size is {maxSize}.", gameDataReader);
		}
		public static Exception ReadingBrokenDocument(GameDataReader gameDataReader, string additionalInformation)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"Failed to continue deserialize because document's structure is invalid. Additional information: {additionalInformation}", gameDataReader);
		}
		public static Exception UnknownMessagePackType(string type, GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"An unknown Message Pack type '{type}'.", gameDataReader);
		}
		public static Exception UnexpectedNullValue(string expected, string propertyName, string schemaName, GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"A null value is deserialized instead of {expected} for required property '{propertyName}' in schema '{schemaName}'.",
				gameDataReader);
		}
	}


	public readonly struct ReaderNode
	{
		private readonly object value;

		public readonly ReaderToken Token;
		public readonly Type ValueType;

		public bool HasValue => this.ValueType != typeof(void);

		public ReaderNode(ReaderToken token)
		{
			this.Token = token;
			this.value = null;
			this.ValueType = typeof(void);
		}
		public ReaderNode(ReaderToken token, object value)
		{
			if (value == null) throw new ArgumentNullException(nameof(value));

			this.Token = token;
			this.value = value;
			this.ValueType = value is IStrongBox box ? box.ValueType : value.GetType();
		}

		public bool AsBoolean
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsBoolean;

				return Convert.ToBoolean(this.value, CultureInfo.InvariantCulture);
			}
		}
		public byte AsByte
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsByte;

				return Convert.ToByte(this.value, CultureInfo.InvariantCulture);
			}
		}
		public short AsInt16
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsInt16;

				return Convert.ToInt16(this.value, CultureInfo.InvariantCulture);
			}
		}
		public int AsInt32
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsInt32;

				return Convert.ToInt32(this.value, CultureInfo.InvariantCulture);
			}
		}
		public long AsInt64
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsInt64;

				return Convert.ToInt64(this.value, CultureInfo.InvariantCulture);
			}
		}
		public sbyte AsSByte
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsSByte;

				return Convert.ToSByte(this.value, CultureInfo.InvariantCulture);
			}
		}
		public ushort AsUInt16
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsUInt16;

				return Convert.ToUInt16(this.value, CultureInfo.InvariantCulture);
			}
		}
		public uint AsUInt32
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsUInt32;

				return Convert.ToUInt32(this.value, CultureInfo.InvariantCulture);
			}
		}
		public ulong AsUInt64
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsUInt64;

				return Convert.ToUInt64(this.value, CultureInfo.InvariantCulture);
			}
		}
		public float AsSingle
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsSingle;

				return Convert.ToSingle(this.value, CultureInfo.InvariantCulture);
			}
		}
		public double AsDouble
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDouble;

				return Convert.ToDouble(this.value, CultureInfo.InvariantCulture);
			}
		}
		public decimal AsDecimal
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDecimal;

				return Convert.ToDecimal(this.value, CultureInfo.InvariantCulture);
			}
		}
		public string AsString
		{
			get
			{
				var value = this.value;
				if (this.value is IStrongBox box) value = box.AsObject;
				return Convert.ToString(value, CultureInfo.InvariantCulture);
			}
		}
		public DateTime AsDateTime
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDateTime;

				var dateTimeStr = this.AsString;
				var date = DateTime.ParseExact(dateTimeStr, GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
				return date;
			}
		}
		public DateTimeOffset AsDateTimeOffset
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDateTime;

				var dateTimeStr = this.AsString;
				var date = DateTimeOffset.ParseExact(dateTimeStr, GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
				return date;
			}
		}
		public TimeSpan AsTimeSpan
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsTimeSpan;

				var timeSpanStr = this.AsString;
				var timeSpan = TimeSpan.Parse(timeSpanStr);
				return timeSpan;
			}
		}
		public object AsObject
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsObject;

				return this.value;
			}
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "{0}:{1}", this.Token, this.value);
		}
	}


	public enum ReaderToken
	{
		None = 0,
		BeginArray,
		EndOfArray,
		BeginObject,
		EndOfObject,
		Member,
		Null,
		Value,
		Comment,
		EndOfStream
	}


	public sealed class StringLookupTable
	{
		public const int MAX_STRING_SIZE = 8 * 8;

		private readonly StringSet[] table;

		public StringLookupTable(StringSet[] table)
		{
			if (table == null) throw new ArgumentNullException(nameof(table));

			this.table = table;
			Array.Resize(ref this.table, MAX_STRING_SIZE + 1);
		}

		public bool TryGetString(byte[] bytes, int offset, int count, out string value)
		{
			const int LAST_ASCII_CHARACTER = 0x7f;

			if (bytes == null)
			{
				throw new ArgumentNullException(nameof(bytes));
			}

			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
			if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
			if (offset + count > bytes.Length) throw new ArgumentOutOfRangeException(nameof(offset));

			if (count == 0)
			{
				value = string.Empty;
				return true;
			}

			value = null;
			if (count > MAX_STRING_SIZE || this.table[count] == null)
			{
				return false;
			}

			var end = offset + count;
			var octet = 0UL;
			for (var i = 0; offset + i < end; i++)
			{
				var character = bytes[offset + i];
				if (character > LAST_ASCII_CHARACTER)
				{
					return false;
				}

				if (i < 8)
				{
					octet = unchecked(octet | ((ulong)character << 8 * i));
				}
			}

			var set = this.table[count];
			var narrowOffset = 1;
			for (var i = 0; i < (count - 1) / 8; i++, narrowOffset++)
			{
				if (set == null || !set.TryNarrow(octet, out set))
				{
					return false;
				}

				octet = GetUInt64(bytes, offset + narrowOffset * 8, end);
			}

			return set != null && set.TryGetValue(octet, out value);
		}
		public bool TryGetString(char[] chars, int offset, int count, out string value)
		{
			const int LAST_ASCII_CHARACTER = 0x7f;

			if (chars == null)
			{
				throw new ArgumentNullException(nameof(chars));
			}

			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
			if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
			if (offset + count > chars.Length) throw new ArgumentOutOfRangeException(nameof(offset));

			if (count == 0)
			{
				value = string.Empty;
				return true;
			}

			value = null;
			if (count > MAX_STRING_SIZE || this.table[count] == null)
			{
				return false;
			}

			var end = offset + count;
			var octet = 0UL;
			for (var i = 0; offset + i < end; i++)
			{
				var character = chars[offset + i];
				if (character > LAST_ASCII_CHARACTER)
				{
					return false;
				}

				if (i < 8)
				{
					octet = unchecked(octet | ((ulong)character << 8 * i));
				}
			}

			var set = this.table[count];
			var narrowOffset = 1;
			for (var i = 0; i < (count - 1) / 8; i++, narrowOffset++)
			{
				if (set == null || !set.TryNarrow(octet, out set))
				{
					return false;
				}

				octet = GetUInt64(chars, offset + narrowOffset * 8, end);
			}

			return set != null && set.TryGetValue(octet, out value);
		}

		private static ulong GetUInt64(byte[] bytes, int offset, int end)
		{
			if (offset >= end)
			{
				return 0;
			}

			switch (end - offset)
			{
				case 1: return (ulong)bytes[offset];
				case 2:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1;
				case 3:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2;
				case 4:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3;
				case 5:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4;
				case 6:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4 |
						(ulong)bytes[offset + 5] << 8 * 5;
				case 7:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4 |
						(ulong)bytes[offset + 5] << 8 * 5 |
						(ulong)bytes[offset + 6] << 8 * 6;
				default:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4 |
						(ulong)bytes[offset + 5] << 8 * 5 |
						(ulong)bytes[offset + 6] << 8 * 6 |
						(ulong)bytes[offset + 7] << 8 * 7;
			}
		}
		private static ulong GetUInt64(char[] chars, int offset, int end)
		{
			if (offset >= end)
			{
				return 0;
			}

			switch (end - offset)
			{
				case 1: return (ulong)chars[offset];
				case 2:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1;
				case 3:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2;
				case 4:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3;
				case 5:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4;
				case 6:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4 |
						(ulong)chars[offset + 5] << 8 * 5;
				case 7:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4 |
						(ulong)chars[offset + 5] << 8 * 5 |
						(ulong)chars[offset + 6] << 8 * 6;
				default:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4 |
						(ulong)chars[offset + 5] << 8 * 5 |
						(ulong)chars[offset + 6] << 8 * 6 |
						(ulong)chars[offset + 7] << 8 * 7;
			}
		}
	}


	public sealed class StringSet
	{
		public static readonly Comparer<ulong> KeyComparer = Comparer<ulong>.Default;

		private readonly ulong[] keys;
		private readonly StringSet[] subSets;
		private readonly string[] values;

		public StringSet(ulong[] keys, StringSet[] subSets)
		{
			if (keys == null) throw new ArgumentNullException(nameof(keys));
			if (subSets == null) throw new ArgumentNullException(nameof(subSets));
			if (subSets.Length != keys.Length) throw new ArgumentException("invalid sets", nameof(keys));

			this.keys = keys;
			this.subSets = subSets;
		}
		public StringSet(ulong[] keys, string[] values)
		{
			if (keys == null) throw new ArgumentNullException(nameof(keys));
			if (values == null) throw new ArgumentNullException(nameof(values));
			if (values.Length != keys.Length) throw new ArgumentException("invalid sets", nameof(keys));

			this.keys = keys;
			this.values = values;
		}

		public bool TryNarrow(ulong octet, out StringSet value)
		{
			var subSetIndex = 0;
			switch (this.keys.Length)
			{
				case 1:
					subSetIndex = this.keys[0] == octet ? 0 : -1;
					break;
				case 2:
					subSetIndex = this.keys[0] == octet ? 0 : this.keys[1] == octet ? 1 : -1;
					break;
				case 3:
				case 4:
				case 5:
					subSetIndex = Array.IndexOf(this.keys, octet, 0, this.keys.Length);
					break;
				default:
					subSetIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, octet, KeyComparer);
					break;
			}

			if (subSetIndex < 0)
			{
				value = null;
				return false;
			}

			value = this.subSets[subSetIndex];
			return true;
		}
		public bool TryGetValue(ulong octet, out string value)
		{
			var valueIndex = 0;
			switch (this.keys.Length)
			{
				case 1:
					valueIndex = this.keys[0] == octet ? 0 : -1;
					break;
				case 2:
					valueIndex = this.keys[0] == octet ? 0 : this.keys[1] == octet ? 1 : -1;
					break;
				case 3:
				case 4:
				case 5:
					valueIndex = Array.IndexOf(this.keys, octet, 0, this.keys.Length);
					break;
				default:
					valueIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, octet, KeyComparer);
					break;
			}

			if (valueIndex < 0)
			{
				value = null;
				return false;
			}

			value = this.values[valueIndex];
			return value != null;
		}
	}


	public sealed class StrongBox<ValueT> : IStrongBox
	{
		private static readonly Type ValueType = typeof(ValueT);

		private readonly IFormatProvider formatProvider;

		public ValueT Value;

		public StrongBox(ValueT value, IFormatProvider formatProvider)
			: this(formatProvider)
		{
			this.Value = value;
		}
		public StrongBox(IFormatProvider formatProvider)
		{
			if (formatProvider == null) throw new ArgumentNullException(nameof(formatProvider));

			this.formatProvider = formatProvider;
		}

		Type IStrongBox.ValueType => ValueType;
		public bool AsBoolean => this.Value is bool asBoolean ? asBoolean : Convert.ToBoolean(this.Value, this.formatProvider);
		public byte AsByte => this.Value is byte asByte ? asByte :  Convert.ToByte(this.Value, this.formatProvider);
		public short AsInt16 => this.Value is short asInt16 ? asInt16 : Convert.ToInt16(this.Value, this.formatProvider);
		public int AsInt32 => this.Value is int asInt32 ? asInt32 : Convert.ToInt32(this.Value, this.formatProvider);
		public long AsInt64 => this.Value is long asInt64 ? asInt64 : Convert.ToInt64(this.Value, this.formatProvider);
		public sbyte AsSByte => this.Value is sbyte asSByte ? asSByte : Convert.ToSByte(this.Value, this.formatProvider);
		public ushort AsUInt16 => this.Value is ushort asUInt16 ? asUInt16 : Convert.ToUInt16(this.Value, this.formatProvider);
		public uint AsUInt32 => this.Value is uint asUInt32 ? asUInt32 : Convert.ToUInt32(this.Value, this.formatProvider);
		public ulong AsUInt64 => this.Value is ulong asUInt64 ? asUInt64 : Convert.ToUInt64(this.Value, this.formatProvider);
		public float AsSingle => this.Value is float asSingle ? asSingle : Convert.ToSingle(this.Value, this.formatProvider);
		public double AsDouble => this.Value is double asDouble ? asDouble : Convert.ToDouble(this.Value, this.formatProvider);
		public decimal AsDecimal => this.Value is decimal asDecimal ? asDecimal : Convert.ToDecimal(this.Value, this.formatProvider);
		public DateTime AsDateTime => this.Value is DateTime asDateTime ? asDateTime : Convert.ToDateTime(this.Value, this.formatProvider);
		public DateTimeOffset AsDateTimeOffset => this.Value is DateTimeOffset asDateTimeOffset ? asDateTimeOffset : new DateTimeOffset(Convert.ToDateTime(this.Value, this.formatProvider));
		public TimeSpan AsTimeSpan => this.Value is TimeSpan asTimeSpan ? asTimeSpan : TimeSpan.Parse(this.AsString ?? string.Empty, this.formatProvider);
		public string AsString => this.Value?.ToString();
		public object AsObject => this.Value;

		public void Store<T>(T value)
		{
			var type = typeof(T);
			if (type != ValueType)
			{
				throw new ArgumentException($"Unable to store value of type '{typeof(ValueT)}' in container of type '{type}'");
			}

			this.Value = (ValueT)(object)value;
		}

		public override string ToString()
		{
			return Convert.ToString(this.Value, this.formatProvider);
		}
	}

	}
}
// file path is Formulas.cs

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Globalization;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

#if !SUPPRESS_BUILD_IN_FORMULAS
	public static class Formulas
	{
	 

		private class ArrayTypeDescription : ReflectionTypeDescription, ITypeDescription
		{
			private readonly MemberGroup indexers;
			private readonly MemberGroup constructors;
	
			public ArrayTypeDescription(Type arrayType, FormulaOptions options) : base(arrayType, options)
			{
				if (arrayType == null) throw new ArgumentNullException(nameof(arrayType));
				if (!arrayType.IsArray) throw new ArgumentException("Array type is expected.", nameof(arrayType));
	
				this.constructors = CreateConstructors(arrayType);
				this.indexers = CreateIndexers(arrayType);
			}
	
			/// <inheritdoc />
			public override bool TryGetConstructors(out MemberGroup constructors)
			{
				constructors = this.constructors;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				if (rank == this.Type.GetArrayRank())
				{
					indexAccessor = this.indexers;
					return true;
				}
				else
				{
					indexAccessor = default;
					return false;
				}
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = default;
				return false;
			}
	
			private static MemberGroup CreateConstructors(Type arrayType)
			{
				if (arrayType == null) throw new ArgumentNullException(nameof(arrayType));
	
				var elementType = arrayType.GetElementType() ?? typeof(object);
				var rank = arrayType.GetArrayRank();
				var parameterDescriptors = new ParameterDescription[rank];
				for (var index = 0; index < rank; index++)
				{
					parameterDescriptors[index] = new ParameterDescription("rank" + rank, typeof(int), isRequired: true);
				}
	
				var rankConstructor = new MemberDescription((_, indexes) =>
				{
					switch (indexes.Length)
					{
						case 1: return new VariableValue(Array.CreateInstance(elementType, indexes[0].ToInt32()));
						case 2: return new VariableValue(Array.CreateInstance(elementType, indexes[0].ToInt32(), indexes[1].ToInt32()));
						case 3: return new VariableValue(Array.CreateInstance(elementType, indexes[0].ToInt32(), indexes[1].ToInt32(), indexes[2].ToInt32()));
						default: return new VariableValue(Array.CreateInstance(elementType, Array.ConvertAll(indexes, value => value.ToInt32())));
					}
				}, arrayType, parameterDescriptors);
	
				return new MemberGroup(MemberGroupType.Constructor, new[] { rankConstructor });
			}
			private static MemberGroup CreateIndexers(Type arrayType)
			{
				if (arrayType == null) throw new ArgumentNullException(nameof(arrayType));
	
				var rank = arrayType.GetArrayRank();
				var elementType = arrayType.GetElementType() ?? typeof(object);
				var parameterDescriptors = new ParameterDescription[rank];
				for (var index = 0; index < rank; index++)
				{
					parameterDescriptors[index] = new ParameterDescription("rank" + rank, typeof(int), isRequired: true);
				}
	
				var indexMethod = new MemberDescription((target, indexes) =>
				{
					
					var array = (Array)target.ToObject();
					switch (indexes.Length)
					{
						case 1: return new VariableValue(array.GetValue(indexes[0].ToInt32()));
						case 2: return new VariableValue(array.GetValue(indexes[0].ToInt32(), indexes[1].ToInt32()));
						case 3: return new VariableValue(array.GetValue(indexes[0].ToInt32(), indexes[1].ToInt32(), indexes[2].ToInt32()));
						default: return new VariableValue(array.GetValue(Array.ConvertAll(indexes, value => value.ToInt32())));
					}
				}, elementType, parameterDescriptors);
				return new MemberGroup(MemberGroupType.Method, new[] { indexMethod });
			}
		}
	

		private sealed class BinaryExpression : FormulaExpression
		{
			private readonly FormulaExpression left;
			private readonly FormulaExpression right;
			private readonly BinaryOperationType binaryOperationType;
			private readonly BinaryOperationType fallbackBinaryOperationType;
	
			public BinaryExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.left = ExpressionBuildHelper.GetExpression(expressionObj, ExpressionConstants.LEFT_ATTRIBUTE);
				this.right = ExpressionBuildHelper.GetExpression(expressionObj, ExpressionConstants.RIGHT_ATTRIBUTE);
	
				var expressionType = ExpressionBuildHelper.GetString(expressionObj, ExpressionConstants.EXPRESSION_TYPE_ATTRIBUTE);
				this.binaryOperationType = MapToBinaryOperationType(expressionType);
	
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (this.binaryOperationType)
				{
					case BinaryOperationType.AddChecked: this.fallbackBinaryOperationType = BinaryOperationType.Add; break;
					case BinaryOperationType.SubtractChecked: this.fallbackBinaryOperationType = BinaryOperationType.Subtract; break;
					case BinaryOperationType.DivideChecked: this.fallbackBinaryOperationType = BinaryOperationType.Divide; break;
					case BinaryOperationType.MultiplyChecked: this.fallbackBinaryOperationType = BinaryOperationType.Multiply; break;
					default: this.fallbackBinaryOperationType = this.binaryOperationType; break;
				}
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				if (this.binaryOperationType == BinaryOperationType.Coalesce)
				{
					return this.ExecuteCoalesce(context);
				}
				else if (this.binaryOperationType == BinaryOperationType.AndAlso ||
						this.binaryOperationType == BinaryOperationType.OrElse)
				{
					return this.ExecuteJunction(context);
				}
				else if (this.binaryOperationType == BinaryOperationType.Power)
				{
					return this.ExecutePower(context);
				}
	
				var leftValue = this.left.Execute(context);
				var rightValue = this.right.Execute(context);
				if (leftValue.IsNull || rightValue.IsNull)
				{
					if (leftValue.TypeCode == TypeCode.Boolean || rightValue.TypeCode == TypeCode.Boolean)
					{
						return this.ExecuteNullLiftedBoolean(leftValue, rightValue);
					}
					else
					{
						return this.ExecuteNullLifted(leftValue, rightValue);
					}
				}
	
				if (!TryPromoteOperands(ref leftValue, ref rightValue, this.binaryOperationType))
				{
					throw FormulaException.MissingBinaryOperation(this.binaryOperationType, leftValue, rightValue);
				}
	
				var arguments = new Dictionary<string, VariableValue> {
					{ "0", leftValue },
					{ "1", rightValue },
				};
				var leftValueType = context.TypeResolver.GetTypeDescription(leftValue.Type);
				if (leftValueType.TryGetBinaryOperation(this.binaryOperationType, out var binaryOperation) &&
					binaryOperation.TryInvoke(VariableValue.Null, arguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
				else if (this.fallbackBinaryOperationType != this.binaryOperationType &&  // try to perform fallback binary operation
							leftValueType.TryGetBinaryOperation(this.fallbackBinaryOperationType, out binaryOperation) &&
							binaryOperation.TryInvoke(VariableValue.Null, arguments, expectedType: null, typeArguments: null, out result))
				{
					return result;
				}
				throw FormulaException.MissingBinaryOperation(this.binaryOperationType, leftValue, rightValue);
			}
	
			private VariableValue ExecuteNullLiftedBoolean(VariableValue leftValue, VariableValue rightValue)
			{
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (this.binaryOperationType)
				{
					case BinaryOperationType.And:
						if (rightValue.IsNull && leftValue.IsNull)
						{
							return VariableValue.Null;
						}
						else if (rightValue.IsNull)
						{
							return leftValue.ToBoolean() ? VariableValue.Null : false;
						}
						else
						{
							return rightValue.ToBoolean() ? VariableValue.Null : false;
	
						}
					case BinaryOperationType.Or:
						if (rightValue.IsNull && leftValue.IsNull)
						{
							return VariableValue.Null;
						}
						else if (rightValue.IsNull)
						{
							return leftValue.ToBoolean() ? true : VariableValue.Null;
						}
						else
						{
							return rightValue.ToBoolean() ? true : VariableValue.Null;
	
						}
					default: return this.ExecuteNullLifted(leftValue, rightValue);
				}
			}
			private VariableValue ExecuteNullLifted(VariableValue leftValue, VariableValue rightValue)
			{
				switch (this.binaryOperationType)
				{
					case BinaryOperationType.And:
					case BinaryOperationType.Or:
					case BinaryOperationType.ExclusiveOr:
					case BinaryOperationType.Multiply:
					case BinaryOperationType.MultiplyChecked:
					case BinaryOperationType.Divide:
					case BinaryOperationType.DivideChecked:
					case BinaryOperationType.Power:
					case BinaryOperationType.Modulo:
					case BinaryOperationType.Add:
					case BinaryOperationType.AddChecked:
					case BinaryOperationType.Subtract:
					case BinaryOperationType.SubtractChecked:
					case BinaryOperationType.LeftShift:
					case BinaryOperationType.RightShift:
						return VariableValue.Null;
					case BinaryOperationType.GreaterThan:
					case BinaryOperationType.GreaterThanOrEqual:
					case BinaryOperationType.LessThan:
					case BinaryOperationType.LessThanOrEqual:
						return false;
					case BinaryOperationType.Equal:
						return leftValue.IsNull == rightValue.IsNull;
					case BinaryOperationType.NotEqual:
						return leftValue.IsNull != rightValue.IsNull;
					case BinaryOperationType.AndAlso:
					case BinaryOperationType.OrElse:
					case BinaryOperationType.Coalesce:
					default: throw FormulaException.UnknownBinaryExpression(this.binaryOperationType.ToString());
				}
			}
			private VariableValue ExecutePower(FormulaExecutionContext context)
			{
				var leftValue = this.left.Execute(context);
				var rightValue = this.right.Execute(context);
				if (leftValue.IsNull || rightValue.IsNull)
				{
					return VariableValue.Null;
				}
				return Math.Pow(leftValue.ToDouble(), rightValue.ToDouble());
			}
			private VariableValue ExecuteJunction(FormulaExecutionContext context)
			{
				var junctionOperator = this.binaryOperationType == BinaryOperationType.AndAlso ? "&&" : "||";
				var leftValue = this.left.Execute(context);
				if (leftValue.Type != typeof(bool))
				{
					return FormulaException.WrongJunctionOperands(junctionOperator, leftValue, new VariableValue(false));
				}
	
				if (this.binaryOperationType == BinaryOperationType.AndAlso && !leftValue.ToBoolean())
				{
					return new VariableValue(false); // shortcut
				}
				else if (this.binaryOperationType == BinaryOperationType.OrElse && leftValue.ToBoolean())
				{
					return new VariableValue(true); // shortcut
				}
	
				var rightValue = this.right.Execute(context);
				if (rightValue.Type != typeof(bool))
				{
					return FormulaException.WrongJunctionOperands(junctionOperator, leftValue, rightValue);
				}
	
				return this.binaryOperationType == BinaryOperationType.AndAlso ? leftValue.ToBoolean() && rightValue.ToBoolean() : leftValue.ToBoolean() || rightValue.ToBoolean();
			}
			private VariableValue ExecuteCoalesce(FormulaExecutionContext context)
			{
				var leftValue = this.left.Execute(context);
				if (!leftValue.IsNull)
				{
					return leftValue;
				}
				var rightValue = this.right.Execute(context);
				return leftValue.IsNull ? rightValue : leftValue;
			}
	
			private static bool TryPromoteOperands(ref VariableValue leftValue, ref VariableValue rightValue, BinaryOperationType operationType)
			{
				var leftIsEnum = leftValue.Type.IsEnum;
				var leftTypeCode = leftValue.TypeCode;
				var leftIsInteger = leftTypeCode >= TypeCode.SByte && leftTypeCode <= TypeCode.UInt64;
				var leftIsNumber = TypeCodes.IsNumberLike(leftTypeCode);
				var leftIsString = leftTypeCode == TypeCode.String;
				var rightIsEnum = rightValue.Type.IsEnum;
				var rightTypeCode = rightValue.TypeCode;
				var rightIsInteger = rightTypeCode >= TypeCode.SByte && rightTypeCode <= TypeCode.UInt64;
				var rightIString = rightTypeCode == TypeCode.String;
				var rightIsNumber = TypeCodes.IsNumberLike(rightTypeCode);
				var isNumberPromotableOperation = operationType != BinaryOperationType.RightShift && operationType != BinaryOperationType.LeftShift;
	
				if (leftIsEnum && rightIsEnum)
				{
					return leftTypeCode == rightTypeCode;
				}
				else if (leftIsEnum && rightIsInteger)
				{
					if (!rightValue.CanFitInto(leftTypeCode))
					{
						return false;
					}
					rightValue = VariableValue.FromEnum(leftValue.Type, rightValue.ToInt64(uncheckedConversion: true));
				}
				else if (leftIsInteger && rightIsEnum)
				{
					if (!leftValue.CanFitInto(rightTypeCode))
					{
						return false;
					}
					leftValue = VariableValue.FromEnum(rightValue.Type, leftValue.ToInt64(uncheckedConversion: true));
				}
				else if (leftIsNumber && rightIsNumber && isNumberPromotableOperation)
				{
					if (leftTypeCode == TypeCode.Decimal || rightTypeCode == TypeCode.Decimal)
					{
						if (leftTypeCode == TypeCode.Double || leftTypeCode == TypeCode.Single || rightTypeCode == TypeCode.Double || rightTypeCode == TypeCode.Single)
						{
							return false; // will throw exception
						}
	
						if (leftTypeCode == TypeCode.Decimal)
							rightValue = rightValue.ToDecimal();
						else
							leftValue = leftValue.ToDecimal();
					}
					else if (leftTypeCode == TypeCode.Double || rightTypeCode == TypeCode.Double)
					{
						if (leftTypeCode == TypeCode.Double)
							rightValue = rightValue.ToDouble();
						else
							leftValue = leftValue.ToDouble();
					}
					else if (leftTypeCode == TypeCode.Single || rightTypeCode == TypeCode.Single)
					{
						if (leftTypeCode == TypeCode.Single)
							rightValue = rightValue.ToSingle();
						else
							leftValue = leftValue.ToSingle();
					}
					else if (leftTypeCode == TypeCode.UInt64)
					{
						if (TypeCodes.IsSignedInteger(rightTypeCode) &&
							!rightValue.CanFitInto(leftTypeCode))
						{
							return false; // will throw exception
						}
						rightValue = rightValue.ToUInt64();
					}
					else if (rightTypeCode == TypeCode.UInt64)
					{
						if (TypeCodes.IsSignedInteger(leftTypeCode) &&
							!rightValue.CanFitInto(leftTypeCode))
						{
							return false; // will throw exception
						}
						leftValue = leftValue.ToUInt64();
					}
					else if (leftTypeCode == TypeCode.Int64 || rightTypeCode == TypeCode.Int64)
					{
						if (leftTypeCode == TypeCode.Int64)
							rightValue = rightValue.ToInt64();
						else
							leftValue = leftValue.ToInt64();
					}
					else if ((leftTypeCode == TypeCode.UInt32 && TypeCodes.IsSignedInteger(rightTypeCode)) ||
						(rightTypeCode == TypeCode.UInt32 && TypeCodes.IsSignedInteger(leftTypeCode)))
					{
						rightValue = rightValue.ToInt64();
						leftValue = leftValue.ToInt64();
					}
					else if (leftTypeCode == TypeCode.UInt32 || rightTypeCode == TypeCode.UInt32)
					{
						if (leftTypeCode == TypeCode.UInt32)
							rightValue = rightValue.ToUInt32();
						else
							leftValue = leftValue.ToUInt32();
					}
					else
					{
						rightValue = rightValue.ToInt32();
						leftValue = leftValue.ToInt32();
					}
				}
				else if ((leftIsString || rightIString) && (operationType == BinaryOperationType.Add || operationType == BinaryOperationType.AddChecked))
				{
					if (!leftIsString)
					{
						leftValue = leftValue.ToString();
					}
					if (!rightIString)
					{
						rightValue = rightValue.ToString();
					}
				}
	
				return true;
			}
	
			private static BinaryOperationType MapToBinaryOperationType(string expressionType)
			{
				BinaryOperationType binaryOperationType;
				switch (expressionType)
				{
					case ExpressionConstants.EXPRESSION_TYPE_DIVIDE_CHECKED: binaryOperationType = BinaryOperationType.DivideChecked; break;
					case ExpressionConstants.EXPRESSION_TYPE_DIVIDE: binaryOperationType = BinaryOperationType.Divide; break;
					case ExpressionConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED: binaryOperationType = BinaryOperationType.MultiplyChecked; break;
					case ExpressionConstants.EXPRESSION_TYPE_MULTIPLY: binaryOperationType = BinaryOperationType.Multiply; break;
					case ExpressionConstants.EXPRESSION_TYPE_MODULO: binaryOperationType = BinaryOperationType.Modulo; break;
					case ExpressionConstants.EXPRESSION_TYPE_ADD_CHECKED: binaryOperationType = BinaryOperationType.AddChecked; break;
					case ExpressionConstants.EXPRESSION_TYPE_ADD: binaryOperationType = BinaryOperationType.Add; break;
					case ExpressionConstants.EXPRESSION_TYPE_POWER: binaryOperationType = BinaryOperationType.Power; break;
					case ExpressionConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED: binaryOperationType = BinaryOperationType.SubtractChecked; break;
					case ExpressionConstants.EXPRESSION_TYPE_SUBTRACT: binaryOperationType = BinaryOperationType.Subtract; break;
					case ExpressionConstants.EXPRESSION_TYPE_LEFT_SHIFT: binaryOperationType = BinaryOperationType.LeftShift; break;
					case ExpressionConstants.EXPRESSION_TYPE_RIGHT_SHIFT: binaryOperationType = BinaryOperationType.RightShift; break;
					case ExpressionConstants.EXPRESSION_TYPE_GREATER_THAN: binaryOperationType = BinaryOperationType.GreaterThan; break;
					case ExpressionConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL: binaryOperationType = BinaryOperationType.GreaterThanOrEqual; break;
					case ExpressionConstants.EXPRESSION_TYPE_LESS_THAN: binaryOperationType = BinaryOperationType.LessThan; break;
					case ExpressionConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL: binaryOperationType = BinaryOperationType.LessThanOrEqual; break;
					case ExpressionConstants.EXPRESSION_TYPE_EQUAL: binaryOperationType = BinaryOperationType.Equal; break;
					case ExpressionConstants.EXPRESSION_TYPE_NOT_EQUAL: binaryOperationType = BinaryOperationType.NotEqual; break;
					case ExpressionConstants.EXPRESSION_TYPE_AND: binaryOperationType = BinaryOperationType.And; break;
					case ExpressionConstants.EXPRESSION_TYPE_OR: binaryOperationType = BinaryOperationType.Or; break;
					case ExpressionConstants.EXPRESSION_TYPE_EXCLUSIVE_OR: binaryOperationType = BinaryOperationType.ExclusiveOr; break;
					case ExpressionConstants.EXPRESSION_TYPE_AND_ALSO: binaryOperationType = BinaryOperationType.AndAlso; break;
					case ExpressionConstants.EXPRESSION_TYPE_OR_ELSE: binaryOperationType = BinaryOperationType.OrElse; break;
					case ExpressionConstants.EXPRESSION_TYPE_COALESCE: binaryOperationType = BinaryOperationType.Coalesce; break;
					default: throw FormulaException.UnknownBinaryExpression(expressionType);
				}
				return binaryOperationType;
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				if (!(this.left is ConstantExpression))
				{
					stringBuilder.Append("(");
				}
				this.left.BuildDebugView(stringBuilder);
				if (!(this.left is ConstantExpression))
				{
					stringBuilder.Append(")");
				}
	
				stringBuilder.Append(" ");
				switch (this.binaryOperationType)
				{
					case BinaryOperationType.And: stringBuilder.Append("&"); break;
					case BinaryOperationType.Or: stringBuilder.Append("|"); break;
					case BinaryOperationType.ExclusiveOr: stringBuilder.Append("^"); break;
					case BinaryOperationType.Multiply: stringBuilder.Append("*"); break;
					case BinaryOperationType.MultiplyChecked: stringBuilder.Append("*"); break;
					case BinaryOperationType.Divide: stringBuilder.Append("/"); break;
					case BinaryOperationType.DivideChecked: stringBuilder.Append("/"); break;
					case BinaryOperationType.Power: stringBuilder.Append("**"); break;
					case BinaryOperationType.Modulo: stringBuilder.Append("%"); break;
					case BinaryOperationType.Add: stringBuilder.Append("+"); break;
					case BinaryOperationType.AddChecked: stringBuilder.Append("+"); break;
					case BinaryOperationType.Subtract: stringBuilder.Append("-"); break;
					case BinaryOperationType.SubtractChecked: stringBuilder.Append("-"); break;
					case BinaryOperationType.LeftShift: stringBuilder.Append("<<"); break;
					case BinaryOperationType.RightShift: stringBuilder.Append(">>"); break;
					case BinaryOperationType.GreaterThan: stringBuilder.Append(">"); break;
					case BinaryOperationType.GreaterThanOrEqual: stringBuilder.Append(">="); break;
					case BinaryOperationType.LessThan: stringBuilder.Append("<"); break;
					case BinaryOperationType.LessThanOrEqual: stringBuilder.Append("<="); break;
					case BinaryOperationType.Equal: stringBuilder.Append("=="); break;
					case BinaryOperationType.NotEqual: stringBuilder.Append("!="); break;
					case BinaryOperationType.AndAlso: stringBuilder.Append("&&"); break;
					case BinaryOperationType.OrElse: stringBuilder.Append("||"); break;
					case BinaryOperationType.Coalesce: stringBuilder.Append("??"); break;
					default: stringBuilder.Append(this.binaryOperationType); break;
				}
				stringBuilder.Append(" ");
	
				if (!(this.right is ConstantExpression))
				{
					stringBuilder.Append("(");
				}
				this.right.BuildDebugView(stringBuilder);
				if (!(this.right is ConstantExpression))
				{
					stringBuilder.Append(")");
				}
			}
		}
	

		public enum BinaryOperationType
		{
			And,
			Or,
			ExclusiveOr,
			Multiply,
			MultiplyChecked,
			Divide,
			DivideChecked,
			Power,
			Modulo,
			Add,
			AddChecked,
			Subtract,
			SubtractChecked,
			LeftShift,
			RightShift,
			GreaterThan,
			GreaterThanOrEqual,
			LessThan,
			LessThanOrEqual,
			Equal,
			NotEqual,
			AndAlso,
			OrElse,
			Coalesce
		}
	

		private sealed class BooleanTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
	
			static BooleanTypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<bool>((_, arguments) => (arguments[0].ToBoolean() & arguments[1].ToBoolean()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<bool>((_, arguments) => (arguments[0].ToBoolean() | arguments[1].ToBoolean()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<bool>((_, arguments) => (arguments[0].ToBoolean() ^ arguments[1].ToBoolean()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToBoolean() == arguments[1].ToBoolean()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToBoolean() != arguments[1].ToBoolean()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.Not] = CreateUnaryOperation<bool>((_, arguments) => (bool)unchecked(!arguments[0].ToBoolean()));
			}
			/// <inheritdoc />
			public BooleanTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Boolean), isRequired: true),
								new ParameterDescription("value2", typeof(Boolean), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Boolean), isRequired: true)
							})
					});
			}
	
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class CharTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static CharTypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToChar() & arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToChar() | arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToChar() ^ arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToChar() * arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() * arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToChar() / arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() / arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToChar(), arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToChar() % arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToChar() + arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() + arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToChar() - arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() - arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() > arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() >= arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() < arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() <= arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() == arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() != arguments[1].ToChar()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToChar()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToChar()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToChar()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToChar()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToChar())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToChar())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToChar())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToChar())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToChar())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToChar())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToChar())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToChar())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToChar())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToChar())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToChar())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToChar())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToChar(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public CharTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Char), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(Char), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Char), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(Char), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class ConditionExpression : FormulaExpression
		{
			private readonly FormulaExpression test;
			private readonly FormulaExpression ifTrue;
			private readonly FormulaExpression ifFalse;
	
			public ConditionExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.test = ExpressionBuildHelper.GetExpression(expressionObj, ExpressionConstants.TEST_ATTRIBUTE);
				this.ifTrue = ExpressionBuildHelper.GetExpression(expressionObj, ExpressionConstants.IF_TRUE_ATTRIBUTE);
				this.ifFalse = ExpressionBuildHelper.GetExpression(expressionObj, ExpressionConstants.IF_FALSE_ATTRIBUTE);
			}
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var testValue = this.test.Execute(context);
				if (testValue.Type != typeof(bool))
				{
					throw FormulaException.InvalidConditionResultType(testValue);
				}
	
				return testValue.ToBoolean() ? this.ifTrue.Execute(context) : this.ifFalse.Execute(context);
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("(");
				this.test.BuildDebugView(stringBuilder);
				stringBuilder.Append(")");
				stringBuilder.Append(" ? ");
				if (!(this.ifTrue is ConstantExpression))
				{
					stringBuilder.Append("(");
				}
				this.ifTrue.BuildDebugView(stringBuilder);
				if (!(this.ifTrue is ConstantExpression))
				{
					stringBuilder.Append(")");
				}
				stringBuilder.Append(" : ");
				if (!(this.ifFalse is ConstantExpression))
				{
					stringBuilder.Append("(");
				}
				this.ifFalse.BuildDebugView(stringBuilder);
				if (!(this.ifFalse is ConstantExpression))
				{
					stringBuilder.Append(")");
				}
			}
		}
	

		private sealed class ConstantExpression : FormulaExpression
		{
			private readonly object value;
			private readonly TypeReference type;
	
			public ConstantExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.value = ExpressionBuildHelper.GetAnyValue(expressionObj, ExpressionConstants.VALUE_ATTRIBUTE, optional: true);
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, ExpressionConstants.TYPE_ATTRIBUTE);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				if (this.value == null)
				{
					return VariableValue.Null;
				}
	
				switch (this.type.ToString())
				{
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_CHAR: return (Convert.ToString(this.value, CultureInfo.InvariantCulture) ?? string.Empty).FirstOrDefault();
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_BOOL: return Convert.ToBoolean(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_BYTE: return Convert.ToByte(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_SBYTE: return Convert.ToSByte(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_INT16: return Convert.ToInt16(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_UINT16: return Convert.ToUInt16(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_INT32: return Convert.ToInt32(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_UINT32: return Convert.ToUInt32(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_INT64: return Convert.ToInt64(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_UINT64: return Convert.ToUInt64(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_DOUBLE: return Convert.ToDouble(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_SINGLE: return Convert.ToSingle(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_DECIMAL: return Convert.ToDecimal(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_DATE_TIME: return Convert.ToDateTime(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_TIME_SPAN: return VariableValue.ToTimeSpan(this.value, CultureInfo.InvariantCulture);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_TYPE:
						var typeReference = default(TypeReference);
						if (this.value is IReadOnlyDictionary<string, object> expression)
						{
							typeReference = new TypeReference(expression);
						}
						else
						{
							var typeName = new VariableValue(this.value).ToString();
							typeReference = new TypeReference(typeName, Array.Empty<TypeReference>(), null);
						}
						var type = context.TypeResolver.GetTypeDescription(typeReference).Type;
						return new VariableValue(type);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_STRING: return new VariableValue(new VariableValue(this.value).ToString());
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_OBJECT:
					default: return new VariableValue(this.value);
				}
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				if (this.value == null)
				{
					stringBuilder.Append("null");
				}
				else if (this.value is string || this.value is DateTime || this.value is TimeSpan)
				{
					stringBuilder.Append("\"").Append(this.value).Append("\"");
				}
				else
				{
					stringBuilder.Append(this.value);
				}
			}
		}
	

		private sealed class ConvertExpression : FormulaExpression
		{
			private readonly TypeReference type;
			private readonly FormulaExpression expression;
			private readonly string expressionType;
	
			public ConvertExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.expressionType = ExpressionBuildHelper.GetString(expressionObj, ExpressionConstants.EXPRESSION_TYPE_ATTRIBUTE, optional: false);
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, ExpressionConstants.TYPE_ATTRIBUTE, optional: false);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, ExpressionConstants.EXPRESSION_ATTRIBUTE, optional: false);
			}
			public ConvertExpression(FormulaExpression expression, Type type, bool checkedScope = true)
			{
				this.expressionType = checkedScope ? ExpressionConstants.EXPRESSION_TYPE_CONVERT_CHECKED : ExpressionConstants.EXPRESSION_TYPE_CONVERT;
				this.expression = expression;
				this.type = new TypeReference(type);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var value = this.expression.Execute(context);
				var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(this.type);
	
				if (value.IsNull)
				{
					if (targetTypeDescriptor.CanBeNull)
					{
						return VariableValue.Null;
					}
					else
					{
						throw FormulaException.CanConvertNullToType(value, targetTypeDescriptor);
					}
				}
	
				if (value.Type == typeof(UnboundLambda) &&
					typeof(Delegate).IsAssignableFrom(targetTypeDescriptor.Type))
				{
					return this.ExecuteLambdaBinding(targetTypeDescriptor, (UnboundLambda)value.ToObject());
				}
				if (this.expressionType == ExpressionConstants.EXPRESSION_TYPE_TYPE_AS)
				{
					return ExecuteTypeAs(targetTypeDescriptor, value);
				}
				else
				{
					return this.ExecuteConvert(context, value, targetTypeDescriptor);
				}
	
			}
			private VariableValue ExecuteConvert(FormulaExecutionContext context, VariableValue value, ITypeDescription targetTypeDescription)
			{
				var valueTypeDescriptor = context.TypeResolver.GetTypeDescription(value.Type);
				var targetValueType = targetTypeDescription.Type;
	
				if (targetValueType.IsAssignableFrom(value.Type))
				{
					return value;
				}
	
				var arguments = new Dictionary<string, VariableValue> {
					{ "0", value }
				};
	
				// try checked conversion
				if (this.expressionType == ExpressionConstants.EXPRESSION_TYPE_CONVERT_CHECKED &&
					(valueTypeDescriptor.TryGetCheckedConversionOperation(out var conversionOperation) ||
					targetTypeDescription.TryGetCheckedConversionOperation(out conversionOperation)) &&
					conversionOperation.TryInvoke(VariableValue.Null, arguments, targetValueType, typeArguments: null, out var result))
				{
	
					return result;
				}
	
				// try fallback/checked conversion
				if ((valueTypeDescriptor.TryGetConversionOperation(out conversionOperation) ||
					targetTypeDescription.TryGetConversionOperation(out conversionOperation)) &&
					conversionOperation.TryInvoke(VariableValue.Null, arguments, targetValueType, typeArguments: null, out result))
				{
					return result;
				}
	
				throw FormulaException.CanConvertToType(value, targetTypeDescription);
			}
			private VariableValue ExecuteLambdaBinding(ITypeDescription delegateTypeDescription, UnboundLambda unboundLambda)
			{
				if (delegateTypeDescription == null) throw new ArgumentNullException(nameof(delegateTypeDescription));
				if (unboundLambda == null) throw new ArgumentNullException(nameof(unboundLambda));
	
				if (!unboundLambda.IsSignatureMatching(delegateTypeDescription.Type))
				{
					throw FormulaException.CanConvertToType(new VariableValue(unboundLambda), delegateTypeDescription);
				}
	
				var boundLambda = unboundLambda.BindTo(delegateTypeDescription.Type);
				return new VariableValue(boundLambda);
			}
			private static VariableValue ExecuteTypeAs(ITypeDescription targetTypeDescription, VariableValue value)
			{
				if (targetTypeDescription.Type.IsAssignableFrom(value.Type))
				{
					return value;
				}
				else
				{
					return VariableValue.Null;
				}
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				if (this.expressionType == ExpressionConstants.EXPRESSION_TYPE_TYPE_AS)
				{
					this.expression.BuildDebugView(stringBuilder);
					stringBuilder.Append(" as ");
					stringBuilder.Append(this.type);
				}
				else
				{
					stringBuilder.Append("(");
					stringBuilder.Append(this.type);
					stringBuilder.Append(") ");
					this.expression.BuildDebugView(stringBuilder);
				}
			}
		}
	

		private sealed class CSharpNameUtils
		{
			private static readonly Dictionary<Type, string> AliasByTypeName;
	
			static CSharpNameUtils()
			{
				var typeNameByAlias = new Dictionary<string, Type>
				{
					// ReSharper disable StringLiteralTypo
					{ "void", typeof(void) },
					{ "char", typeof(char) },
					{ "bool", typeof(bool) },
					{ "byte", typeof(byte) },
					{ "sbyte", typeof(sbyte) },
					{ "decimal", typeof(decimal) },
					{ "double", typeof(double) },
					{ "float", typeof(float) },
					{ "int", typeof(int) },
					{ "uint", typeof(uint) },
					{ "long", typeof(long) },
					{ "ulong", typeof(ulong) },
					{ "object", typeof(object) },
					{ "short", typeof(short) },
					{ "ushort", typeof(ushort) },
					{ "string", typeof(string) }
	
					// ReSharper restore StringLiteralTypo
				};
				AliasByTypeName = typeNameByAlias.ToDictionary(kv => kv.Value, kv => kv.Key);
			}
	
			[Flags]
			private enum TypeNameFormatOptions
			{
				None,
				// ReSharper disable once ShiftExpressionRealShiftCountIsZero
				IncludeDeclaringType = 0x1 << 0,
				IncludeNamespace = 0x1 << 1 | IncludeDeclaringType,
				IncludeGenericArguments = 0x1 << 2,
				IncludeGenericSuffix = 0x1 << 3,
			}
	
			public static KeyValuePair<string, string> GetTypeNames(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				var name = type.Name;
				if (string.IsNullOrEmpty(name))
				{
					return new KeyValuePair<string, string>(null, null);
				}
	
				if (type == typeof(Array))
				{
					return new KeyValuePair<string, string>(name, name + "`1");
				}
				else if (type.IsGenericType)
				{
					return new KeyValuePair<string, string>(
						GetCSharpName(type, options: TypeNameFormatOptions.None).ToString(),
						GetCSharpName(type, options: TypeNameFormatOptions.IncludeGenericSuffix).ToString());
				}
				else if (AliasByTypeName.TryGetValue(type, out var alias))
				{
					return new KeyValuePair<string, string>(alias, GetCSharpName(type).ToString());
				}
				else
				{
					return new KeyValuePair<string, string>(GetCSharpName(type).ToString(), null);
				}
			}
			public static KeyValuePair<string, string> GetTypeFullNames(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				var fullName = type.FullName;
				if (string.IsNullOrEmpty(fullName))
				{
					return new KeyValuePair<string, string>(null, null);
				}
	
				if (type == typeof(Array))
				{
					return new KeyValuePair<string, string>(fullName, fullName + "`1");
				}
				else if (type.IsGenericType)
				{
					return new KeyValuePair<string, string>(GetCSharpFullName(type, options: TypeNameFormatOptions.None).ToString(),
						GetCSharpFullName(type, options: TypeNameFormatOptions.IncludeGenericSuffix).ToString());
				}
				else
				{
					return new KeyValuePair<string, string>(GetCSharpFullName(type).ToString(), null);
				}
			}
	
			public static string GetCSharpFullNameWithGenerics(Type type)
			{
				return GetCSharpFullName(type, new StringBuilder(), TypeNameFormatOptions.IncludeGenericArguments).ToString();
			}
	
			private static StringBuilder GetCSharpFullName(Type type, StringBuilder builder = null, TypeNameFormatOptions options = TypeNameFormatOptions.IncludeGenericSuffix)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				if (builder == null)
				{
					builder = new StringBuilder();
				}
	
				var nameStartIndex = builder.Length;
				WriteName(type, builder, options | TypeNameFormatOptions.IncludeNamespace);
	
				if ((options & TypeNameFormatOptions.IncludeGenericSuffix) == 0)
				{
					RemoveGenericSuffix(builder, nameStartIndex, builder.Length - nameStartIndex);
				}
	
				return builder;
			}
			private static StringBuilder GetCSharpName(Type type, StringBuilder builder = null, TypeNameFormatOptions options = TypeNameFormatOptions.IncludeGenericSuffix)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				if (builder == null)
				{
					builder = new StringBuilder();
				}
	
				var nameStartIndex = builder.Length;
				WriteName(type, builder, options & ~TypeNameFormatOptions.IncludeNamespace | TypeNameFormatOptions.IncludeDeclaringType);
	
				if ((options & TypeNameFormatOptions.IncludeGenericSuffix) == 0)
				{
					return RemoveGenericSuffix(builder, nameStartIndex, builder.Length - nameStartIndex);
				}
	
				return builder;
			}
	
			private static StringBuilder RemoveGenericSuffix(StringBuilder builder, int startIndex, int count)
			{
				if (builder == null) throw new ArgumentNullException(nameof(builder));
				if (startIndex < 0 || startIndex > builder.Length) throw new ArgumentOutOfRangeException(nameof(startIndex));
				if (count < 0 || startIndex + count > builder.Length) throw new ArgumentOutOfRangeException(nameof(count));
	
				if (count == 0 || startIndex == builder.Length) return builder;
	
				var endIndex = startIndex + count;
				var markerIndex = IndexOf(builder, '`', startIndex, count);
				var cutStartIndex = markerIndex;
				while (markerIndex >= 0)
				{
					markerIndex++;
					while (markerIndex < endIndex && char.IsDigit(builder[markerIndex]))
						markerIndex++;
	
					var cutLength = markerIndex - cutStartIndex;
					builder.Remove(cutStartIndex, cutLength);
	
					endIndex -= cutLength;
					markerIndex = IndexOf(builder, '`', cutStartIndex, endIndex - cutStartIndex);
					cutStartIndex = markerIndex;
				}
	
				return builder;
			}
	
			private static void WriteName(Type type, StringBuilder builder, TypeNameFormatOptions options)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
				if (builder == null) throw new ArgumentNullException(nameof(builder));
	
				var arrayDepth = 0;
				while (type.IsArray)
				{
					type = type.GetElementType();
					arrayDepth++;
				}
	
				var writeGenericArguments = (options & TypeNameFormatOptions.IncludeGenericArguments) == TypeNameFormatOptions.IncludeGenericArguments;
				var namespaceWritten = (options & TypeNameFormatOptions.IncludeNamespace) != TypeNameFormatOptions.IncludeNamespace;
				var writeDeclaringType = (options & TypeNameFormatOptions.IncludeDeclaringType) == TypeNameFormatOptions.IncludeDeclaringType;
	
				var genericArguments = type.IsGenericType && writeGenericArguments ? type.GetGenericArguments() : Type.EmptyTypes;
				var genericArgumentOffset = 0;
				foreach (var declaringTypeInfo in new TypeNestingEnumerator(type))
				{
					if (!namespaceWritten)
					{
						var typeNamespace = declaringTypeInfo.Namespace;
						builder.Append(typeNamespace);
						if (!string.IsNullOrEmpty(typeNamespace))
							builder.Append('.');
						namespaceWritten = true;
					}
	
					var genericArgumentsCount = (declaringTypeInfo.IsGenericType && writeGenericArguments ? declaringTypeInfo.GetGenericArguments().Length : 0) - genericArgumentOffset;
					var partialGenerics = new ArraySegment<Type>(genericArguments, genericArgumentOffset, genericArgumentsCount);
	
					if (writeDeclaringType || declaringTypeInfo == type)
					{
						WriteNamePart(declaringTypeInfo, builder, partialGenerics, options);
	
						if (declaringTypeInfo == type == false)
							builder.Append('.');
					}
	
					genericArgumentOffset += genericArgumentsCount;
				}
	
				for (var d = 0; d < arrayDepth; d++)
				{
					builder.Append("[]");
				}
			}
			private static void WriteNamePart(Type type, StringBuilder builder, ArraySegment<Type> genericArguments, TypeNameFormatOptions options)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
				if (builder == null) throw new ArgumentNullException(nameof(builder));
	
				builder.Append(type.Name);
	
				if (genericArguments.Count > 0)
				{
					builder.Append("<");
					for (var i = genericArguments.Offset; i < genericArguments.Offset + genericArguments.Count; i++)
					{
						// ReSharper disable once PossibleNullReferenceException
						if (genericArguments.Array[i].IsGenericParameter == false)
						{
							WriteName(genericArguments.Array[i], builder, options);
						}
						builder.Append(',');
					}
					builder.Length--;
					builder.Append(">");
				}
			}
			private static int IndexOf(StringBuilder builder, char character, int startIndex, int count)
			{
				if (builder == null) throw new ArgumentNullException(nameof(builder));
				if (startIndex < 0 || startIndex > builder.Length) throw new ArgumentOutOfRangeException(nameof(startIndex));
				if (count < 0 || startIndex + count > builder.Length) throw new ArgumentOutOfRangeException(nameof(count));
	
				if (count == 0 || startIndex == builder.Length) return -1;
	
				for (int i = startIndex, len = startIndex + count; i < len; i++)
				{
					if (builder[i] == character)
						return i;
				}
				return -1;
			}
	
			public struct TypeNestingEnumerator : IEnumerator<Type>, IEnumerable<Type>
			{
				private readonly Type typeInfo;
	
				public TypeNestingEnumerator(Type typeInfo)
				{
					this.typeInfo = typeInfo;
					this.Current = null;
				}
	
				public bool MoveNext()
				{
					if (this.Current == null)
					{
						this.Reset();
						return true;
					}
					else if (this.Current == this.typeInfo)
					{
						return false;
					}
	
					var typeAboveCurrent = this.typeInfo;
					while (typeAboveCurrent != null && this.Current == GetDeclaringType(typeAboveCurrent) == false)
						typeAboveCurrent = GetDeclaringType(typeAboveCurrent);
	
					this.Current = typeAboveCurrent;
					return typeAboveCurrent != null;
				}
				public void Reset()
				{
					this.Current = this.typeInfo;
					while (GetDeclaringType(this.Current) != null) this.Current = GetDeclaringType(this.Current);
				}
	
				private static Type GetDeclaringType(Type type)
				{
					if (type == null) throw new ArgumentNullException(nameof(type));
	
					var declaringType = type.DeclaringType;
					// ReSharper disable once ConditionIsAlwaysTrueOrFalse
					if (declaringType == null)
					{
						return null;
					}
					return declaringType;
				}
	
				public Type Current { get; private set; }
				object IEnumerator.Current => this.Current;
	
				public TypeNestingEnumerator GetEnumerator()
				{
					return this;
				}
				IEnumerator<Type> IEnumerable<Type>.GetEnumerator()
				{
					return this;
				}
				IEnumerator IEnumerable.GetEnumerator()
				{
					return this;
				}
	
				public void Dispose()
				{
	
				}
			}
		}
	

		private class DefaultExpression : FormulaExpression
		{
			private readonly TypeReference type;
	
			public DefaultExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, ExpressionConstants.TYPE_ATTRIBUTE);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				switch (this.type.ToString())
				{
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_CHAR: return default(char);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_BOOL: return default(bool);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_BYTE: return default(byte);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_SBYTE: return default(sbyte);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_INT16: return default(short);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_UINT16: return default(ushort);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_INT32: return default(int);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_UINT32: return default(uint);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_INT64: return default(long);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_UINT64: return default(ulong);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_DOUBLE: return default(double);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_SINGLE: return default(float);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_DECIMAL: return default(decimal);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_DATE_TIME: return default(DateTime);
					case ExpressionConstants.KNOWN_TYPE_SYSTEM_TIME_SPAN: return default(TimeSpan);
					default:
						var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
						return typeDescription.DefaultValue;
	
				}
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("default(").Append(this.type).Append(")");
			}
		}
	

		private sealed class EnumTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private readonly Lazy<MemberGroup> lazyCheckedConversions;
			private readonly Lazy<MemberGroup> lazyUncheckedConversions;
			private readonly Lazy<MemberGroup[]> lazyBinaryOperations;
			private readonly Lazy<MemberGroup[]> lazyUnaryOperations;
	
			/// <inheritdoc />
			public EnumTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
				if (!type.IsEnum) throw new ArgumentException($"Type '{type}' should be enum type.");
	
				this.lazyCheckedConversions = new Lazy<MemberGroup>(() => CreateCheckedConversions(type), LazyThreadSafetyMode.ExecutionAndPublication);
				this.lazyUncheckedConversions = new Lazy<MemberGroup>(() => CreateUncheckedConversions(type), LazyThreadSafetyMode.ExecutionAndPublication);
				this.lazyBinaryOperations = new Lazy<MemberGroup[]>(() => CreateBinaryOperations(type), LazyThreadSafetyMode.ExecutionAndPublication);
				this.lazyUnaryOperations = new Lazy<MemberGroup[]>(() => CreateUnaryOperations(type), LazyThreadSafetyMode.ExecutionAndPublication);
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				var binaryOperations = this.lazyBinaryOperations.Value;
				if (operationIndex >= 0 && operationIndex < binaryOperations.Length)
				{
					binaryOperation = binaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				var unaryOperations = this.lazyUnaryOperations.Value;
				if (operationIndex >= 0 && operationIndex < unaryOperations.Length)
				{
					unaryOperation = unaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = this.lazyCheckedConversions.Value;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = this.lazyUncheckedConversions.Value;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation(Type resultType, Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: resultType,
							parameters: new [] {
								new ParameterDescription("value1", typeof(Int64), isRequired: true),
								new ParameterDescription("value2", typeof(Int64), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation(Type resultType, Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: resultType,
							parameters: new [] {
								new ParameterDescription("value", typeof(Int64), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Type enumType, Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", enumType, isRequired: true)
					});
			}
			private static MemberDescription CreateConvertFrom<T>(Type enumType, Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: enumType,
					parameters: new[] {
						new ParameterDescription("value", typeof(T), isRequired: true)
					});
			}
			private static MemberGroup CreateCheckedConversions(Type enumType)
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				if (IsSigned(enumType))
				{
					return new MemberGroup(MemberGroupType.Method, new[] {
						CreateConvertTo<char>(enumType, (_, arguments) => checked((char)arguments[0].ToInt64())),
						CreateConvertTo<sbyte>(enumType,(_, arguments) => checked((sbyte)arguments[0].ToInt64())),
						CreateConvertTo<byte>(enumType,(_, arguments) => checked((byte)arguments[0].ToInt64())),
						CreateConvertTo<short>(enumType,(_, arguments) => checked((short)arguments[0].ToInt64())),
						CreateConvertTo<ushort>(enumType,(_, arguments) => checked((ushort)arguments[0].ToInt64())),
						CreateConvertTo<int>(enumType,(_, arguments) => checked((int)arguments[0].ToInt64())),
						CreateConvertTo<uint>(enumType,(_, arguments) => checked((uint)arguments[0].ToInt64())),
						CreateConvertTo<long>(enumType,(_, arguments) => checked((long)arguments[0].ToInt64())),
						CreateConvertTo<ulong>(enumType,(_, arguments) => checked((ulong)arguments[0].ToInt64())),
						CreateConvertTo<float>(enumType,(_, arguments) => checked((float)arguments[0].ToInt64())),
						CreateConvertTo<double>(enumType,(_, arguments) => checked((double)arguments[0].ToInt64())),
						CreateConvertTo<decimal>(enumType,(_, arguments) => checked((decimal)arguments[0].ToInt64())),
	
						CreateConvertFrom<sbyte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToSByte()))),
						CreateConvertFrom<byte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToByte()))),
						CreateConvertFrom<short>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt16()))),
						CreateConvertFrom<ushort>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt16()))),
						CreateConvertFrom<int>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt32()))),
						CreateConvertFrom<uint>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt32()))),
						CreateConvertFrom<long>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt64()))),
						CreateConvertFrom<ulong>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt64()))),
					});
				}
				else
				{
					return new MemberGroup(MemberGroupType.Method, new[] {
						CreateConvertTo<char>(enumType, (_, arguments) => checked((char)arguments[0].ToUInt64())),
						CreateConvertTo<sbyte>(enumType,(_, arguments) => checked((sbyte)arguments[0].ToUInt64())),
						CreateConvertTo<byte>(enumType,(_, arguments) => checked((byte)arguments[0].ToUInt64())),
						CreateConvertTo<short>(enumType,(_, arguments) => checked((short)arguments[0].ToUInt64())),
						CreateConvertTo<ushort>(enumType,(_, arguments) => checked((ushort)arguments[0].ToUInt64())),
						CreateConvertTo<int>(enumType,(_, arguments) => checked((int)arguments[0].ToUInt64())),
						CreateConvertTo<uint>(enumType,(_, arguments) => checked((uint)arguments[0].ToUInt64())),
						CreateConvertTo<long>(enumType,(_, arguments) => checked((long)arguments[0].ToUInt64())),
						CreateConvertTo<ulong>(enumType,(_, arguments) => checked((ulong)arguments[0].ToUInt64())),
						CreateConvertTo<float>(enumType,(_, arguments) => checked((float)arguments[0].ToUInt64())),
						CreateConvertTo<double>(enumType,(_, arguments) => checked((double)arguments[0].ToUInt64())),
						CreateConvertTo<decimal>(enumType,(_, arguments) => checked((decimal)arguments[0].ToUInt64())),
	
						CreateConvertFrom<sbyte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToSByte()))),
						CreateConvertFrom<byte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToByte()))),
						CreateConvertFrom<short>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt16()))),
						CreateConvertFrom<ushort>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt16()))),
						CreateConvertFrom<int>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt32()))),
						CreateConvertFrom<uint>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt32()))),
						CreateConvertFrom<long>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt64()))),
						CreateConvertFrom<ulong>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt64()))),
					});
				}
			}
			private static MemberGroup CreateUncheckedConversions(Type enumType)
			{
				if (IsSigned(enumType))
				{
					return new MemberGroup(MemberGroupType.Method, new[] {
						CreateConvertTo<char>(enumType, (_, arguments) => unchecked((char)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<sbyte>(enumType,(_, arguments) => unchecked((sbyte)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<byte>(enumType,(_, arguments) => unchecked((byte)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<short>(enumType,(_, arguments) => unchecked((short)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<ushort>(enumType,(_, arguments) => unchecked((ushort)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<int>(enumType,(_, arguments) => unchecked((int)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<uint>(enumType,(_, arguments) => unchecked((uint)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<long>(enumType,(_, arguments) => unchecked((long)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<ulong>(enumType,(_, arguments) => unchecked((ulong)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<float>(enumType,(_, arguments) => unchecked((float)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<double>(enumType,(_, arguments) => unchecked((double)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<decimal>(enumType,(_, arguments) => unchecked((decimal)arguments[0].ToInt64(uncheckedConversion: true))),
	
						CreateConvertFrom<sbyte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToSByte(uncheckedConversion: true)))),
						CreateConvertFrom<byte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToByte(uncheckedConversion: true)))),
						CreateConvertFrom<short>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt16(uncheckedConversion: true)))),
						CreateConvertFrom<ushort>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt16(uncheckedConversion: true)))),
						CreateConvertFrom<int>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt32(uncheckedConversion: true)))),
						CreateConvertFrom<uint>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt32(uncheckedConversion: true)))),
						CreateConvertFrom<long>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt64(uncheckedConversion: true)))),
						CreateConvertFrom<ulong>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt64(uncheckedConversion: true)))),
					});
				}
				else
				{
					return new MemberGroup(MemberGroupType.Method, new[] {
						CreateConvertTo<char>(enumType, (_, arguments) => unchecked((char)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<sbyte>(enumType,(_, arguments) => unchecked((sbyte)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<byte>(enumType,(_, arguments) => unchecked((byte)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<short>(enumType,(_, arguments) => unchecked((short)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<ushort>(enumType,(_, arguments) => unchecked((ushort)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<int>(enumType,(_, arguments) => unchecked((int)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<uint>(enumType,(_, arguments) => unchecked((uint)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<long>(enumType,(_, arguments) => unchecked((long)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<ulong>(enumType,(_, arguments) => unchecked((ulong)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<float>(enumType,(_, arguments) => unchecked((float)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<double>(enumType,(_, arguments) => unchecked((double)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<decimal>(enumType,(_, arguments) => unchecked((decimal)arguments[0].ToUInt64(uncheckedConversion: true))),
	
						CreateConvertFrom<sbyte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToSByte(uncheckedConversion: true)))),
						CreateConvertFrom<byte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToByte(uncheckedConversion: true)))),
						CreateConvertFrom<short>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt16(uncheckedConversion: true)))),
						CreateConvertFrom<ushort>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt16(uncheckedConversion: true)))),
						CreateConvertFrom<int>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt32(uncheckedConversion: true)))),
						CreateConvertFrom<uint>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt32(uncheckedConversion: true)))),
						CreateConvertFrom<long>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt64(uncheckedConversion: true)))),
						CreateConvertFrom<ulong>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt64(uncheckedConversion: true)))),
					});
				}
			}
			private static MemberGroup[] CreateBinaryOperations(Type enumType)
			{
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				var binaryOperations = new MemberGroup[lastBinaryOperation + 1];
				binaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() & arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() | arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() ^ arguments[1].ToInt64()));
	
				binaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() * arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() * arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() / arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() / arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() % arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() + arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() + arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() - arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() - arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() << arguments[1].ToInt32()));
				binaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() >> arguments[1].ToInt32()));
	
				binaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() > arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() >= arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() < arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() <= arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() == arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() != arguments[1].ToInt64()));
				return binaryOperations;
			}
			private static MemberGroup[] CreateUnaryOperations(Type enumType)
			{
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				var unaryOperations = new MemberGroup[lastUnaryOperation + 1];
				unaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, unchecked(+arguments[0].ToInt64())));
				unaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, unchecked(-arguments[0].ToInt64())));
				unaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, checked(-arguments[0].ToInt64())));
				unaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, unchecked((Int64)~arguments[0].ToUInt64())));
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
				return unaryOperations;
			}
	
			private static bool IsSigned(Type enumType)
			{
				var underlyingType = Enum.GetUnderlyingType(enumType);
				return underlyingType == typeof(sbyte) || underlyingType == typeof(short) || underlyingType == typeof(int) || underlyingType == typeof(long);
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class ExpressionBuildHelper
		{
			private static readonly string[] PositionNumbers = Enumerable.Range(0, 64).Select(p => p.ToString()).ToArray();
			private static readonly IReadOnlyDictionary<string, FormulaExpression> EmptyArguments = new Dictionary<string, FormulaExpression>();
	
			public static FormulaExpression GetExpression(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					TryGetExpressionDictionary(propertyValue, out var propertyValueExpressionObj))
				{
					return FormulaExpression.Create(propertyValueExpressionObj);
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static string GetString(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					propertyValue is string propertyValueString)
				{
					return propertyValueString;
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static object GetAnyValue(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue))
				{
					return propertyValue;
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static bool? GetBoolean(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					propertyValue is bool propertyValueBool)
				{
					return propertyValueBool;
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static TypeReference GetTypeRef(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue))
				{
					if (propertyValue is string plainName)
					{
						return new TypeReference(plainName);
					}
					else if (TryGetExpressionDictionary(propertyValue, out var propertyValueExpressionObj))
					{
						return new TypeReference(propertyValueExpressionObj);
					}
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static IReadOnlyList<TypeReference> GetTypeRefArguments(IReadOnlyDictionary<string, object> expressionObj, string propertyName)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					TryGetExpressionDictionary(propertyValue, out var propertyValueExpressionObj))
				{
					var arguments = new List<TypeReference>(propertyValueExpressionObj.Count);
					for (var i = 0; i < propertyValueExpressionObj.Count; i++)
					{
						var argumentIndex = GetIndexAsString(i);
						arguments.Add(GetTypeRef(propertyValueExpressionObj, argumentIndex, optional: false));
					}
					return arguments;
				}
	
				return Array.Empty<TypeReference>();
			}
			public static IReadOnlyDictionary<string, FormulaExpression> GetArguments(IReadOnlyDictionary<string, object> expressionObj, string propertyName)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					TryGetExpressionDictionary(propertyValue, out var propertyValueExpressionObj))
				{
					var arguments = new Dictionary<string, FormulaExpression>(propertyValueExpressionObj.Count);
					foreach (var kv in propertyValueExpressionObj)
					{
						arguments[kv.Key] = GetExpression(propertyValueExpressionObj, kv.Key, optional: false);
					}
					return arguments;
				}
	
				return EmptyArguments;
			}
	
			private static bool TryGetExpressionDictionary(object value, out IReadOnlyDictionary<string, object> expressionObj)
			{
				if (value is IReadOnlyDictionary<string, object> readOnlyDictionary)
				{
					expressionObj = readOnlyDictionary;
					return true;
				}
				else if (value is IDictionary<string, object> dictionary)
				{
					expressionObj = new Dictionary<string, object>(dictionary);
					return true;
				}
	
				expressionObj = null;
				return false;
			}
			private static string GetIndexAsString(int index)
			{
				if (index >= 0 && index < 64)
				{
					return PositionNumbers[index];
				}
				return index.ToString();
			}
		}
	

		private sealed class ExpressionConstants
		{
			public const string EXPRESSION_TYPE_ATTRIBUTE = "expressionType";
			public const string EXPRESSION_ATTRIBUTE = "expression";
			public const string ARGUMENTS_ATTRIBUTE = "arguments";
			public const string LEFT_ATTRIBUTE = "left";
			public const string RIGHT_ATTRIBUTE = "right";
			public const string TEST_ATTRIBUTE = "test";
			public const string IF_TRUE_ATTRIBUTE = "ifTrue";
			public const string IF_FALSE_ATTRIBUTE = "ifFalse";
			public const string TYPE_ATTRIBUTE = "type";
			public const string VALUE_ATTRIBUTE = "value";
			public const string PROPERTY_OR_FIELD_NAME_ATTRIBUTE = "propertyOrFieldName";
			public const string NAME_ATTRIBUTE = "name";
			public const string USE_NULL_PROPAGATION_ATTRIBUTE = "useNullPropagation";
			// expression types
			public const string EXPRESSION_TYPE_PROPERTY_OR_FIELD = "PropertyOrField";
			public const string EXPRESSION_TYPE_MEMBER_RESOLVE = "MemberResolve";
			public const string EXPRESSION_TYPE_CONSTANT = "Constant";
			public const string EXPRESSION_TYPE_CONVERT = "Convert";
			public const string EXPRESSION_TYPE_CONVERT_CHECKED = "ConvertChecked";
			public const string EXPRESSION_TYPE_GROUP = "Group";
			public const string EXPRESSION_TYPE_INVOKE = "Invoke";
			public const string EXPRESSION_TYPE_LAMBDA = "Lambda";
			public const string EXPRESSION_TYPE_INDEX = "Index";
			public const string EXPRESSION_TYPE_UNCHECKED_SCOPE = "UncheckedScope";
			public const string EXPRESSION_TYPE_CHECKED_SCOPE = "CheckedScope";
			public const string EXPRESSION_TYPE_TYPE_OF = "TypeOf";
			public const string EXPRESSION_TYPE_DEFAULT = "Default";
			public const string EXPRESSION_TYPE_NEW = "New";
			public const string EXPRESSION_TYPE_NEW_ARRAY_BOUNDS = "NewArrayBounds";
			public const string EXPRESSION_TYPE_ADD = "Add";
			public const string EXPRESSION_TYPE_ADD_CHECKED = "AddChecked";
			public const string EXPRESSION_TYPE_SUBTRACT = "Subtract";
			public const string EXPRESSION_TYPE_SUBTRACT_CHECKED = "SubtractChecked";
			public const string EXPRESSION_TYPE_LEFT_SHIFT = "LeftShift";
			public const string EXPRESSION_TYPE_RIGHT_SHIFT = "RightShift";
			public const string EXPRESSION_TYPE_GREATER_THAN = "GreaterThan";
			public const string EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL = "GreaterThanOrEqual";
			public const string EXPRESSION_TYPE_LESS_THAN = "LessThan";
			public const string EXPRESSION_TYPE_LESS_THAN_OR_EQUAL = "LessThanOrEqual";
			public const string EXPRESSION_TYPE_NEGATE = "Negate";
			public const string EXPRESSION_TYPE_NEGATE_CHECKED = "NegateChecked";
			public const string EXPRESSION_TYPE_POWER = "Power";
			public const string EXPRESSION_TYPE_COMPLEMENT = "Complement";
			public const string EXPRESSION_TYPE_DIVIDE = "Divide";
			public const string EXPRESSION_TYPE_DIVIDE_CHECKED = "DivideChecked";
			public const string EXPRESSION_TYPE_MULTIPLY = "Multiply";
			public const string EXPRESSION_TYPE_MULTIPLY_CHECKED = "MultiplyChecked";
			public const string EXPRESSION_TYPE_MODULO = "Modulo";
			public const string EXPRESSION_TYPE_TYPE_IS = "TypeIs";
			public const string EXPRESSION_TYPE_TYPE_AS = "TypeAs";
			public const string EXPRESSION_TYPE_NOT = "Not";
			public const string EXPRESSION_TYPE_EQUAL = "Equal";
			public const string EXPRESSION_TYPE_NOT_EQUAL = "NotEqual";
			public const string EXPRESSION_TYPE_AND = "And";
			public const string EXPRESSION_TYPE_OR = "Or";
			public const string EXPRESSION_TYPE_EXCLUSIVE_OR = "ExclusiveOr";
			public const string EXPRESSION_TYPE_AND_ALSO = "AndAlso";
			public const string EXPRESSION_TYPE_OR_ELSE = "OrElse";
			public const string EXPRESSION_TYPE_COALESCE = "Coalesce";
			public const string EXPRESSION_TYPE_CONDITION = "Condition";
			public const string EXPRESSION_TYPE_UNARY_PLUS = "UnaryPlus";
			// known types
			public const string KNOWN_TYPE_ARRAY = "Array";
			public const string KNOWN_TYPE_SYSTEM_VOID = "System.Void";
			public const string KNOWN_TYPE_SYSTEM_CHAR = "System.Char";
			public const string KNOWN_TYPE_SYSTEM_BOOL = "System.Boolean";
			public const string KNOWN_TYPE_SYSTEM_BYTE = "System.Byte";
			public const string KNOWN_TYPE_SYSTEM_SBYTE = "System.SByte";
			public const string KNOWN_TYPE_SYSTEM_DECIMAL = "System.Decimal";
			public const string KNOWN_TYPE_SYSTEM_DATE_TIME = "System.DateTime";
			public const string KNOWN_TYPE_SYSTEM_TIME_SPAN = "System.TimeSpan";
			public const string KNOWN_TYPE_SYSTEM_DOUBLE = "System.Double";
			public const string KNOWN_TYPE_SYSTEM_SINGLE = "System.Single";
			public const string KNOWN_TYPE_SYSTEM_INT32 = "System.Int32";
			public const string KNOWN_TYPE_SYSTEM_UINT32 = "System.UInt32";
			public const string KNOWN_TYPE_SYSTEM_INT64 = "System.Int64";
			public const string KNOWN_TYPE_SYSTEM_UINT64 = "System.UInt64";
			public const string KNOWN_TYPE_SYSTEM_OBJECT = "System.Object";
			public const string KNOWN_TYPE_SYSTEM_INT16 = "System.Int16";
			public const string KNOWN_TYPE_SYSTEM_UINT16 = "System.UInt16";
			public const string KNOWN_TYPE_SYSTEM_STRING = "System.String";
			public const string KNOWN_TYPE_SYSTEM_TYPE = "System.Type";
			public const string KNOWN_TYPE_SYSTEM_ARRAY = "System.Array";
			// notations
			public const string NOTATION_TRUE_STRING = "true";
			public const string NOTATION_FALSE_STRING = "false";
			public const string NOTATION_NULL_STRING = "null";
			//
	
			public static readonly Dictionary<string, string> TypeAliases = new Dictionary<string, string>(StringComparer.Ordinal) {
				{ "void", KNOWN_TYPE_SYSTEM_VOID },
				{ "char", KNOWN_TYPE_SYSTEM_CHAR },
				{ "bool", KNOWN_TYPE_SYSTEM_BOOL },
				{ "byte", KNOWN_TYPE_SYSTEM_BYTE },
				{ "sbyte", KNOWN_TYPE_SYSTEM_SBYTE },
				{ "decimal", KNOWN_TYPE_SYSTEM_DECIMAL },
				{ "double", KNOWN_TYPE_SYSTEM_DOUBLE },
				{ "float", KNOWN_TYPE_SYSTEM_SINGLE },
				{ "int", KNOWN_TYPE_SYSTEM_INT32 },
				{ "uint", KNOWN_TYPE_SYSTEM_UINT32 },
				{ "long", KNOWN_TYPE_SYSTEM_INT64 },
				{ "ulong", KNOWN_TYPE_SYSTEM_UINT64 },
				{ "object", KNOWN_TYPE_SYSTEM_OBJECT },
				{ "short", KNOWN_TYPE_SYSTEM_INT16 },
				{ "ushort", KNOWN_TYPE_SYSTEM_UINT16 },
				{ "string", KNOWN_TYPE_SYSTEM_STRING },
			};
	
			public static readonly Dictionary<string, string> SystemTypes = new Dictionary<string, string>(StringComparer.Ordinal) {
				{ "Void", KNOWN_TYPE_SYSTEM_VOID },
				{ "Char", KNOWN_TYPE_SYSTEM_CHAR },
				{ "Boolean", KNOWN_TYPE_SYSTEM_BOOL },
				{ "Byte", KNOWN_TYPE_SYSTEM_BYTE },
				{ "SByte", KNOWN_TYPE_SYSTEM_SBYTE },
				{ "Decimal", KNOWN_TYPE_SYSTEM_DECIMAL },
				{ "Double", KNOWN_TYPE_SYSTEM_DOUBLE },
				{ "Single", KNOWN_TYPE_SYSTEM_SINGLE },
				{ "Int32", KNOWN_TYPE_SYSTEM_INT32 },
				{ "UInt32", KNOWN_TYPE_SYSTEM_UINT32 },
				{ "Int64", KNOWN_TYPE_SYSTEM_INT64 },
				{ "UInt64", KNOWN_TYPE_SYSTEM_UINT64 },
				{ "Object", KNOWN_TYPE_SYSTEM_OBJECT },
				{ "Int16", KNOWN_TYPE_SYSTEM_INT16 },
				{ "UInt16", KNOWN_TYPE_SYSTEM_UINT16 },
				{ "String", KNOWN_TYPE_SYSTEM_STRING },
				{ "Type", KNOWN_TYPE_SYSTEM_TYPE },
				{ "Array", KNOWN_TYPE_SYSTEM_ARRAY },
				{ "DateTime", KNOWN_TYPE_SYSTEM_DATE_TIME },
				{ "TimeSpan", KNOWN_TYPE_SYSTEM_TIME_SPAN },
			};
		}
	

		private sealed class Float32TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Float32TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast CompareOfFloatsByEqualityOperator
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<float>((_, arguments) => (float)unchecked(arguments[0].ToSingle() * arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<float>((_, arguments) => (float)checked(arguments[0].ToSingle() * arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<float>((_, arguments) => (float)unchecked(arguments[0].ToSingle() / arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<float>((_, arguments) => (float)checked(arguments[0].ToSingle() / arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<float>((_, arguments) => (double)Math.Pow(arguments[0].ToSingle(), arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<float>((_, arguments) => (float)(arguments[0].ToSingle() % arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<float>((_, arguments) => (float)unchecked(arguments[0].ToSingle() + arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<float>((_, arguments) => (float)checked(arguments[0].ToSingle() + arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<float>((_, arguments) => (float)unchecked(arguments[0].ToSingle() - arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<float>((_, arguments) => (float)checked(arguments[0].ToSingle() - arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() > arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() >= arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() < arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() <= arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() == arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() != arguments[1].ToSingle()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<float>((_, arguments) => (float)unchecked(+arguments[0].ToSingle()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<float>((_, arguments) => (float)unchecked(-arguments[0].ToSingle()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<float>((_, arguments) => (float)checked(-arguments[0].ToSingle()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToSingle())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToSingle())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToSingle())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToSingle())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToSingle())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToSingle())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToSingle())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToSingle())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToSingle())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToSingle())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToSingle())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToSingle())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToSingle())),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToSingle())),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToSingle())),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToSingle())),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToSingle())),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToSingle())),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToSingle())),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToSingle())),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToSingle())),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToSingle())),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToSingle())),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToSingle())),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast CompareOfFloatsByEqualityOperator
			}
			/// <inheritdoc />
			public Float32TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Single), isRequired: true),
								new ParameterDescription("value2", typeof(Single), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Single), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(Single), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class Float64TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Float64TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast CompareOfFloatsByEqualityOperator
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<double>((_, arguments) => (double)unchecked(arguments[0].ToDouble() * arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<double>((_, arguments) => (double)checked(arguments[0].ToDouble() * arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<double>((_, arguments) => (double)unchecked(arguments[0].ToDouble() / arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<double>((_, arguments) => (double)checked(arguments[0].ToDouble() / arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<double>((_, arguments) => (double)Math.Pow(arguments[0].ToDouble(), arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<double>((_, arguments) => (double)(arguments[0].ToDouble() % arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<double>((_, arguments) => (double)unchecked(arguments[0].ToDouble() + arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<double>((_, arguments) => (double)checked(arguments[0].ToDouble() + arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<double>((_, arguments) => (double)unchecked(arguments[0].ToDouble() - arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<double>((_, arguments) => (double)checked(arguments[0].ToDouble() - arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() > arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() >= arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() < arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() <= arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() == arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() != arguments[1].ToDouble()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<double>((_, arguments) => (double)unchecked(+arguments[0].ToDouble()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<double>((_, arguments) => (double)unchecked(-arguments[0].ToDouble()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<double>((_, arguments) => (double)checked(-arguments[0].ToDouble()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToDouble())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToDouble())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToDouble())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToDouble())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToDouble())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToDouble())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToDouble())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToDouble())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToDouble())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToDouble())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToDouble())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToDouble())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToDouble())),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToDouble())),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToDouble())),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToDouble())),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToDouble())),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToDouble())),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToDouble())),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToDouble())),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToDouble())),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToDouble())),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToDouble())),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToDouble())),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast CompareOfFloatsByEqualityOperator
			}
			/// <inheritdoc />
			public Float64TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Double), isRequired: true),
								new ParameterDescription("value2", typeof(Double), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Double), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value1", typeof(Double), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		public class FormulaException : Exception
		{
			public FormulaException(string message) : base(message)
			{
	
			}
			public FormulaException(string message, Exception innerException) : base(message, innerException)
			{
	
			}
	
			public static Exception MissingBinaryOperation(BinaryOperationType binaryOperation, VariableValue leftValue, VariableValue rightValue)
			{
				throw new FormulaException($"Missing binary operation '{binaryOperation}' between types '{CSharpName(leftValue.Type)}' and '{CSharpName(rightValue.Type)}'.");
			}
			public static Exception MissingUnaryOperation(UnaryOperationType unaryOperation, VariableValue target)
			{
				throw new FormulaException($"Missing unary operation '{unaryOperation}' on type '{CSharpName(target.Type)}'.");
			}
			public static Exception UnknownUnaryExpression(string expressionType)
			{
				throw new FormulaException($"Unknown unary expression type '{expressionType}'.");
			}
			public static Exception UnknownBinaryExpression(string expressionType)
			{
				throw new FormulaException($"Unknown binary expression type '{expressionType}'.");
			}
			public static Exception UnknownExpressionType(string expressionType)
			{
				throw new FormulaException($"Unknown expression type '{expressionType}'.");
			}
			public static Exception CantAccessMemberOnNull(string name)
			{
				throw new FormulaException($"Can't access member with name '{name}' on null value.");
			}
			public static Exception CantFindMember(ITypeDescription targetType, string name)
			{
				throw new FormulaException($"Can't find member with name '{name}' on type '{targetType}'.");
			}
			public static Exception UnableToResolveGlobalName(string name)
			{
				throw new FormulaException($"Unable to find parameter with name '{name}' or type starting from this name or member on global object.");
			}
			public static Exception CanConvertNullToType(VariableValue value, ITypeDescription targetType)
			{
				throw new FormulaException($"Can't convert null value to type '{targetType}'.");
			}
			public static VariableValue WrongJunctionOperands(string junctionOperation, VariableValue leftValue, VariableValue rightValue)
			{
				throw new FormulaException($"There is no '{junctionOperation}' between '{CSharpName(leftValue.Type)}' and '{CSharpName(rightValue.Type)}' types.");
			}
			public static Exception CantFindIndexer(ITypeDescription targetType, Dictionary<string, VariableValue> indexArguments)
			{
				throw new FormulaException($"Can't find indexer on type '{targetType}' accepting {indexArguments.Count} arguments.");
			}
			public static Exception CantIndexOnNull()
			{
				throw new FormulaException("Can't apply indexing to null value.");
			}
			public static Exception CantCallOnNull()
			{
				throw new FormulaException("Can't invoke on null value.");
			}
			public static Exception UnableToInvokeNonMethodOrDelegate(VariableValue variableValue)
			{
				throw new FormulaException($"Can invoke on non-method member or non-delegate value of type '{CSharpName(variableValue.Type)}'.");
			}
			public static Exception InvalidConditionResultType(VariableValue testValue)
			{
				throw new FormulaException($"Can't use value of type '{CSharpName(testValue.Type)}' for condition result. A boolean value is expected.");
			}
			public static Exception CanConvertToType(VariableValue value, ITypeDescription targetTypeDescription)
			{
				throw new FormulaException($"There is no explicit/implicit conversion exists from '{CSharpName(value.Type)}' type to '{targetTypeDescription}' type.");
			}
			public static Exception UnableToBindMethodToParameters(string name, ITypeDescription targetTypeDescription, Dictionary<string, VariableValue> callArguments)
			{
				if (callArguments.Count != 0)
				{
					throw new FormulaException($"Can't find method with name '{name}' on type '{targetTypeDescription}' accepting {callArguments.Count} arguments of types '{string.Join(", ", callArguments.Values.Select(v => CSharpName(v.Type)))}'.");
				}
				else
				{
					throw new FormulaException($"Can't find method with name '{name}' on type '{targetTypeDescription}' accepting no arguments'.");
				}
			}
			public static Exception UnableToBindConstructorToParameters(ITypeDescription targetTypeDescription, Dictionary<string, VariableValue> callArguments)
			{
				if (callArguments.Count != 0)
				{
					throw new FormulaException($"Can't find constructor on type '{targetTypeDescription}' accepting arguments of types '{string.Join(", ", callArguments.Values.Select(v => CSharpName(v.Type)))}'.");
				}
				else
				{
					throw new FormulaException($"Can't find constructor on type '{targetTypeDescription}' accepting no arguments'.");
				}
			}
			public static Exception CanAccessMethodOrConstructorGroup(string name, ITypeDescription targetTypeDescription)
			{
				throw new FormulaException($"Can't access method group with name '{name}' on type '{targetTypeDescription}' in this context.");
			}
			public static Exception UnableToResolveType(TypeReference typeReference)
			{
				throw new FormulaException($"Can't find type with name '{typeReference}'. Add this type to list of known types before using it.");
			}
			public static Exception InvalidLambdaArgument(FormulaExpression lambdaArgument)
			{
				throw new FormulaException($"Invalid lambda argument expression '{lambdaArgument}'({lambdaArgument.GetType().Name}) while plain argument name is expected.");
			}
			public static Exception MissingRequiredAttributeInExpression(string propertyName)
			{
				throw new FormulaException($"Missing required attribute '{propertyName}' on expression object.");
			}
	
			private static string CSharpName(Type type)
			{
				return CSharpNameUtils.GetCSharpFullNameWithGenerics(type);
			}
		}
	

		public class FormulaExecutionContext
		{
			public bool AutoNullPropagation { get; }
			public VariableValue Global { get; }
			public IReadOnlyDictionary<string, VariableValue> Arguments { get; }
			public IFormulaTypeResolver TypeResolver { get; }
	
			public FormulaExecutionContext
			(
				IReadOnlyDictionary<string, VariableValue> arguments,
				VariableValue global = default,
				bool autoNullPropagation = false,
				IFormulaTypeResolver typeResolver = null)
			{
				this.Arguments = arguments;
				this.Global = global;
				this.AutoNullPropagation = autoNullPropagation;
				this.TypeResolver = typeResolver ?? KnownFormulaTypeResolver.Default;
			}
		}
	

		public abstract class FormulaExpression
		{
			public static FormulaExpression Create(IReadOnlyDictionary<string, object> expressionObj, Type expectedType = null)
			{
				var expressionType = ExpressionBuildHelper.GetString(expressionObj, ExpressionConstants.EXPRESSION_TYPE_ATTRIBUTE);
				FormulaExpression expression;
				switch (expressionType)
				{
	
					case ExpressionConstants.EXPRESSION_TYPE_PROPERTY_OR_FIELD:
					case ExpressionConstants.EXPRESSION_TYPE_MEMBER_RESOLVE: expression = new MemberExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_INVOKE: expression = new InvokeExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_LAMBDA: expression = new LambdaExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_INDEX: expression = new IndexExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_TYPE_OF: expression = new TypeOfExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_CONSTANT: expression = new ConstantExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_DEFAULT: expression = new DefaultExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_NEW: expression = new NewExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_NEW_ARRAY_BOUNDS: expression = new NewArrayBoundExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_ADD:
					case ExpressionConstants.EXPRESSION_TYPE_ADD_CHECKED:
					case ExpressionConstants.EXPRESSION_TYPE_SUBTRACT:
					case ExpressionConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED:
					case ExpressionConstants.EXPRESSION_TYPE_LEFT_SHIFT:
					case ExpressionConstants.EXPRESSION_TYPE_RIGHT_SHIFT:
					case ExpressionConstants.EXPRESSION_TYPE_GREATER_THAN:
					case ExpressionConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL:
					case ExpressionConstants.EXPRESSION_TYPE_LESS_THAN:
					case ExpressionConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL:
					case ExpressionConstants.EXPRESSION_TYPE_POWER:
					case ExpressionConstants.EXPRESSION_TYPE_DIVIDE:
					case ExpressionConstants.EXPRESSION_TYPE_DIVIDE_CHECKED:
					case ExpressionConstants.EXPRESSION_TYPE_MULTIPLY:
					case ExpressionConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED:
					case ExpressionConstants.EXPRESSION_TYPE_MODULO:
					case ExpressionConstants.EXPRESSION_TYPE_EQUAL:
					case ExpressionConstants.EXPRESSION_TYPE_NOT_EQUAL:
					case ExpressionConstants.EXPRESSION_TYPE_AND:
					case ExpressionConstants.EXPRESSION_TYPE_OR:
					case ExpressionConstants.EXPRESSION_TYPE_EXCLUSIVE_OR:
					case ExpressionConstants.EXPRESSION_TYPE_AND_ALSO:
					case ExpressionConstants.EXPRESSION_TYPE_OR_ELSE:
					case ExpressionConstants.EXPRESSION_TYPE_COALESCE: expression = new BinaryExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_NEGATE:
					case ExpressionConstants.EXPRESSION_TYPE_NEGATE_CHECKED:
					case ExpressionConstants.EXPRESSION_TYPE_NOT:
					case ExpressionConstants.EXPRESSION_TYPE_COMPLEMENT: expression = new UnaryExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_TYPE_IS: expression = new TypeIsExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_CONVERT:
					case ExpressionConstants.EXPRESSION_TYPE_CONVERT_CHECKED:
					case ExpressionConstants.EXPRESSION_TYPE_TYPE_AS: expression = new ConvertExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_CONDITION: expression = new ConditionExpression(expressionObj); break;
					case ExpressionConstants.EXPRESSION_TYPE_GROUP:
					case ExpressionConstants.EXPRESSION_TYPE_UNCHECKED_SCOPE:
					case ExpressionConstants.EXPRESSION_TYPE_CHECKED_SCOPE:
					case ExpressionConstants.EXPRESSION_TYPE_UNARY_PLUS: expression = new UnaryExpression(expressionObj); break;
					default: throw FormulaException.UnknownExpressionType(expressionType);
				}
	
				if (expectedType != null)
				{
					expression = new ConvertExpression(expression, expectedType, checkedScope: false);
				}
	
				return expression;
			}
	
			public static void RegisterFunc<Arg1T, Arg2T, Arg3T, Arg4T, ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<Arg1T, Arg2T, Arg3T, Arg4T, ResultT>(default, default, default); } }
			public static void RegisterFunc<Arg1T, Arg2T, Arg3T, ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<Arg1T, Arg2T, Arg3T, ResultT>(default, default, default); } }
			public static void RegisterFunc<Arg1T, Arg2T, ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<Arg1T, Arg2T, ResultT>(default, default, default); } }
			public static void RegisterFunc<Arg1T, ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<Arg1T, ResultT>(default, default, default); } }
			public static void RegisterFunc<ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<ResultT>(default, default, default); } }
	
			public static void RegisterAction<Arg1T, Arg2T, Arg3T, Arg4T>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Action<Arg1T, Arg2T, Arg3T, Arg4T>(default, default, default); } }
			public static void RegisterAction<Arg1T, Arg2T, Arg3T>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Action<Arg1T, Arg2T, Arg3T>(default, default, default); } }
			public static void RegisterAction<Arg1T, Arg2T>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Action<Arg1T, Arg2T>(default, default, default); } }
			public static void RegisterAction<Arg1T>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Action<Arg1T>(default, default, default); } }
	
			public abstract VariableValue Execute(FormulaExecutionContext context);
	
			public abstract void BuildDebugView(StringBuilder stringBuilder);
	
			/// <inheritdoc />
			public sealed override string ToString()
			{
				var debugViewBuilder = new StringBuilder();
				this.BuildDebugView(debugViewBuilder);
				return debugViewBuilder.ToString();
			}
		}
	

		[Flags]
		public enum FormulaOptions
		{
			None = 0,
			UseDynamicMethods = 0x1 << 0,
			AllowReflectionApi = 0x1 << 1,
		}
	

		public sealed class GenericConstraint
		{
			private readonly Type[] requiredTypes;
			private readonly GenericParameterAttributes otherConstraints;
	
			public GenericConstraint(Type genericArgument)
			{
				if (genericArgument == null) throw new ArgumentNullException(nameof(genericArgument));
				if (!genericArgument.IsGenericParameter) throw new ArgumentException("Type should be generic parameter.", nameof(genericArgument));
	
				this.requiredTypes = genericArgument.GetGenericParameterConstraints();
				this.otherConstraints = genericArgument.GenericParameterAttributes;
			}
	
			public bool IsMatching(Type type)
			{
				// check required types
				if (this.requiredTypes != null && this.requiredTypes.Length > 0)
				{
					foreach (var requiredType in this.requiredTypes)
					{
						if (!requiredType.IsAssignableFrom(type))
						{
							return false;
						}
					}
				}
	
				// check other
				if ((this.otherConstraints & GenericParameterAttributes.ReferenceTypeConstraint) != 0 && type.IsValueType)
				{
					return false;
				}
	
				if ((this.otherConstraints & GenericParameterAttributes.NotNullableValueTypeConstraint) != 0 &&
					(Nullable.GetUnderlyingType(type) != null || !type.IsValueType))
				{
					return false;
				}
	
				if ((this.otherConstraints & GenericParameterAttributes.DefaultConstructorConstraint) != 0 &&
					type.GetConstructor(BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null) == null)
				{
					return false;
				}
	
				return true;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				return $"Constraint, Types: {string.Join(", ", this.requiredTypes.Select(CSharpNameUtils.GetCSharpFullNameWithGenerics))}, Other: {this.otherConstraints}";
			}
		}
	

		public interface IFormulaTypeResolver
		{
			ITypeDescription GetTypeDescription(Type type);
			ITypeDescription GetTypeDescription(TypeReference typeReference);
	
			bool TryGetTypeDescription(TypeReference typeReference, out ITypeDescription typeDescription);
		}
	

		private class IndexExpression : FormulaExpression, INullPropagationExpression
		{
			private readonly IReadOnlyDictionary<string, FormulaExpression> arguments;
			private readonly FormulaExpression expression;
			private readonly bool useNullPropagation;
	
	
			/// <inheritdoc />
			public bool IsNullPropagationEnabled
			{
				get
				{
					if (this.useNullPropagation)
					{
						return true;
					}
	
					return (this.expression as INullPropagationExpression)?.IsNullPropagationEnabled ?? false;
				}
			}
	
			public IndexExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.arguments = ExpressionBuildHelper.GetArguments(expressionObj, ExpressionConstants.ARGUMENTS_ATTRIBUTE);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, ExpressionConstants.EXPRESSION_ATTRIBUTE, optional: false);
				this.useNullPropagation = ExpressionBuildHelper.GetBoolean(expressionObj, ExpressionConstants.USE_NULL_PROPAGATION_ATTRIBUTE, optional: true)
					.GetValueOrDefault();
			}
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var target = this.expression.Execute(context);
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
	
				if (target.IsNull)
				{
					if (isNullPropagation)
					{
						return VariableValue.Null;
					}
					else
					{
						throw FormulaException.CantIndexOnNull();
					}
				}
	
				var indexArguments = new Dictionary<string, VariableValue>();
				foreach (var index in this.arguments)
				{
					indexArguments[index.Key] = index.Value.Execute(context);
				}
	
				var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(target.Type);
				if (!targetTypeDescriptor.TryGetIndexer(indexArguments.Count, out var indexAccessor))
				{
					throw FormulaException.CantFindIndexer(targetTypeDescriptor, indexArguments);
				}
	
				if (indexAccessor.TryInvoke(target, indexArguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
				throw FormulaException.CantFindIndexer(targetTypeDescriptor, indexArguments);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				this.expression.BuildDebugView(stringBuilder);
				if (this.useNullPropagation)
				{
					stringBuilder.Append("?");
				}
				stringBuilder.Append("[");
				foreach (var argument in this.arguments)
				{
					if (!argument.Key.All(char.IsDigit))
					{
						stringBuilder.Append(argument.Key).Append(": ");
					}
					argument.Value.BuildDebugView(stringBuilder);
					stringBuilder.Append(", ");
				}
	
				if (this.arguments.Count > 0)
				{
					stringBuilder.Length -= 2;
				}
	
				stringBuilder.Append("]");
			}
		}
	

		private sealed class Int16TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Int16TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt16() & arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt16() | arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt16() ^ arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt16() * arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() * arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt16() / arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() / arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToInt16(), arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt16() % arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt16() + arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() + arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt16() - arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() - arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() > arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() >= arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() < arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() <= arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() == arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() != arguments[1].ToInt16()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToInt16()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToInt16()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToInt16()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToInt16()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToInt16())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToInt16())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToInt16())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToInt16())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToInt16())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToInt16())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToInt16())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToInt16())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToInt16())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToInt16())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToInt16())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToInt16())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToInt16(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public Int16TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Int16), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(Int16), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Int16), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(Int16), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class Int32TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Int32TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt32() & arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt32() | arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt32() ^ arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt32() * arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() * arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt32() / arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() / arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToInt32(), arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt32() % arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt32() + arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() + arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt32() - arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() - arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() << arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() >> arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() > arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() >= arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() < arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() <= arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() == arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() != arguments[1].ToInt32()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToInt32()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToInt32()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToInt32()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToInt32()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToInt32())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToInt32())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToInt32())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToInt32())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToInt32())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToInt32())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToInt32())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToInt32())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToInt32())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToInt32())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToInt32())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToInt32())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToInt32(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public Int32TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Int32), isRequired: true),
								new ParameterDescription("value2", typeof(Int32), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Int32), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new [] {
						new ParameterDescription("value", typeof(Int32), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class Int64TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Int64TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<long>((_, arguments) => (long)(arguments[0].ToInt64() & arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<long>((_, arguments) => (long)(arguments[0].ToInt64() | arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<long>((_, arguments) => (long)(arguments[0].ToInt64() ^ arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<long>((_, arguments) => (long)unchecked(arguments[0].ToInt64() * arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() * arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<long>((_, arguments) => (long)unchecked(arguments[0].ToInt64() / arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() / arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<long>((_, arguments) => (double)Math.Pow(arguments[0].ToInt64(), arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<long>((_, arguments) => (long)(arguments[0].ToInt64() % arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<long>((_, arguments) => (long)unchecked(arguments[0].ToInt64() + arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() + arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<long>((_, arguments) => (long)unchecked(arguments[0].ToInt64() - arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() - arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() > arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() >= arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() < arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() <= arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() == arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() != arguments[1].ToInt64()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<long>((_, arguments) => (long)unchecked(+arguments[0].ToInt64()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<long>((_, arguments) => (long)unchecked(-arguments[0].ToInt64()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<long>((_, arguments) => (long)checked(-arguments[0].ToInt64()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<long>((_, arguments) => (long)unchecked(~arguments[0].ToInt64()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToInt64())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToInt64())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToInt64())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToInt64())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToInt64())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToInt64())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToInt64())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToInt64())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToInt64())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToInt64())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToInt64())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToInt64())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToInt64(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public Int64TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Int64), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(Int64), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Int64), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new [] {
						new ParameterDescription("value", typeof(Int64), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class Int8TypeDescription : ReflectionTypeDescription
		{
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Int8TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToSByte() & arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToSByte() | arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToSByte() ^ arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToSByte() * arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() * arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToSByte() / arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() / arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToSByte(), arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToSByte() % arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToSByte() + arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() + arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToSByte() - arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() - arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() > arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() >= arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() < arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() <= arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() == arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() != arguments[1].ToSByte()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToSByte()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToSByte()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToSByte()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToSByte()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToSByte())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToSByte())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToSByte())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToSByte())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToSByte())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToSByte())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToSByte())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToSByte())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToSByte())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToSByte())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToSByte())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToSByte())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToSByte(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public Int8TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(SByte), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(SByte), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(SByte), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(SByte), isRequired: true)
					});
			}
		}
	

		private interface INullPropagationExpression
		{
			bool IsNullPropagationEnabled { get; }
		}
	

		private class InvokeExpression : FormulaExpression, INullPropagationExpression
		{
			private readonly IReadOnlyDictionary<string, FormulaExpression> arguments;
			private readonly FormulaExpression expression;
	
			/// <inheritdoc />
			public bool IsNullPropagationEnabled => (this.expression as INullPropagationExpression)?.IsNullPropagationEnabled ?? false;
	
			public InvokeExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.arguments = ExpressionBuildHelper.GetArguments(expressionObj, ExpressionConstants.ARGUMENTS_ATTRIBUTE);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, ExpressionConstants.EXPRESSION_ATTRIBUTE, optional: false);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				string memberName;
				if (!(this.expression is MemberExpression targetMemberExpression))
				{
					// ex. (a + b)(param1, param2)
					return this.ExecutePlainInvoke(context);
				}
				else if (targetMemberExpression.TryGetTypeReferenceAndMemberName(out var typeReference, out memberName) &&
					context.TypeResolver.TryGetTypeDescription(typeReference, out var typeDescriptor))
				{
					// ex. System.Math.Add()
					return this.ExecuteStaticMethod(typeDescriptor, memberName, context);
				}
				if (targetMemberExpression.TryGetExpressionAndMemberName(out var memberExpression, out memberName))
				{
					// ex. my.hello();
					return this.ExecuteInstanceMethod(memberExpression, memberName, context);
				}
				else if (!context.Global.IsNull)
				{
					// ex. hello()
					var globalTypeDescriptor = context.TypeResolver.GetTypeDescription(context.Global.Type);
					if (globalTypeDescriptor.TryGetMember(targetMemberExpression.MemberName, out var memberAccessor))
					{
						return this.ExecuteAnyMethod(context.Global, globalTypeDescriptor, memberAccessor, context);
					}
					else if (globalTypeDescriptor.TryGetStaticMember(targetMemberExpression.MemberName, out memberAccessor))
					{
						return this.ExecuteAnyMethod(VariableValue.Null, globalTypeDescriptor, memberAccessor, context);
					}
				}
	
				return this.ExecutePlainInvoke(context);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				this.expression.BuildDebugView(stringBuilder);
				stringBuilder.Append("(");
				foreach (var argument in this.arguments)
				{
					if (!argument.Key.All(char.IsDigit))
					{
						stringBuilder.Append(argument.Key).Append(": ");
					}
					argument.Value.BuildDebugView(stringBuilder);
					stringBuilder.Append(", ");
				}
	
				if (this.arguments.Count > 0)
				{
					stringBuilder.Length -= 2;
				}
	
				stringBuilder.Append(")");
			}
	
			private VariableValue ExecutePlainInvoke(FormulaExecutionContext context)
			{
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
				var target = this.expression.Execute(context);
				if (target.IsNull)
				{
					if (isNullPropagation)
					{
						return VariableValue.Null;
					}
					else
					{
						throw FormulaException.CantCallOnNull();
					}
				}
				var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(target.Type);
				return this.InvokeDelegate(new VariableValue(target), targetTypeDescriptor, context);
			}
			private VariableValue ExecuteStaticMethod(ITypeDescription targetTypeDescription, string memberName, FormulaExecutionContext context)
			{
				if (!targetTypeDescription.TryGetStaticMember(memberName, out var memberAccessor))
				{
					throw FormulaException.CantFindMember(targetTypeDescription, memberName);
				}
	
				return this.ExecuteAnyMethod(VariableValue.Null, targetTypeDescription, memberAccessor, context);
			}
			private VariableValue ExecuteInstanceMethod(FormulaExpression memberExpression, string memberName, FormulaExecutionContext context)
			{
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
				var target = memberExpression.Execute(context);
				if (target.IsNull)
				{
					if (isNullPropagation)
					{
						return VariableValue.Null;
					}
					else
					{
						throw FormulaException.CantCallOnNull();
					}
				}
	
				var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(target.Type);
				if (!targetTypeDescriptor.TryGetMember(memberName, out var memberAccessor))
				{
					throw FormulaException.CantFindMember(targetTypeDescriptor, memberName);
				}
	
				return this.ExecuteAnyMethod(target, targetTypeDescriptor, memberAccessor, context);
			}
			private VariableValue ExecuteAnyMethod(VariableValue target, ITypeDescription targetTypeDescription, MemberGroup memberAccessor, FormulaExecutionContext context)
			{
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
				if (memberAccessor.GroupType == MemberGroupType.Method)
				{
					return this.InvokeMethod(target, targetTypeDescription, memberAccessor, context, isDelegated: false);
				}
				else
				{
					memberAccessor.TryInvoke(target, callArguments: null, expectedType: null, typeArguments: null,out var delegateValue);
	
					if (delegateValue.IsNull)
					{
						if (isNullPropagation)
						{
							return VariableValue.Null;
						}
						else
						{
							throw FormulaException.CantCallOnNull();
						}
					}
					return this.InvokeDelegate(delegateValue, targetTypeDescription, context);
				}
			}
	
			private VariableValue InvokeDelegate(VariableValue delegateValue, ITypeDescription targetTypeDescription, FormulaExecutionContext context)
			{
				const string DELEGATE_INVOKE_METHOD = "Invoke";
	
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (delegateValue.IsNull) throw new ArgumentNullException(nameof(delegateValue));
	
				var delegateToCall = delegateValue.ToObject() as Delegate;
				if (delegateToCall == null)
				{
					throw FormulaException.UnableToInvokeNonMethodOrDelegate(delegateValue);
				}
	
				var delegateTypeDescriptor = context.TypeResolver.GetTypeDescription(delegateToCall.GetType());
				if (!delegateTypeDescriptor.TryGetMember(DELEGATE_INVOKE_METHOD, out var invokeMethodGroup))
				{
					throw FormulaException.CantFindMember(delegateTypeDescriptor, DELEGATE_INVOKE_METHOD);
				}
	
				return this.InvokeMethod(delegateValue, targetTypeDescription ?? delegateTypeDescriptor, invokeMethodGroup, context, isDelegated: true);
			}
			private VariableValue InvokeMethod(VariableValue target, ITypeDescription targetTypeDescription, MemberGroup memberGroup, FormulaExecutionContext context, bool isDelegated)
			{
				if (memberGroup == null) throw new ArgumentNullException(nameof(memberGroup));
				if (context == null) throw new ArgumentNullException(nameof(context));
	
				var callArguments = new Dictionary<string, VariableValue>();
				foreach (var index in this.arguments)
				{
					callArguments[index.Key] = index.Value.Execute(context);
				}
	
				var typeArguments = isDelegated ? Type.EmptyTypes : this.GetTypeArguments(context);
	
				if (memberGroup.TryInvoke(target, callArguments, expectedType: null, typeArguments, out var result))
				{
					return result;
				}
	
				var name = this.expression is MemberExpression targetMemberExpression ? targetMemberExpression.MemberName : "<unknown>";
				throw FormulaException.UnableToBindMethodToParameters(name, targetTypeDescription, callArguments);
			}
	
			private Type[] GetTypeArguments(FormulaExecutionContext context)
			{
				if (this.expression is MemberExpression targetMemberExpression &&
					targetMemberExpression.TypeArguments.Count > 0)
				{
					var resolvedTypeArguments = new Type[targetMemberExpression.TypeArguments.Count];
					for (var index = 0; index < targetMemberExpression.TypeArguments.Count; index++)
					{
						var typeArgument = targetMemberExpression.TypeArguments[index];
						resolvedTypeArguments[index] = context.TypeResolver.GetTypeDescription(typeArgument).Type;
					}
					return resolvedTypeArguments;
				}
	
				return Type.EmptyTypes;
			}
		}
	

		public interface ITypeDescription
		{
			bool CanBeNull { get; }
			Type Type { get; }
			VariableValue DefaultValue { get; }
	
			bool TryGetConstructors(out MemberGroup constructors);
			bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation);
			bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation);
			bool TryGetMember(string memberName, out MemberGroup memberAccessor);
			bool TryGetStaticMember(string memberName, out MemberGroup memberAccessor);
			bool TryGetIndexer(int rank, out MemberGroup indexAccessor);
			bool TryGetConversionOperation(out MemberGroup convertOperation);
			bool TryGetCheckedConversionOperation(out MemberGroup convertOperation);
		}
	

		public class KnownFormulaTypeResolver : IFormulaTypeResolver
		{
			public static readonly IFormulaTypeResolver Default;
			private static readonly HashSet<Type> BuildInTypes;
	
			private readonly FormulaOptions options;
			private readonly Dictionary<Type, ITypeDescription> typeDescriptions;
			private readonly Dictionary<string, List<Type>> knownTypesByFullName;
			private readonly Dictionary<string, List<Type>> knownTypesByName;
			private readonly HashSet<Type> knownTypes;
			private readonly IFormulaTypeResolver otherTypeResolver;
	
			static KnownFormulaTypeResolver()
			{
				BuildInTypes = new HashSet<Type>
				{
					typeof (object),
					typeof (bool),
					typeof (char),
					typeof (sbyte),
					typeof (byte),
					typeof (short),
					typeof (ushort),
					typeof (int),
					typeof (uint),
					typeof (long),
					typeof (ulong),
					typeof (float),
					typeof (double),
					typeof (decimal),
					typeof (DateTime),
					typeof (TimeSpan),
					typeof (string),
					typeof (Math),
					typeof (Array),
					typeof (Nullable<>),
					typeof (Func<>),
					typeof (Func<,>),
					typeof (Func<,,>),
					typeof (Func<,,,>),
					typeof (Func<,,,,>),
	#if UNITY_EDITOR || UNITY_STANDALONE || UNITY_WII || UNITY_IOS || UNITY_IPHONE || UNITY_ANDROID || UNITY_LUMIN || UNITY_TIZEN || UNITY_TVOS || UNITY_WSA || UNITY_WSA_10_0 || UNITY_WEBGL || UNITY_FACEBOOK
					typeof(UnityEngine.Mathf),
					typeof(UnityEngine.Quaternion),
					typeof(UnityEngine.Vector4),
					typeof(UnityEngine.Vector3),
					typeof(UnityEngine.Vector2),
					typeof(UnityEngine.Color),
					typeof(UnityEngine.Color32),
					typeof(UnityEngine.Matrix4x4),
					typeof(UnityEngine.Plane),
	#endif
				};
				Default = new KnownFormulaTypeResolver(Type.EmptyTypes, FormulaOptions.None);
			}
			public KnownFormulaTypeResolver(IEnumerable<Type> knownTypes, FormulaOptions options, IFormulaTypeResolver otherTypeResolver = null)
			{
				this.knownTypesByFullName = new Dictionary<string, List<Type>>(StringComparer.Ordinal);
				this.knownTypesByName = new Dictionary<string, List<Type>>(StringComparer.Ordinal);
	
				this.otherTypeResolver = otherTypeResolver;
				this.options = options;
				this.typeDescriptions = new Dictionary<Type, ITypeDescription>();
	
				this.knownTypes = new HashSet<Type>(knownTypes ?? Type.EmptyTypes);
				foreach (var buildInType in BuildInTypes)
				{
					this.knownTypes.Add(buildInType);
				}
				foreach (var type in this.knownTypes)
				{
					this.AddKnownType(type);
				}
			}
	
			private void AddKnownType(Type type)
			{
				var typeNames = CSharpNameUtils.GetTypeNames(type);
				if (!string.IsNullOrEmpty(typeNames.Key))
				{
					if (this.knownTypesByName.TryGetValue(typeNames.Key, out var typeList) == false)
					{
						this.knownTypesByName.Add(typeNames.Key, typeList = new List<Type>());
					}
	
					typeList.Add(type);
				}
	
				if (!string.IsNullOrEmpty(typeNames.Value))
				{
					if (this.knownTypesByName.TryGetValue(typeNames.Value, out var typeList) == false)
					{
						this.knownTypesByName.Add(typeNames.Value, typeList = new List<Type>());
					}
	
					typeList.Add(type);
				}
	
				var fullTypeNames = CSharpNameUtils.GetTypeFullNames(type);
				if (!string.IsNullOrEmpty(fullTypeNames.Key))
				{
					if (this.knownTypesByFullName.TryGetValue(fullTypeNames.Key, out var typeList) == false)
					{
						this.knownTypesByFullName.Add(fullTypeNames.Key, typeList = new List<Type>());
					}
	
					typeList.Add(type);
				}
	
				if (!string.IsNullOrEmpty(fullTypeNames.Value))
				{
					if (this.knownTypesByFullName.TryGetValue(fullTypeNames.Value, out var typeList) == false)
					{
						this.knownTypesByFullName.Add(fullTypeNames.Value, typeList = new List<Type>());
					}
	
					typeList.Add(type);
				}
			}
	
			/// <inheritdoc />
			public ITypeDescription GetTypeDescription(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				lock (this.typeDescriptions)
				{
					if (this.typeDescriptions.TryGetValue(type, out var typeDescriptor))
					{
						return typeDescriptor;
					}
	
					this.typeDescriptions[type] = typeDescriptor = this.CreateTypeDescription(type, this.options);
					return typeDescriptor;
				}
			}
			/// <inheritdoc />
			public ITypeDescription GetTypeDescription(TypeReference typeReference)
			{
				if (this.TryGetTypeDescription(typeReference, out var typeDescriptor))
				{
					return typeDescriptor;
				}
	
				throw FormulaException.UnableToResolveType(typeReference);
			}
			/// <inheritdoc />
			public bool TryGetTypeDescription(TypeReference typeReference, out ITypeDescription typeDescription)
			{
				if (typeReference == null) throw new ArgumentNullException(nameof(typeReference));
	
				if (this.TryGetType(typeReference, out var type))
				{
					typeDescription = this.GetTypeDescription(type);
					return true;
				}
	
				if (this.otherTypeResolver != null)
				{
					return this.otherTypeResolver.TryGetTypeDescription(typeReference, out typeDescription);
				}
	
				typeDescription = default;
				return false;
			}
	
			private bool TryGetType(TypeReference typeReference, out Type foundType)
			{
				foundType = default;
	
				var matches = 0;
				var genericTypeRequired = typeReference.TypeArguments.Count > 0;
	
				// search in full names
				if (this.knownTypesByFullName.TryGetValue(typeReference.FullName, out var typesToCheck))
				{
					foreach (var type in typesToCheck)
					{
						var typeInfo = type.GetTypeInfo();
						if (genericTypeRequired != typeInfo.IsGenericType) continue;
						if (genericTypeRequired && typeInfo.GetGenericArguments().Length != typeReference.TypeArguments.Count) continue;
	
						if (foundType != type)  // could be same type
							matches++;
						foundType = type;
					}
				}
	
				// search in short names
				if (this.knownTypesByName.TryGetValue(typeReference.FullName, out typesToCheck))
				{
					foreach (var type in typesToCheck)
					{
						var typeInfo = type.GetTypeInfo();
						if (genericTypeRequired != typeInfo.IsGenericType) continue;
						if (genericTypeRequired && typeInfo.GetGenericArguments().Length != typeReference.TypeArguments.Count) continue;
	
						if (foundType != type) // could be same type
							matches++;
						foundType = type;
					}
				}
	
				// special case for System.Array because it's not generic but TypeReference for Arrays are
				if (foundType == null && (string.Equals(typeReference.FullName, ExpressionConstants.KNOWN_TYPE_SYSTEM_ARRAY, StringComparison.Ordinal) ||
						string.Equals(typeReference.Name, ExpressionConstants.KNOWN_TYPE_ARRAY, StringComparison.Ordinal)))
				{
					foundType = typeof(Array);
					matches = 1;
				}
	
				if (matches != 1)
				{
					foundType = null;
					return false;
				}
	
				if (foundType == typeof(Array) &&
					this.TryMakeArrayType(typeReference, ref foundType))
				{
					return true;
				}
				else if (foundType != null && typeReference.TypeArguments.Count > 0 &&
						this.TryMakeGenericType(typeReference, ref foundType))
				{
					return true;
				}
				return foundType != null;
			}
	
			private bool TryMakeGenericType(TypeReference typeReference, ref Type foundType)
			{
				var genericParameters = default(Type[]);
				var foundTypeInfo = foundType.GetTypeInfo();
				if (foundTypeInfo.IsGenericType &&
					(genericParameters = foundTypeInfo.GetGenericArguments()).Length == typeReference.TypeArguments.Count)
				{
					var typeArguments = new Type[genericParameters.Length];
					var allArgumentBound = true;
					var isOpenType = true;
					for (var i = 0; i < typeArguments.Length; i++)
					{
						var genericArgumentTypeReference = typeReference.TypeArguments[i];
						if (genericArgumentTypeReference.IsEmpty)
						{
							typeArguments[i] = genericParameters[i];
						}
						else if (this.TryGetType(genericArgumentTypeReference, out typeArguments[i]))
						{
							isOpenType = false;
						}
						else
						{
							allArgumentBound = false;
						}
					}
	
					if (!foundTypeInfo.IsGenericTypeDefinition)
					{
						foundType = foundType.GetGenericTypeDefinition() ?? foundType;
					}
	
					if (allArgumentBound)
					{
						foundType = isOpenType ? foundType : foundType.MakeGenericType(typeArguments);
						return true;
					}
				}
	
				foundType = null;
				return false;
			}
			private bool TryMakeArrayType(TypeReference typeReference, ref Type foundType)
			{
				if (typeReference.TypeArguments.Count == 1)
				{
					if (this.TryGetType(typeReference.TypeArguments[0], out var elementType) == false)
					{
						return false;
					}
	
					foundType = elementType.MakeArrayType();
					return true;
				}
				else if (typeReference.TypeArguments.Count == 0)
				{
					return true;
				}
				foundType = null;
				return true;
			}
	
			protected virtual ITypeDescription CreateTypeDescription(Type type, FormulaOptions options)
			{
				if (type.IsArray)
				{
					return new ArrayTypeDescription(type, options);
				}
				else if (type.IsEnum)
				{
					return new EnumTypeDescription(type, options);
				}
				else if (type == typeof(char))
				{
					return new CharTypeDescription(type, options);
				}
				else if (type == typeof(byte))
				{
					return new UInt8TypeDescription(type, options);
				}
				else if (type == typeof(sbyte))
				{
					return new Int8TypeDescription(type, options);
				}
				else if (type == typeof(short))
				{
					return new Int16TypeDescription(type, options);
				}
				else if (type == typeof(ushort))
				{
					return new UInt16TypeDescription(type, options);
				}
				else if (type == typeof(int))
				{
					return new Int32TypeDescription(type, options);
				}
				else if (type == typeof(uint))
				{
					return new UInt32TypeDescription(type, options);
				}
				else if (type == typeof(long))
				{
					return new Int64TypeDescription(type, options);
				}
				else if (type == typeof(ulong))
				{
					return new UInt64TypeDescription(type, options);
				}
				else if (type == typeof(float))
				{
					return new Float32TypeDescription(type, options);
				}
				else if (type == typeof(double))
				{
					return new Float64TypeDescription(type, options);
				}
				else if (type == typeof(bool))
				{
					return new BooleanTypeDescription(type, options);
				}
				else if (type == typeof(object))
				{
					return new ObjectTypeDescription(type, options);
				}
				else if (type == typeof(string))
				{
					return new StringTypeDescription(type, options);
				}
				else if ((typeof(Type).IsAssignableFrom(type) || type.Namespace == typeof(MemberInfo).Namespace) &&
						(options & FormulaOptions.AllowReflectionApi) == 0)
				{
					return new RestrictedReflectionTypeDescription(type, options);
				}
				return new ReflectionTypeDescription(type, options);
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				return $"KnownTypeResolver, Type Count: {this.knownTypes.Count}";
			}
		}
	

		private class LambdaExpression : FormulaExpression
		{
			private readonly FormulaExpression body;
			private readonly KeyValuePair<string, TypeReference>[] arguments;
	
			public LambdaExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.body = ExpressionBuildHelper.GetExpression(expressionObj, ExpressionConstants.EXPRESSION_ATTRIBUTE, optional: false);
	
				var arguments = ExpressionBuildHelper.GetArguments(expressionObj, ExpressionConstants.ARGUMENTS_ATTRIBUTE);
				this.arguments = new KeyValuePair<string, TypeReference>[arguments.Count];
				var argumentIndex = 0;
				foreach (var argumentByIndex in arguments)
				{
					if (argumentByIndex.Value is MemberExpression argumentMember)
					{
						this.arguments[argumentIndex++] = new KeyValuePair<string, TypeReference>(argumentMember.MemberName, null);
						continue;
					}
					throw FormulaException.InvalidLambdaArgument(argumentByIndex.Value);
				}
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var parameters = Array.Empty<KeyValuePair<string, Type>>();
				if (this.arguments.Length > 0)
				{
					parameters = new KeyValuePair<string, Type>[this.arguments.Length];
					for (var index = 0; index < this.arguments.Length; index++)
					{
						var argument = this.arguments[index];
						var parameterType = argument.Value == null ? null : context.TypeResolver.GetTypeDescription(argument.Value).Type;
						parameters[index] = new KeyValuePair<string, Type>(argument.Key, parameterType);
					}
				}
				return new VariableValue(new UnboundLambda(this.body, parameters, context));
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("(");
				foreach (var argument in this.arguments)
				{
					if (argument.Value != null)
					{
						stringBuilder.Append(argument.Value);
						stringBuilder.Append(" ");
					}
					stringBuilder.Append(argument.Key);
					stringBuilder.Append(", ");
				}
				if (this.arguments.Length > 0)
				{
					stringBuilder.Length -= 2;
				}
				stringBuilder.Append(") => ");
				this.body.BuildDebugView(stringBuilder);
			}
		}
	

		private sealed class LambdaFunctions
		{
			public static Func<ResultT> Func<ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 0) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return () =>
				{
					var newContext = new FormulaExecutionContext(context.Arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
			public static Func<Arg1T, ResultT> Func<Arg1T, ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 1) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
			public static Func<Arg1T, Arg2T, ResultT> Func<Arg1T, Arg2T, ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 2) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
			public static Func<Arg1T, Arg2T, Arg3T, ResultT> Func<Arg1T, Arg2T, Arg3T, ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 3) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2, arg3) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
					arguments[parameters[2].Key] = new VariableValue(arg3);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
			public static Func<Arg1T, Arg2T, Arg3T, Arg4T, ResultT> Func<Arg1T, Arg2T, Arg3T, Arg4T, ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 4) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2, arg3, arg4) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
					arguments[parameters[2].Key] = new VariableValue(arg3);
					arguments[parameters[3].Key] = new VariableValue(arg4);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
	
			public static Action Action(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 0) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return () =>
				{
					var newContext = new FormulaExecutionContext(context.Arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
			public static Action<Arg1T> Action<Arg1T>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 1) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
			public static Action<Arg1T, Arg2T> Action<Arg1T, Arg2T>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 2) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
			public static Action<Arg1T, Arg2T, Arg3T> Action<Arg1T, Arg2T, Arg3T>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 3) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2, arg3) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
					arguments[parameters[2].Key] = new VariableValue(arg3);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
			public static Action<Arg1T, Arg2T, Arg3T, Arg4T> Action<Arg1T, Arg2T, Arg3T, Arg4T>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 4) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2, arg3, arg4) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
					arguments[parameters[2].Key] = new VariableValue(arg3);
					arguments[parameters[3].Key] = new VariableValue(arg4);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
	
			private static Dictionary<string, VariableValue> CopyArguments(KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				var arguments = new Dictionary<string, VariableValue>(context.Arguments.Count + parameters.Length);
				foreach (var contextArgument in context.Arguments)
				{
					arguments[contextArgument.Key] = contextArgument.Value;
				}
	
				return arguments;
			}
		}
	

		public sealed class MemberDescription
		{
			private static readonly ParameterDescription[] EmptyParameters = Array.Empty<ParameterDescription>();
			private static readonly GenericConstraint[] EmptyTypeParameters = Array.Empty<GenericConstraint>();
	
			private readonly Func<VariableValue, VariableValue[], VariableValue> invokeFunc;
			private readonly Lazy<Func<VariableValue, VariableValue[], VariableValue>> lazyInvokeFunc;
			private readonly MemberInfo originalMember;
			private readonly FormulaOptions options;
			private readonly Dictionary<TypeTuple, MemberDescription> methodInstantiations; // null for non-MethodInfo members
	
			public IReadOnlyList<GenericConstraint> TypeParameters { get; }
			public IReadOnlyList<ParameterDescription> Parameters { get; }
			public Type ResultType { get; }
			public int RequiredParameterCount { get; }
	
			public MemberDescription
			(
				Func<VariableValue, VariableValue[], VariableValue> invokeFunc,
				Type resultType,
				IReadOnlyList<ParameterDescription> parameters
			)
			{
				if (invokeFunc == null) throw new ArgumentNullException(nameof(invokeFunc));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (parameters.Count > 64) throw new ArgumentOutOfRangeException(nameof(parameters));
	
	
				this.invokeFunc = invokeFunc;
				this.ResultType = resultType;
				this.Parameters = parameters;
				this.RequiredParameterCount = parameters.Count(parameter => parameter.IsRequired);
				this.TypeParameters = EmptyTypeParameters;
			}
			public MemberDescription(MethodBase methodBase, FormulaOptions options)
			{
				if (methodBase == null) throw new ArgumentNullException(nameof(methodBase));
				if (methodBase.DeclaringType == null) throw new ArgumentException("Method should have declaring type.", nameof(methodBase));
	
				this.originalMember = methodBase;
				this.options = options;
				this.Parameters = EmptyParameters;
				this.TypeParameters = EmptyTypeParameters;
	
				var parameters = methodBase.GetParameters();
				if (parameters.Length > 0)
				{
					var parameterDescriptors = new ParameterDescription[parameters.Length];
					for (var parameterIndex = 0; parameterIndex < parameters.Length; parameterIndex++)
					{
						var parameter = parameters[parameterIndex];
						var defaultValue = VariableValue.Null;
						if (parameter.IsOptional)
						{
							if (parameter.HasDefaultValue)
							{
								defaultValue = new VariableValue(parameter.DefaultValue);
							}
							else if (parameter.ParameterType.IsValueType)
							{
								defaultValue = new VariableValue(Activator.CreateInstance(parameter.ParameterType));
							}
							else
							{
								defaultValue = VariableValue.Null;
							}
						}
						parameterDescriptors[parameterIndex] = new ParameterDescription(parameter.Name, parameter.ParameterType, !parameter.IsOptional, defaultValue);
					}
					this.Parameters = parameterDescriptors;
				}
	
				this.ResultType = methodBase is ConstructorInfo constructorInfo ? constructorInfo.DeclaringType : ((MethodInfo)methodBase).ReturnType;
				this.RequiredParameterCount = this.Parameters.Count(parameter => parameter.IsRequired);
	
				if (methodBase is MethodInfo methodInfo && methodInfo.IsGenericMethod && methodInfo.IsGenericMethodDefinition)
				{
					var genericArguments = methodInfo.GetGenericArguments();
					var genericConstraints = new GenericConstraint[genericArguments.Length];
					for (var index = 0; index < genericArguments.Length; index++)
					{
						var genericArgument = genericArguments[index];
						genericConstraints[index] = new GenericConstraint(genericArgument);
					}
	
					this.methodInstantiations = new Dictionary<TypeTuple, MemberDescription>();
					this.TypeParameters = genericConstraints;
					this.invokeFunc = ReflectionMethodInvoke(methodBase, parameters); // will throw exception on invoke
				}
				else
				{
					if ((options & FormulaOptions.UseDynamicMethods) != 0)
					{
						this.lazyInvokeFunc = new Lazy<Func<VariableValue, VariableValue[], VariableValue>>(() => ExpressionMethodInvoke(methodBase, parameters), LazyThreadSafetyMode.ExecutionAndPublication);
					}
					else
					{
						this.invokeFunc = ReflectionMethodInvoke(methodBase, parameters);
					}
				}
	
			}
			public MemberDescription(FieldInfo fieldInfo, FormulaOptions options)
			{
				if (fieldInfo == null) throw new ArgumentNullException(nameof(fieldInfo));
				if (fieldInfo.DeclaringType == null) throw new ArgumentException("Field should have declaring type.", nameof(fieldInfo));
	
				this.originalMember = fieldInfo;
				this.options = options;
				this.Parameters = EmptyParameters;
				this.RequiredParameterCount = 0;
				this.TypeParameters = EmptyTypeParameters;
	
				if ((options & FormulaOptions.UseDynamicMethods) != 0)
				{
					this.lazyInvokeFunc = new Lazy<Func<VariableValue, VariableValue[], VariableValue>>(() => ExpressionFieldGet(fieldInfo), LazyThreadSafetyMode.ExecutionAndPublication);
				}
				else
				{
					this.invokeFunc = ReflectionFieldGet(fieldInfo);
				}
			}
			public MemberDescription(PropertyInfo propertyInfo, FormulaOptions options)
			{
				if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));
				if (propertyInfo.DeclaringType == null) throw new ArgumentException("Property should have declaring type.", nameof(propertyInfo));
	
				this.originalMember = propertyInfo;
				this.options = options;
				this.Parameters = EmptyParameters;
				this.RequiredParameterCount = 0;
				this.TypeParameters = EmptyTypeParameters;
	
				if ((options & FormulaOptions.UseDynamicMethods) != 0)
				{
					this.lazyInvokeFunc = new Lazy<Func<VariableValue, VariableValue[], VariableValue>>(() => ExpressionPropertyGet(propertyInfo), LazyThreadSafetyMode.ExecutionAndPublication);
				}
				else
				{
					this.invokeFunc = ReflectionPropertyGet(propertyInfo);
				}
			}
	
			private static Func<VariableValue, VariableValue[], VariableValue> ReflectionFieldGet(FieldInfo fieldInfo)
			{
				if (fieldInfo == null) throw new ArgumentNullException(nameof(fieldInfo));
	
				return (target, _) =>
				{
					try
					{
						var targetObj = fieldInfo.IsStatic || target.IsNull ? null : target.ToType(fieldInfo.DeclaringType);
						var result = fieldInfo.GetValue(targetObj);
						return new VariableValue(result);
					}
					catch (TargetInvocationException te)
					{
						if (te.InnerException == null)
						{
							throw;
						}
	#if !NET35 && !NET20
						var exceptionDispatchInfo = System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture(te.InnerException);
						exceptionDispatchInfo.Throw();
	#endif
						throw te.InnerException;
					}
				};
			}
			private static Func<VariableValue, VariableValue[], VariableValue> ExpressionFieldGet(FieldInfo fieldInfo)
			{
				if (fieldInfo == null) throw new ArgumentNullException(nameof(fieldInfo));
	
				var target = Expression.Parameter(typeof(VariableValue), "target");
				var arguments = Expression.Parameter(typeof(VariableValue), "arguments");
	
				return Expression.Lambda<Func<VariableValue, VariableValue[], VariableValue>>(
					body: VariableValue.ToVariableValueExpression(
						Expression.Field(
							VariableValue.FromVariableValueExpression(target, fieldInfo.DeclaringType),
							fieldInfo
						)),
					parameters: new[] { target, arguments },
					name: "Get" + GetMemberName(fieldInfo) + "WithVariableValuesCall"
				).Compile();
			}
	
			private static Func<VariableValue, VariableValue[], VariableValue> ReflectionPropertyGet(PropertyInfo propertyInfo)
			{
				if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));
	
				return (target, _) =>
				{
					try
					{
						var targetObj = (propertyInfo.GetMethod?.IsStatic).GetValueOrDefault() || target.IsNull ? null : target.ToType(propertyInfo.DeclaringType);
						var result = propertyInfo.GetValue(targetObj);
						return new VariableValue(result);
					}
					catch (TargetInvocationException te)
					{
						if (te.InnerException == null)
						{
							throw;
						}
	#if !NET35 && !NET20
						var exceptionDispatchInfo = System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture(te.InnerException);
						exceptionDispatchInfo.Throw();
	#endif
						throw te.InnerException;
					}
				};
			}
			private static Func<VariableValue, VariableValue[], VariableValue> ExpressionPropertyGet(PropertyInfo propertyInfo)
			{
				if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));
	
				var target = Expression.Parameter(typeof(VariableValue), "target");
				var arguments = Expression.Parameter(typeof(VariableValue), "arguments");
	
				return Expression.Lambda<Func<VariableValue, VariableValue[], VariableValue>>(
					body: VariableValue.ToVariableValueExpression(
						Expression.Property(
							VariableValue.FromVariableValueExpression(target, propertyInfo.DeclaringType),
							propertyInfo
						)),
					parameters: new[] { target, arguments },
					name: "Get" + GetMemberName(propertyInfo) + "WithVariableValuesCall"
				).Compile();
			}
	
			private static Func<VariableValue, VariableValue[], VariableValue> ReflectionMethodInvoke(MethodBase methodBase, ParameterInfo[] parameters)
			{
				if (methodBase == null) throw new ArgumentNullException(nameof(methodBase));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
	
				var isStatic = methodBase is MethodInfo methodInfo && methodInfo.IsStatic;
				return (target, arguments) =>
				{
					try
					{
						var argumentList = new object[arguments.Length];
						for (var i = 0; i < arguments.Length; i++)
						{
							argumentList[i] = arguments[i].ToType(parameters[i].ParameterType);
						}
	
						if (methodBase is ConstructorInfo constructorInfo)
						{
							var result = constructorInfo.Invoke(argumentList);
							return new VariableValue(result);
						}
						else
						{
							var targetObj = isStatic || target.IsNull ? null : target.ToType(methodBase.DeclaringType);
							var result = methodBase.Invoke(targetObj, argumentList);
							return new VariableValue(result);
						}
					}
					catch (TargetInvocationException te)
					{
						if (te.InnerException == null)
						{
							throw;
						}
	#if !NET35 && !NET20
						var exceptionDispatchInfo = System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture(te.InnerException);
						exceptionDispatchInfo.Throw();
	#endif
						throw te.InnerException;
					}
				};
			}
			private static Func<VariableValue, VariableValue[], VariableValue> ExpressionMethodInvoke(MethodBase methodBase, ParameterInfo[] parameters)
			{
				if (methodBase == null) throw new ArgumentNullException(nameof(methodBase));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
	
				var target = Expression.Parameter(typeof(VariableValue), "target");
				var arguments = Expression.Parameter(typeof(VariableValue[]), "arguments");
	
				var argumentExpressions = new Expression[parameters.Length];
				for (var argumentIndex = 0; argumentIndex < argumentExpressions.Length; argumentIndex++)
				{
					argumentExpressions[argumentIndex] = VariableValue.FromVariableValueExpression(
						Expression.ArrayIndex(arguments, Expression.Constant(argumentIndex)),
						parameters[argumentIndex].ParameterType
					);
				}
	
				if (methodBase is ConstructorInfo constructorInfo)
				{
					return Expression.Lambda<Func<VariableValue, VariableValue[], VariableValue>>(
						body: VariableValue.ToVariableValueExpression(
							Expression.New(
								constructorInfo,
								argumentExpressions
							)),
						parameters: new[] { target, arguments },
						name: "Invoke" + constructorInfo.Name + "WithVariableValuesCall"
					).Compile();
				}
				else
				{
					return Expression.Lambda<Func<VariableValue, VariableValue[], VariableValue>>(
						body: VariableValue.ToVariableValueExpression(
							Expression.Call(
								VariableValue.FromVariableValueExpression(target, parameters[0].ParameterType),
								(MethodInfo)methodBase,
								argumentExpressions
							)),
						parameters: new[] { target, arguments },
						name: "Invoke" + GetMemberName(methodBase) + "WithVariableValuesCall"
					).Compile();
				}
			}
	
			private static string GetMemberName(MemberInfo member)
			{
				if (member == null) throw new ArgumentNullException(nameof(member));
	
				return (member.DeclaringType?.FullName + "." + member.Name).Replace(".", "_");
			}
	
			public VariableValue Invoke(VariableValue target, VariableValue[] arguments)
			{
				if (this.invokeFunc != null)
				{
					return this.invokeFunc(target, arguments);
				}
				else
				{
					return this.lazyInvokeFunc.Value(target, arguments);
				}
			}
	
			public MemberDescription MakeGenericMethod(Type[] typeArguments)
			{
				if (typeArguments == null) throw new ArgumentNullException(nameof(typeArguments));
				if (!(this.originalMember is MethodInfo info)) throw new InvalidOperationException($"Can't instantiate not method '{this.originalMember}'.");
				if (this.TypeParameters.Count <= 0) throw new InvalidOperationException($"Can't instantiate non-generic method '{this.originalMember}'.");
	
				var key = new TypeTuple(typeArguments);
				var instantiatedMethodDescription = default(MemberDescription);
				lock (this.methodInstantiations)
				{
					if (this.methodInstantiations.TryGetValue(key, out instantiatedMethodDescription))
						return instantiatedMethodDescription;
	
					var instantiatedMethod = info.MakeGenericMethod(typeArguments);
					instantiatedMethodDescription = new MemberDescription(instantiatedMethod, this.options);
					this.methodInstantiations[key] = instantiatedMethodDescription;
				}
				return instantiatedMethodDescription;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				var memberRef = this.originalMember != null ? GetMemberName(this.originalMember) : this.invokeFunc.Method.ToString();
				var parameters = string.Join(", ", this.Parameters.Select(p => p.ParameterType.Name));
	
				return $"({parameters}) -> {this.ResultType.Name}, Member: {memberRef}";
			}
	
		}
	

		private class MemberExpression : FormulaExpression, INullPropagationExpression
		{
			private readonly bool useNullPropagation;
			private readonly FormulaExpression expression;
			private TypeReference skipSelfTypeReference;
			private TypeReference typeReference;
	
			/// <inheritdoc />
			public bool IsNullPropagationEnabled
			{
				get
				{
					if (this.useNullPropagation)
					{
						return true;
					}
	
					return (this.expression as INullPropagationExpression)?.IsNullPropagationEnabled ?? false;
				}
			}
			public string MemberName { get; }
			public IReadOnlyList<TypeReference> TypeArguments { get; }
	
			public MemberExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.MemberName = ExpressionBuildHelper.GetString(expressionObj, ExpressionConstants.PROPERTY_OR_FIELD_NAME_ATTRIBUTE, optional: true) ??
					ExpressionBuildHelper.GetString(expressionObj, ExpressionConstants.NAME_ATTRIBUTE, optional: false);
				this.TypeArguments = ExpressionBuildHelper.GetTypeRefArguments(expressionObj, ExpressionConstants.ARGUMENTS_ATTRIBUTE);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, ExpressionConstants.EXPRESSION_ATTRIBUTE, optional: true);
				this.useNullPropagation = ExpressionBuildHelper.GetBoolean(expressionObj, ExpressionConstants.USE_NULL_PROPAGATION_ATTRIBUTE, optional: true)
					.GetValueOrDefault();
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
	
				if (this.TryGetTypeReferenceAndMemberName(out var typeReference, out var memberName) &&
					context.TypeResolver.TryGetTypeDescription(typeReference, out var typeDescriptor) &&
					typeDescriptor.TryGetStaticMember(memberName, out var memberAccessor))
				{
					memberAccessor.TryInvoke(VariableValue.Null, callArguments: null, expectedType: null, typeArguments: null, out var result);
					return result;
				}
				else if (this.expression != null)
				{
					var target = this.expression.Execute(context);
					if (target.IsNull)
					{
						if (isNullPropagation)
						{
							return VariableValue.Null;
						}
	
						throw FormulaException.CantAccessMemberOnNull(this.MemberName);
					}
	
					var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(target.Type);
					if (this.TryGetMemberValue(targetTypeDescriptor, target, out var memberValue))
					{
						return memberValue;
					}
					throw FormulaException.CantFindMember(targetTypeDescriptor, this.MemberName);
				}
				else if (this.MemberName == ExpressionConstants.NOTATION_TRUE_STRING)
				{
					return true;
				}
				else if (this.MemberName == ExpressionConstants.NOTATION_FALSE_STRING)
				{
					return false;
				}
				else if (this.MemberName == ExpressionConstants.NOTATION_NULL_STRING)
				{
					return VariableValue.Null;
				}
				else if (context.Arguments.TryGetValue(this.MemberName, out var argumentValue))
				{
					return argumentValue;
				}
				else if (!context.Global.IsNull &&
						this.TryGetMemberValue(context.TypeResolver.GetTypeDescription(context.Global.Type), context.Global, out var globalMemberValue))
				{
					return globalMemberValue;
				}
				else
				{
					throw FormulaException.UnableToResolveGlobalName(this.MemberName);
				}
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				if (this.expression != null)
				{
					this.expression.BuildDebugView(stringBuilder);
					if (this.useNullPropagation)
					{
						stringBuilder.Append("?");
					}
					stringBuilder.Append(".");
				}
				stringBuilder.Append(this.MemberName);
				if (this.TypeArguments != null && this.TypeArguments.Count > 0)
				{
					stringBuilder.Append("<");
					foreach (var typeArgument in this.TypeArguments)
					{
						stringBuilder.Append(typeArgument);
						stringBuilder.Append(", ");
					}
					stringBuilder.Length -= 2;
					stringBuilder.Append(">");
				}
			}
	
			public bool TryGetExpressionAndMemberName(out FormulaExpression expression, out string memberName)
			{
				if (this.expression != null)
				{
					memberName = this.MemberName;
					expression = this.expression;
					return true;
				}
				else
				{
					expression = default;
					memberName = default;
					return false;
				}
			}
	
			public bool TryGetTypeReferenceAndMemberName(out TypeReference typeReference, out string memberName)
			{
				if (this.TryGetTypeReference(out typeReference, skipSelf: true))
				{
					memberName = this.MemberName;
					return true;
				}
	
				memberName = default;
				return false;
			}
			private bool TryGetTypeReference(out TypeReference typeReference, bool skipSelf = false)
			{
				if (skipSelf && this.skipSelfTypeReference != null)
				{
					typeReference = this.skipSelfTypeReference;
					return true;
				}
				else if (!skipSelf && this.typeReference != null)
				{
					typeReference = this.typeReference;
					return true;
				}
	
				if (this.useNullPropagation)
				{
					typeReference = default;
					return false; // null propagation ?. is not type reference
				}
	
				var baseTypeReference = default(TypeReference);
				if (this.expression != null && !(this.expression is MemberExpression))
				{
					typeReference = default;
					return false; // base expression is not member expression
				}
	
				if (this.expression != null && ((MemberExpression)this.expression).TryGetTypeReference(out baseTypeReference, skipSelf: false) == false)
				{
					typeReference = default;
					return false; // base expression is not a type reference
				}
	
				if (skipSelf)
				{
					this.skipSelfTypeReference = typeReference = baseTypeReference;
				}
				else
				{
					this.typeReference = typeReference = new TypeReference(this.MemberName, this.TypeArguments, baseTypeReference);
				}
				return typeReference != null;
			}
	
			private bool TryGetMemberValue(ITypeDescription targetTypeDescription, VariableValue target, out VariableValue memberValue)
			{
				if (targetTypeDescription == null) throw new ArgumentNullException(nameof(targetTypeDescription));
	
				if (!targetTypeDescription.TryGetMember(this.MemberName, out var memberDescriptor))
				{
					memberValue = default;
					return false;
				}
	
				if (memberDescriptor.GroupType == MemberGroupType.Method ||
					memberDescriptor.GroupType == MemberGroupType.Constructor)
				{
					throw FormulaException.CanAccessMethodOrConstructorGroup(this.MemberName, targetTypeDescription);
				}
	
				// TODO wrap errors for better message
				return memberDescriptor.TryInvoke(target, callArguments: null, expectedType: null, typeArguments: null, out memberValue);
			}
		}
	

		public sealed class MemberGroup
		{
			private enum ParameterMatchQuality { None, Coerced, Cast, Exact }
			private static readonly Dictionary<string, VariableValue> EmptyArguments = new Dictionary<string, VariableValue>();
	
			private static readonly string[] PositionNumbers = Enumerable.Range(0, 64).Select(p => p.ToString()).ToArray();
	
			private readonly IReadOnlyList<MemberDescription> members;
	
			public MemberGroupType GroupType { get; }
	
			public MemberGroup(MemberGroupType groupType, IReadOnlyList<MemberDescription> members)
			{
				if (members == null) throw new ArgumentNullException(nameof(members));
	
				this.members = members;
				this.GroupType = groupType;
			}
	
			public bool TryInvoke(VariableValue target, Dictionary<string, VariableValue> callArguments, Type expectedType, Type[] typeArguments, out VariableValue result)
			{
				callArguments = callArguments ?? EmptyArguments;
				typeArguments = typeArguments ?? Type.EmptyTypes;
	
				var bestMatchMethod = MatchMember(this.members, callArguments, expectedType, typeArguments, out var argumentOrder);
				if (bestMatchMethod == null || !TryPrepareArguments(bestMatchMethod, callArguments, argumentOrder, out var arguments))
				{
					result = default;
					return false;
				}
	
				result = bestMatchMethod.Invoke(target, arguments);
				return true;
			}
	
			private static MemberDescription MatchMember(IReadOnlyList<MemberDescription> members, Dictionary<string, VariableValue> callArguments, Type expectedType, Type[] typeArguments, out string[] argumentOrder)
			{
				if (members == null) throw new ArgumentNullException(nameof(members));
				if (callArguments == null) throw new ArgumentNullException(nameof(callArguments));
	
				argumentOrder = PositionNumbers;
	
				var bestMatchMethod = default(MemberDescription);
				var bestMatchParametersQuality = ParameterMatchQuality.Coerced;
				var bestMatchResultQuality = ParameterMatchQuality.Coerced;
	
				for (var index = 0; index < members.Count; index++)
				{
					var method = members[index];
					if (method.RequiredParameterCount > callArguments.Count)
					{
						continue;
					}
	
					if (method.TypeParameters.Count != typeArguments.Length ||
						!AreMatching(method.TypeParameters, typeArguments))
					{
						continue;
					}
	
					if (method.TypeParameters.Count > 0)
					{
						method = method.MakeGenericMethod(typeArguments);
					}
	
					if (!TryBindParameters(method, callArguments, out var argumentsOrder, out var parametersQuality))
					{
						continue;
					}
	
					var resultQuality = ParameterMatchQuality.Exact;
					if (expectedType != null && !TryMatchResultType(method.ResultType, expectedType, out resultQuality))
					{
						continue;
					}
	
					if (resultQuality < bestMatchResultQuality || parametersQuality < bestMatchParametersQuality)
					{
						continue;
					}
	
					bestMatchMethod = method;
					argumentOrder = argumentsOrder;
					bestMatchParametersQuality = parametersQuality;
					bestMatchResultQuality = resultQuality;
				}
	
				return bestMatchMethod;
			}
	
			private static bool TryBindParameters(MemberDescription member, Dictionary<string, VariableValue> callArguments, out string[] argumentOrder, out ParameterMatchQuality quality)
			{
				var parameterCount = member.Parameters.Count;
				if (parameterCount == 0 && callArguments.Count == 0)
				{
					argumentOrder = PositionNumbers;
					quality = ParameterMatchQuality.Exact;
					return true;
				}
	
				for (var parameterIndex = 0; parameterIndex < callArguments.Count; parameterIndex++)
				{
					var parameterName = GetIndexAsString(parameterIndex);
					if (!callArguments.ContainsKey(parameterName))
					{
						return TryBindMixedParameters(member, callArguments, out argumentOrder, out quality);
					}
				}
				return TryBindPositionalParameters(member, callArguments, out argumentOrder, out quality);
			}
			private static bool TryBindPositionalParameters(MemberDescription member, Dictionary<string, VariableValue> callArguments, out string[] parameterOrder, out ParameterMatchQuality quality)
			{
				var parameterCount = member.Parameters.Count;
	
				parameterOrder = PositionNumbers;
				quality = ParameterMatchQuality.Exact;
	
				// bind positional parameters
				for (var parameterIndex = 0; parameterIndex < parameterCount; parameterIndex++)
				{
					var parameter = member.Parameters[parameterIndex];
					var parameterType = parameter.ParameterType;
					var parameterName = GetIndexAsString(parameterIndex);
	
					if (!callArguments.TryGetValue(parameterName, out var parameterValue) &&
						!TryGetDefaultValue(parameter, ref parameterValue))
					{
						quality = ParameterMatchQuality.None;
						return false; // unable to find parameter
					}
	
					if (parameterValue.Type == parameterType)
					{
						quality = MinQuality(quality, ParameterMatchQuality.Exact);
					}
					else if (TryCastValue(parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Cast);
					}
					else if (TryCoercePrimitive(ref parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Coerced);
					}
					else
					{
						quality = ParameterMatchQuality.None;
						return false;  // unable to bind parameter by type
					}
				}
	
				return true;
			}
			private static bool TryBindMixedParameters(MemberDescription member, Dictionary<string, VariableValue> callArguments, out string[] parameterOrder, out ParameterMatchQuality quality)
			{
				var parameterCount = member.Parameters.Count;
				var boundArguments = 0UL;
				var parameterValue = default(VariableValue);
	
				parameterOrder = new string[parameterCount];
				quality = ParameterMatchQuality.Exact;
	
				// bind named arguments
				for (var parameterIndex = 0; parameterIndex < parameterCount; parameterIndex++)
				{
					var parameter = member.Parameters[parameterIndex];
					var parameterName = parameter.Name;
					if (callArguments.TryGetValue(parameterName, out parameterValue))
					{
						boundArguments |= 1UL << parameterIndex;
						parameterOrder[parameterIndex] = parameterName;
					}
					else
					{
						continue;
					}
	
					var parameterType = parameter.ParameterType;
					if (parameterValue.Type == parameterType)
					{
						quality = MinQuality(quality, ParameterMatchQuality.Exact);
					}
					else if (TryCastValue(parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Cast);
					}
					else if (TryCoercePrimitive(ref parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Coerced);
					}
					else
					{
						quality = ParameterMatchQuality.None;
						return false;  // unable to bind parameter by type
					}
				}
	
				// bind positional parameters
				var lastPositionIndex = 0;
				for (var parameterIndex = 0; parameterIndex < parameterCount; parameterIndex++)
				{
					var parameter = member.Parameters[parameterIndex];
	
					if ((boundArguments & 1UL << parameterIndex) != 0)
					{
						continue; // already bound
					}
	
					if ((boundArguments & 1UL << parameterIndex) == 0) // try to bind by position
					{
						while (lastPositionIndex < parameterCount)
						{
							var parameterName = GetIndexAsString(lastPositionIndex++);
							if (callArguments.TryGetValue(parameterName, out parameterValue))
							{
								boundArguments |= 1UL << parameterIndex;
								parameterOrder[parameterIndex] = parameterName;
								break;
							}
						}
					}
	
					if ((boundArguments & 1UL << parameterIndex) == 0 &&
						!TryGetDefaultValue(parameter, ref parameterValue))
					{
						return false; // required and not bound by position and not bound by name
					}
	
	
					var parameterType = member.Parameters[parameterIndex].ParameterType;
					if (parameterValue.Type == parameterType)
					{
						quality = MinQuality(quality, ParameterMatchQuality.Exact);
					}
					else if (TryCastValue(parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Cast);
					}
					else if (TryCoercePrimitive(ref parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Coerced);
					}
					else
					{
						quality = ParameterMatchQuality.None;
						return false;  // unable to bind parameter by type
					}
				}
	
				return true;
			}
			private static bool TryPrepareArguments(MemberDescription member, Dictionary<string, VariableValue> callArguments, string[] parameterOrder, out VariableValue[] arguments)
			{
				var parameterCount = member.Parameters.Count;
				arguments = new VariableValue[parameterCount];
				for (var parameterIndex = 0; parameterIndex < parameterCount; parameterIndex++)
				{
					var parameterName = parameterIndex < parameterOrder.Length ? parameterOrder[parameterIndex] : string.Empty;
					var parameter = member.Parameters[parameterIndex];
					var parameterType = parameter.ParameterType;
					if (!(callArguments.TryGetValue(parameterName, out var parameterValue) || TryGetDefaultValue(parameter, ref parameterValue)) ||
							!TryCastValue(parameterValue, parameterType) &&
							!TryCoercePrimitive(ref parameterValue, parameterType) &&
							!TryBindLambda(ref parameterValue, parameterType))
					{
						return false;
					}
	
					arguments[parameterIndex] = parameterValue;
				}
	
				return true;
			}
			private static bool TryGetDefaultValue(ParameterDescription parameter, ref VariableValue parameterValue)
			{
				if (parameter.IsRequired)
				{
					return false;
				}
	
				parameterValue = parameter.DefaultValue;
				return true;
			}
	
			private static bool TryBindLambda(ref VariableValue parameterValue, Type parameterType)
			{
				if (parameterValue.Type != typeof(UnboundLambda) ||
					!typeof(Delegate).IsAssignableFrom(parameterType))
				{
					return false;
				}
	
				var unboundLambdaExpression = (UnboundLambda)parameterValue.ToObject();
				parameterValue = new VariableValue(unboundLambdaExpression.BindTo(parameterType));
				return true;
			}
			private static bool TryCoercePrimitive(ref VariableValue parameterValue, Type parameterType)
			{
				if (parameterValue.IsNull)
				{
					return false;
				}
	
				var expectedTypeCode = TypeCodes.GetTypeCode(parameterType);
				if (parameterValue.TypeCode == expectedTypeCode)
				{
					return true;
				}
	
				if (parameterValue.TypeCode == expectedTypeCode)
				{
					return true;
				}
	
				if (!parameterValue.CanFitInto(expectedTypeCode))
				{
					return false;
				}
	
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (expectedTypeCode)
				{
					case TypeCode.Boolean: parameterValue = parameterValue.ToBoolean(); return true;
					case TypeCode.Char: parameterValue = parameterValue.ToChar(); return true;
					case TypeCode.SByte: parameterValue = parameterValue.ToSByte(); return true;
					case TypeCode.Byte: parameterValue = parameterValue.ToByte(); return true;
					case TypeCode.Int16: parameterValue = parameterValue.ToInt16(); return true;
					case TypeCode.UInt16: parameterValue = parameterValue.ToUInt16(); return true;
					case TypeCode.Int32: parameterValue = parameterValue.ToInt32(); return true;
					case TypeCode.UInt32: parameterValue = parameterValue.ToUInt32(); return true;
					case TypeCode.Int64: parameterValue = parameterValue.ToInt64(); return true;
					case TypeCode.UInt64: parameterValue = parameterValue.ToUInt64(); return true;
					case TypeCode.Single: parameterValue = parameterValue.ToSingle(); return true;
					case TypeCode.Double: parameterValue = parameterValue.ToDouble(); return true;
					case TypeCode.Decimal: parameterValue = parameterValue.ToDecimal(); return true;
					default: return false;
				}
			}
			private static bool TryCastValue(VariableValue parameterValue, Type parameterType)
			{
				if (parameterType == typeof(object))
				{
					return true;
				}
				if (parameterValue.IsNull && (!parameterType.IsValueType || IsNullableType(parameterType)))
				{
					return true;
				}
	
				if (parameterValue.Type == typeof(UnboundLambda) &&
					typeof(Delegate).IsAssignableFrom(parameterType))
				{
					return ((UnboundLambda)parameterValue.ToObject()).IsSignatureMatching(parameterType);
				}
	
				return parameterType.IsAssignableFrom(parameterValue.Type);
			}
			private static bool TryMatchResultType(Type resultType, Type expectedResultType, out ParameterMatchQuality quality)
			{
				if (resultType == expectedResultType)
				{
					quality = ParameterMatchQuality.Exact;
					return true;
				}
				else if (expectedResultType.IsAssignableFrom(resultType))
				{
					quality = ParameterMatchQuality.Cast;
					return true;
				}
	
				var resultTypeCode = TypeCodes.GetTypeCode(resultType);
				var expectedResultTypeCode = TypeCodes.GetTypeCode(expectedResultType);
				if (TypeCodes.CanCoerceNumberLike(expectedResultTypeCode, resultTypeCode))
				{
					quality = ParameterMatchQuality.Coerced;
					return true;
				}
	
				quality = default;
				return false;
			}
			private static bool IsNullableType(Type parameterType)
			{
				return Nullable.GetUnderlyingType(parameterType) != null;
			}
			private static bool AreMatching(IReadOnlyList<GenericConstraint> typeParameters, Type[] typeArguments)
			{
				if (typeParameters == null) throw new ArgumentNullException(nameof(typeParameters));
				if (typeParameters.Count != typeArguments.Length) throw new ArgumentOutOfRangeException(nameof(typeArguments));
	
				for (var index = 0; index < typeParameters.Count; index++)
				{
					if (typeParameters[index].IsMatching(typeArguments[index]) == false)
					{
						return false;
					}
				}
	
				return true;
			}
			private static string GetIndexAsString(int index)
			{
				if (index >= 0 && index < 64)
				{
					return PositionNumbers[index];
				}
				return index.ToString();
			}
	
			private static ParameterMatchQuality MinQuality(ParameterMatchQuality value1, ParameterMatchQuality value2)
			{
				return value1 < value2 ? value1 : value2;
			}
			/// <inheritdoc />
			public override string ToString()
			{
				return "MemberGroup, Members: " + string.Join("\r\n\t", this.members.Select(member => member.ToString()).ToArray());
			}
		}
	

		public enum MemberGroupType
		{
			Field,
			Property,
			Constructor,
			Method
		}
	

		private class NewArrayBoundExpression : FormulaExpression
		{
			private readonly IReadOnlyDictionary<string, FormulaExpression> arguments;
			private readonly TypeReference type;
	
			public NewArrayBoundExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.arguments = ExpressionBuildHelper.GetArguments(expressionObj, ExpressionConstants.ARGUMENTS_ATTRIBUTE);
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, ExpressionConstants.TYPE_ATTRIBUTE, optional: false);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
				var arrayTypeDescription = context.TypeResolver.GetTypeDescription(typeDescription.Type.MakeArrayType(this.arguments.Count));
	
				var constructorArguments = new Dictionary<string, VariableValue>();
				foreach (var index in this.arguments)
				{
					constructorArguments[index.Key] = index.Value.Execute(context);
				}
	
				if (arrayTypeDescription.TryGetConstructors(out var constructors) &&
					constructors.TryInvoke(VariableValue.Null, constructorArguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
	
				throw FormulaException.UnableToBindConstructorToParameters(typeDescription, constructorArguments);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append(this.type);
				stringBuilder.Length -= 2;
				stringBuilder.Append("[");
				foreach (var argument in this.arguments)
				{
					argument.Value.BuildDebugView(stringBuilder);
					stringBuilder.Append(", ");
				}
				if (this.arguments.Count > 0)
				{
					stringBuilder.Length -= 2;
				}
				stringBuilder.Append("]");
			}
		}
	

		private class NewExpression : FormulaExpression
		{
			private readonly IReadOnlyDictionary<string, FormulaExpression> arguments;
			private readonly TypeReference type;
	
			public NewExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.arguments = ExpressionBuildHelper.GetArguments(expressionObj, ExpressionConstants.ARGUMENTS_ATTRIBUTE);
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, ExpressionConstants.TYPE_ATTRIBUTE, optional: false);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
	
				if (this.arguments.Count == 1 &&
					this.arguments.Values.First() is LambdaExpression lambdaExpression &&
					typeof(Delegate).IsAssignableFrom(typeDescription.Type))
				{
					return this.ExecuteLambdaConstructor(context, typeDescription, lambdaExpression);
				}
				else
				{
					return this.ExecuteConstructor(context, typeDescription);
				}
			}
	
			private VariableValue ExecuteLambdaConstructor(FormulaExecutionContext context, ITypeDescription typeDescription, LambdaExpression lambdaExpression)
			{
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (typeDescription == null) throw new ArgumentNullException(nameof(typeDescription));
				if (lambdaExpression == null) throw new ArgumentNullException(nameof(lambdaExpression));
	
				var unboundLambdaValue = lambdaExpression.Execute(context);
				var unboundLambda = (UnboundLambda)unboundLambdaValue.ToObject();
				var boundLambda = unboundLambda.BindTo(typeDescription.Type);
				return new VariableValue(boundLambda);
			}
	
			private VariableValue ExecuteConstructor(FormulaExecutionContext context, ITypeDescription typeDescription)
			{
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (typeDescription == null) throw new ArgumentNullException(nameof(typeDescription));
	
				var constructorArguments = new Dictionary<string, VariableValue>();
				foreach (var index in this.arguments)
				{
					constructorArguments[index.Key] = index.Value.Execute(context);
				}
	
				if (typeDescription.TryGetConstructors(out var constructors) &&
					constructors.TryInvoke(VariableValue.Null, constructorArguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
	
				throw FormulaException.UnableToBindConstructorToParameters(typeDescription, constructorArguments);
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("new ").Append(this.type).Append("(");
				stringBuilder.Append("(");
				foreach (var argument in this.arguments)
				{
					if (!argument.Key.All(char.IsDigit))
					{
						stringBuilder.Append(argument.Key).Append(": ");
					}
					argument.Value.BuildDebugView(stringBuilder);
					stringBuilder.Append(", ");
				}
	
				if (this.arguments.Count > 0)
				{
					stringBuilder.Length -= 2;
				}
	
				stringBuilder.Append(")");
			}
		}
	

		private sealed class ObjectTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
	
			static ObjectTypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToObject() == arguments[1].ToObject()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToObject() != arguments[1].ToObject()));
			}
			/// <inheritdoc />
			public ObjectTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Object), isRequired: true),
								new ParameterDescription("value2", typeof(Object), isRequired: true)
							})
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		public sealed class ParameterDescription
		{
			public Type ParameterType { get; }
			public string Name { get; }
			public bool IsRequired { get; }
			public VariableValue DefaultValue { get; }
	
			public ParameterDescription(string name, Type parameterType, bool isRequired, VariableValue defaultValue = default)
			{
				if (name == null) throw new ArgumentNullException(nameof(name));
				if (parameterType == null) throw new ArgumentNullException(nameof(parameterType));
				if (string.IsNullOrEmpty(name)) throw new ArgumentException("Value cannot be null or empty.", nameof(name));
	
				this.ParameterType = parameterType;
				this.IsRequired = isRequired;
				this.DefaultValue = defaultValue;
				this.Name = name;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				return $"Parameter, Name: {this.Name}, Type: {this.ParameterType}, Required: {this.IsRequired}, Default Value: {this.DefaultValue}";
			}
		}
	

		private class ReflectionTypeDescription : ITypeDescription
		{
			private readonly Lazy<MemberGroup> lazyConstructors;
			private readonly Lazy<Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>>> lazyAllMembers;
			private readonly Lazy<Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>>> lazyAllStaticMembers;
			private readonly Lazy<Dictionary<bool, Lazy<MemberGroup>>> lazyConvertMethods;
	
			/// <inheritdoc />
			public bool CanBeNull { get; }
			/// <inheritdoc />
			public Type Type { get; }
			/// <inheritdoc />
			public VariableValue DefaultValue { get; }
	
			public ReflectionTypeDescription(Type type, FormulaOptions options)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				this.CanBeNull = !type.IsValueType || Nullable.GetUnderlyingType(type) != null;
				this.Type = type;
				this.DefaultValue = type.IsValueType ? new VariableValue(Activator.CreateInstance(type)) : VariableValue.Null;
	
				this.lazyAllMembers = new Lazy<Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>>>(
					() => GetAllMembers(type, BindingFlags.Instance | BindingFlags.Public, options),
					LazyThreadSafetyMode.ExecutionAndPublication
				);
				this.lazyAllStaticMembers = new Lazy<Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>>>(
					() => GetAllMembers(type, BindingFlags.Static | BindingFlags.Public, options),
					LazyThreadSafetyMode.ExecutionAndPublication
				);
				this.lazyConstructors = new Lazy<MemberGroup>(
					() => GetConstructors(type, options),
					LazyThreadSafetyMode.ExecutionAndPublication
				);
				this.lazyConvertMethods = new Lazy<Dictionary<bool, Lazy<MemberGroup>>>(
					() => GetConvertMethods(type, options),
					LazyThreadSafetyMode.ExecutionAndPublication
				);
			}
	
			/// <inheritdoc />
			public virtual bool TryGetConstructors(out MemberGroup constructors)
			{
				constructors = this.lazyConstructors.Value;
				return constructors != null;
			}
			/// <inheritdoc />
			public virtual bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				string methodName;
				switch (operationType)
				{
					case BinaryOperationType.And: methodName = "op_BitwiseAnd"; break;
					case BinaryOperationType.Or: methodName = "op_BitwiseOr"; break;
					case BinaryOperationType.ExclusiveOr: methodName = "op_ExclusiveOr"; break;
					case BinaryOperationType.Multiply: methodName = "op_Multiply"; break;
					case BinaryOperationType.MultiplyChecked: methodName = "op_CheckedMultiply"; break;
					case BinaryOperationType.Divide: methodName = "op_Division"; break;
					case BinaryOperationType.DivideChecked: methodName = "op_CheckedDivision"; break;
					case BinaryOperationType.Power: methodName = ""; break;
					case BinaryOperationType.Modulo: methodName = "op_Modulus"; break;
					case BinaryOperationType.Add: methodName = "op_Addition"; break;
					case BinaryOperationType.AddChecked: methodName = "op_CheckedAddition"; break;
					case BinaryOperationType.Subtract: methodName = "op_Subtraction"; break;
					case BinaryOperationType.SubtractChecked: methodName = "op_CheckedSubtraction"; break;
					case BinaryOperationType.LeftShift: methodName = "op_Multiply"; break;
					case BinaryOperationType.RightShift: methodName = "op_RightShift"; break;
					case BinaryOperationType.GreaterThan: methodName = "op_GreaterThan"; break;
					case BinaryOperationType.GreaterThanOrEqual: methodName = "op_GreaterThanOrEqual"; break;
					case BinaryOperationType.LessThan: methodName = "op_LessThan"; break;
					case BinaryOperationType.LessThanOrEqual: methodName = "op_LessThanOrEqual"; break;
					case BinaryOperationType.Equal: methodName = "op_Equality"; break;
					case BinaryOperationType.NotEqual: methodName = "op_Inequality"; break;
					case BinaryOperationType.AndAlso: methodName = ""; break;
					case BinaryOperationType.OrElse: methodName = ""; break;
					case BinaryOperationType.Coalesce: methodName = ""; break;
					default: throw new ArgumentOutOfRangeException(nameof(operationType), operationType, null);
				}
	
				if (!string.IsNullOrEmpty(methodName) &&
					this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
					memberGroupsByName.TryGetValue(methodName, out var lazyMemberGroup))
				{
					binaryOperation = lazyMemberGroup.Value;
					return true;
				}
	
				binaryOperation = null;
				return false;
			}
			/// <inheritdoc />
			public virtual bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				string methodName;
				switch (operationType)
				{
					case UnaryOperationType.UnaryPlus: methodName = "op_UnaryPlus"; break;
					case UnaryOperationType.Negate: methodName = "op_UnaryNegation"; break;
					case UnaryOperationType.NegateChecked: methodName = "op_CheckedUnaryNegation"; break;
					case UnaryOperationType.Not: methodName = "op_LogicalNot"; break;
					case UnaryOperationType.Complement: methodName = "op_OnesComplement"; break;
					case UnaryOperationType.UncheckedScope: methodName = ""; break;
					case UnaryOperationType.CheckedScope: methodName = ""; break;
					case UnaryOperationType.Group: methodName = ""; break;
					default: throw new ArgumentOutOfRangeException(nameof(operationType), operationType, null);
				}
	
				if (!string.IsNullOrEmpty(methodName) &&
					this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
					memberGroupsByName.TryGetValue(methodName, out var lazyMemberGroup))
				{
					unaryOperation = lazyMemberGroup.Value;
					return true;
				}
	
				unaryOperation = null;
				return false;
			}
			/// <inheritdoc />
			public virtual bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				var methodName = "get_Item";
	
				if (!string.IsNullOrEmpty(methodName) &&
					this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
					memberGroupsByName.TryGetValue(methodName, out var lazyMemberGroup))
				{
					indexAccessor = lazyMemberGroup.Value;
					return true;
				}
	
				indexAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public virtual bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				if (this.lazyConvertMethods.Value.TryGetValue( /*checked scope*/ false, out var lazyMemberGroup))
				{
					convertOperation = lazyMemberGroup.Value;
					return true;
				}
				else
				{
					convertOperation = null;
					return false;
				}
			}
			/// <inheritdoc />
			public virtual bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				if (this.lazyConvertMethods.Value.TryGetValue( /*checked scope*/ true, out var lazyMemberGroup))
				{
					convertOperation = lazyMemberGroup.Value;
					return true;
				}
				else
				{
					convertOperation = null;
					return false;
				}
			}
			/// <inheritdoc />
			public virtual bool TryGetMember(string memberName, out MemberGroup memberAccessor)
			{
				if (memberName == null) throw new ArgumentNullException(nameof(memberName));
	
				if (string.IsNullOrEmpty(memberName))
				{
					memberAccessor = null;
					return false;
				}
	
				if (this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
					memberGroupsByName.TryGetValue(memberName, out var lazyMemberGroup) ||
					this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Field, out memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out lazyMemberGroup) ||
					this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Property, out memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out lazyMemberGroup))
				{
					memberAccessor = lazyMemberGroup.Value;
					return true;
				}
	
				memberAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public virtual bool TryGetStaticMember(string memberName, out MemberGroup memberAccessor)
			{
				if (string.IsNullOrEmpty(memberName))
				{
					memberAccessor = null;
					return false;
				}
	
				if (this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out var lazyMemberGroup) ||
						this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Field, out memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out lazyMemberGroup) ||
						this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Property, out memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out lazyMemberGroup))
				{
					memberAccessor = lazyMemberGroup.Value;
					return true;
				}
	
				memberAccessor = null;
				return false;
			}
	
			private static Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>> GetAllMembers(Type type, BindingFlags bindingFlags, FormulaOptions options)
			{
				return type
					.GetMembers(bindingFlags)
					.Where(memberInfo => !HasByRefLikeAttribute(memberInfo) && HasGetter(memberInfo))
					.ToLookup(MapToGroupType)
					.Where(group => group.Key != null)
					.ToDictionary(
						group => group.Key.GetValueOrDefault(),
						group => group
							.ToLookup(member => member.Name)
							.ToDictionary(
								members => members.Key,
								members => new Lazy<MemberGroup>(() => GroupMembers(members.ToList(), options), LazyThreadSafetyMode.ExecutionAndPublication)));
			}
	
			private static MemberGroup GroupMembers(List<MemberInfo> members, FormulaOptions options)
			{
				if (members == null) throw new ArgumentNullException(nameof(members));
	
				var memberDescriptors = new List<MemberDescription>(members.Count);
				var groupType = default(MemberGroupType?);
				foreach (var memberInfo in members)
				{
					groupType = MapToGroupType(memberInfo);
					if (memberInfo is ConstructorInfo constructorInfo)
					{
						memberDescriptors.Add(new MemberDescription(constructorInfo, options));
					}
					else if (memberInfo is MethodBase methodBase)
					{
						memberDescriptors.Add(new MemberDescription(methodBase, options));
					}
					else if (memberInfo is PropertyInfo propertyInfo)
					{
						memberDescriptors.Add(new MemberDescription(propertyInfo, options));
					}
					else if (memberInfo is FieldInfo fieldInfo)
					{
						memberDescriptors.Add(new MemberDescription(fieldInfo, options));
					}
				}
				if (groupType == null)
				{
					throw new InvalidOperationException("Member group doesn't contains any members.");
				}
				return new MemberGroup(groupType.Value, memberDescriptors);
			}
			private static MemberGroup GetConstructors(Type type, FormulaOptions options)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				var constructors = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public)
					.Where(constructorInfo => !HasByRefLikeAttribute(constructorInfo))
					.Select(member => (MemberInfo)member)
					.ToList();
				if (constructors.Count == 0)
				{
					return null;
				}
				return GroupMembers(constructors, options);
			}
			private static Dictionary<bool, Lazy<MemberGroup>> GetConvertMethods(Type type, FormulaOptions options)
			{
				var allMethods = type
					.GetMethods(BindingFlags.Public | BindingFlags.Static)
					.Where(methodInfo => !HasByRefLikeAttribute(methodInfo));
	
				var checkedConvertMethods = new List<MemberInfo>(10);
				var uncheckedConvertMethods = new List<MemberInfo>(10);
	
				foreach (var method in allMethods)
				{
					if (method.Name == "op_CheckedImplicit" || method.Name == "op_CheckedExplicit")
					{
						checkedConvertMethods.Add(method);
					}
					else if (method.Name == "op_Implicit" || method.Name == "op_Explicit")
					{
						checkedConvertMethods.Add(method);
						uncheckedConvertMethods.Add(method);
					}
				}
	
				var convertOperations = new Dictionary<bool, Lazy<MemberGroup>>();
				if (checkedConvertMethods.Count > 0)
				{
					convertOperations[true] = new Lazy<MemberGroup>(() => GroupMembers(checkedConvertMethods, options), LazyThreadSafetyMode.ExecutionAndPublication);
				}
				if (uncheckedConvertMethods.Count > 0)
				{
					convertOperations[false] = new Lazy<MemberGroup>(() => GroupMembers(uncheckedConvertMethods, options), LazyThreadSafetyMode.ExecutionAndPublication);
				}
				return convertOperations;
			}
	
			private static MemberGroupType? MapToGroupType(MemberInfo memberInfo)
			{
				if (memberInfo is ConstructorInfo)
				{
					return MemberGroupType.Constructor;
				}
				else if (memberInfo is MethodBase)
				{
					return MemberGroupType.Method;
				}
				else if (memberInfo is PropertyInfo)
				{
					return MemberGroupType.Property;
				}
				else if (memberInfo is FieldInfo)
				{
					return MemberGroupType.Field;
				}
				else
				{
					return null;
				}
			}
	
			private static bool HasByRefLikeAttribute(MethodBase methodBase)
			{
				if (methodBase is MethodInfo methodInfo)
				{
					return HasByRefLikeAttribute(methodInfo.ReturnParameter?.ParameterType) ||
						methodInfo.GetParameters().Any(HasByRefLikeAttribute);
				}
				else
				{
					return methodBase.GetParameters().Any(HasByRefLikeAttribute);
				}
			}
			private static bool HasByRefLikeAttribute(ParameterInfo parameterInfo)
			{
				if (parameterInfo.Member.Name == "ToString" && parameterInfo.Position == -1 /* return value */)
				{
					return false; // fix for https://github.com/mono/mono/issues/17192
				}
				return HasByRefLikeAttribute(parameterInfo.ParameterType);
			}
			private static bool HasByRefLikeAttribute(Type type)
			{
				if (type == null) return false;
				return type.GetTypeInfo().GetCustomAttributes(inherit: true).Any(attribute => IsByRefLikeAttributeType(attribute.GetType()));
			}
			private static bool HasByRefLikeAttribute(MemberInfo memberInfo)
			{
				if (memberInfo is MethodBase methodBase)
				{
					return HasByRefLikeAttribute(methodBase);
				}
				else if (memberInfo is PropertyInfo propertyInfo)
				{
					return HasByRefLikeAttribute(propertyInfo.PropertyType);
				}
				else if (memberInfo is FieldInfo fieldInfo)
				{
					return HasByRefLikeAttribute(fieldInfo.FieldType);
				}
				return false;
			}
			private static bool IsByRefLikeAttributeType(Type attributeType)
			{
				return string.Equals(attributeType.Namespace, "System.Runtime.CompilerServices", StringComparison.Ordinal) &&
					string.Equals(attributeType.Name, "IsByRefLikeAttribute", StringComparison.Ordinal);
			}
			private static bool HasGetter(MemberInfo memberInfo)
			{
				return !(memberInfo is PropertyInfo propertyInfo) || propertyInfo.GetMethod != null;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				return CSharpNameUtils.GetCSharpFullNameWithGenerics(this.Type);
			}
		}
	

		private sealed class RestrictedReflectionTypeDescription : ReflectionTypeDescription
		{
			public RestrictedReflectionTypeDescription(Type type, FormulaOptions options)
				: base(type, options)
			{
	
			}
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				if (operationType == BinaryOperationType.Equal || operationType == BinaryOperationType.NotEqual)
				{
					return base.TryGetBinaryOperation(operationType, out binaryOperation);
				}
				binaryOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConstructors(out MemberGroup constructors)
			{
				constructors = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetMember(string memberName, out MemberGroup memberAccessor)
			{
				if (memberName == nameof(this.Type.Name) ||
					memberName == nameof(this.Type.Namespace) ||
					memberName == nameof(this.Type.FullName))
				{
					return base.TryGetMember(memberName, out memberAccessor);
				}
	
				memberAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetStaticMember(string memberName, out MemberGroup memberAccessor)
			{
				memberAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				unaryOperation = default;
				return false;
			}
		}
	

		private sealed class StringTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup IndexAccessor;
	
			static StringTypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<String>((_, arguments) => (arguments[0].ToString() + arguments[1].ToString()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<String>((_, arguments) => (arguments[0].ToString() + arguments[1].ToString()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].IsNull == arguments[1].IsNull && string.Equals(arguments[0].ToString(), arguments[1].ToString(), StringComparison.Ordinal)));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].IsNull != arguments[1].IsNull || !string.Equals(arguments[0].ToString(), arguments[1].ToString(), StringComparison.Ordinal)));
	
				IndexAccessor = new MemberGroup(MemberGroupType.Method, new[] {
					new MemberDescription(
						invokeFunc: (stringValue, indexes) => ((string)stringValue.ToObject())[indexes[0].ToInt32()],
						resultType: typeof(char),
						new []{ new ParameterDescription("index", typeof(int), isRequired: true, defaultValue: VariableValue.Null) }
					)
				});
			}
			/// <inheritdoc />
			public StringTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = IndexAccessor;
				return true;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(String), isRequired: true),
								new ParameterDescription("value2", typeof(String), isRequired: true)
							})
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class TypeCodes
		{
			public const TypeCode TIME_SPAN_CODE = (TypeCode)20;
	
			public static TypeCode GetTypeCode(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				if (type == typeof(TimeSpan))
				{
					return TIME_SPAN_CODE;
				}
				else if (type.IsEnum)
				{
					// there is a b_u_g in some Mono implementation then GetTypeCode(enumType) gives TypeCode.Object instead of type code of underlying type
					return Type.GetTypeCode(Enum.GetUnderlyingType(type));
				}
				else
				{
					return Type.GetTypeCode(type);
				}
			}
	
			public static bool CanCoerceNumberLike(TypeCode toTypeCode, TypeCode fromTypeCode)
			{
				const int DOUBLE_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Double;
				const int DECIMAL_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Decimal;
				const int SINGLE_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double;
				const int BYTE_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Byte | 1 << (int)TypeCode.UInt16 | 1 << (int)TypeCode.Int16 | 1 << (int)TypeCode.UInt32 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int CHAR_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Char | 1 << (int)TypeCode.UInt16 | 1 << (int)TypeCode.UInt32 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int UINT16_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.UInt16 | 1 << (int)TypeCode.UInt32 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int UINT32_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.UInt32 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int UINT64_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int SBYTE_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.SByte | 1 << (int)TypeCode.Int16 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int INT16_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Int16 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int INT32_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int INT64_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
	
	
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (fromTypeCode)
				{
					case TypeCode.Char: return (CHAR_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.SByte: return (SBYTE_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Byte: return (BYTE_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Int16: return (INT16_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.UInt16: return (UINT16_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Int32: return (INT32_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.UInt32: return (UINT32_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Int64: return (INT64_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.UInt64: return (UINT64_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Single: return (SINGLE_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Double: return (DOUBLE_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Decimal: return (DECIMAL_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					default: return false;
				}
			}
	
			public static bool IsInteger(TypeCode typeCode)
			{
				return typeCode == TypeCode.Byte ||
					typeCode == TypeCode.SByte ||
					typeCode == TypeCode.Int16 ||
					typeCode == TypeCode.UInt16 ||
					typeCode == TypeCode.Int32 ||
					typeCode == TypeCode.UInt32 ||
					typeCode == TypeCode.Int64 ||
					typeCode == TypeCode.UInt64;
			}
			public static bool IsNumberLike(TypeCode typeCode)
			{
				return IsFloat(typeCode) || IsInteger(typeCode) || typeCode == TypeCode.Decimal || typeCode == TypeCode.Char;
			}
			public static bool IsFloat(TypeCode typeCode)
			{
				return typeCode == TypeCode.Single || typeCode == TypeCode.Double;
			}
			public static bool IsSignedInteger(TypeCode typeCode)
			{
				return typeCode == TypeCode.SByte || typeCode == TypeCode.Int16 || typeCode == TypeCode.Int32 || typeCode == TypeCode.Int64;
			}
			public static bool IsUnsignedInteger(TypeCode typeCode)
			{
				return typeCode == TypeCode.Byte || typeCode == TypeCode.UInt16 || typeCode == TypeCode.UInt32 || typeCode == TypeCode.UInt64;
			}
			public static TypeCode MakeUnsigned(TypeCode typeCode)
			{
				switch (typeCode)
				{
					case TypeCode.UInt64: return TypeCode.UInt64;
					case TypeCode.UInt32: return TypeCode.UInt32;
					case TypeCode.UInt16: return TypeCode.UInt16;
					case TypeCode.Int64: return TypeCode.UInt64;
					case TypeCode.Int32: return TypeCode.UInt32;
					case TypeCode.Int16: return TypeCode.UInt16;
					case TypeCode.Byte: return TypeCode.Byte;
					case TypeCode.SByte: return TypeCode.Byte;
					case TypeCode.Boolean:
					case TypeCode.Char:
					case TypeCode.DateTime:
					case TypeCode.DBNull:
					case TypeCode.Decimal:
					case TypeCode.Double:
					case TypeCode.Empty:
					case TypeCode.Object:
					case TypeCode.Single:
					case TypeCode.String:
					default: throw new ArgumentOutOfRangeException(nameof(typeCode), typeCode, null);
				}
			}
		}
	

		private sealed class TypeIsExpression : FormulaExpression
		{
			private readonly TypeReference type;
			private readonly FormulaExpression expression;
	
			public TypeIsExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, ExpressionConstants.TYPE_ATTRIBUTE, optional: false);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, ExpressionConstants.EXPRESSION_ATTRIBUTE);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var target = this.expression.Execute(context);
				var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
				return typeDescription.Type.IsAssignableFrom(target.Type);
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				this.expression.BuildDebugView(stringBuilder);
				stringBuilder.Append(" is ").Append(this.type);
			}
		}
	

		private sealed class TypeOfExpression : FormulaExpression
		{
			private readonly TypeReference type;
	
			public TypeOfExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, ExpressionConstants.TYPE_ATTRIBUTE, optional: false);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
				return new VariableValue(typeDescription.Type);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("typeof(").Append(this.type).Append(")");
			}
		}
	

		public sealed class TypeReference
		{
			public static readonly TypeReference Empty = new TypeReference(string.Empty, null, null);
			private static readonly IReadOnlyList<TypeReference> EmptyTypeReferences = Array.Empty<TypeReference>();
	
			private readonly TypeReference expression;
			private readonly IReadOnlyList<TypeReference> typeArguments;
			private string fullName;
			private string displayName;
	
			public string Name { get; }
			public string FullName => this.fullName ?? (this.fullName = this.GetFullName());
			public IReadOnlyList<TypeReference> TypeArguments => this.typeArguments;
			public bool IsEmpty => string.IsNullOrEmpty(this.Name) && this.expression == null && this.typeArguments.Count == 0;
	
			public TypeReference(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.Name = ExpressionBuildHelper.GetString(expressionObj, ExpressionConstants.NAME_ATTRIBUTE);
				this.expression = ExpressionBuildHelper.GetTypeRef(expressionObj, ExpressionConstants.EXPRESSION_ATTRIBUTE, optional: true);
				this.typeArguments = ExpressionBuildHelper.GetTypeRefArguments(expressionObj, ExpressionConstants.ARGUMENTS_ATTRIBUTE);
	
				if (this.expression != null && this.expression.TypeArguments.Count > 0)
				{
					this.typeArguments = this.expression.TypeArguments.Concat(this.typeArguments).ToArray();
				}
	
				this.displayName = string.Empty;
			}
			public TypeReference(string name, IReadOnlyList<TypeReference> typeArguments = null, TypeReference baseTypeReference = null)
			{
				if (name == null) throw new ArgumentNullException(nameof(name));
	
				this.Name = name;
				this.typeArguments = typeArguments ?? EmptyTypeReferences;
				this.expression = baseTypeReference;
	
				if (this.expression != null && this.expression.TypeArguments.Count > 0)
				{
					this.typeArguments = this.expression.TypeArguments.Concat(this.typeArguments).ToArray();
				}
			}
			public TypeReference(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				if (type.IsArray)
				{
					this.Name = nameof(Array);
					this.expression = new TypeReference(typeof(Array).Namespace);
					this.typeArguments = new[] {
						new TypeReference(type.GetElementType() ?? typeof(object))
					};
				}
				else
				{
					this.Name = type.Name;
					this.typeArguments = EmptyTypeReferences;
	
					if (type.DeclaringType != null)
					{
						this.expression = new TypeReference(type.DeclaringType);
					}
					else if (!string.IsNullOrEmpty(type.Namespace))
					{
						this.expression = new TypeReference(type.Namespace);
					}
	
					if (type.IsGenericType)
					{
						var genericArguments = type.GetGenericArguments();
						if (type.IsGenericTypeDefinition)
						{
							this.typeArguments = Array.ConvertAll(genericArguments, _ => Empty);
						}
						else
						{
							this.typeArguments = Array.ConvertAll(genericArguments, genericArgument => new TypeReference(genericArgument));
						}
					}
				}
			}
	
			private StringBuilder BuildFullName(StringBuilder nameBuilder, bool writeGenerics)
			{
				if (nameBuilder == null) throw new ArgumentNullException(nameof(nameBuilder));
	
				if (this.expression != null)
				{
					this.expression.BuildFullName(nameBuilder, writeGenerics);
					nameBuilder.Append(".");
				}
	
				nameBuilder.Append(this.Name);
				if (this.typeArguments.Count > 0 && writeGenerics)
				{
					nameBuilder.Append("<");
					foreach (var genericArgument in this.typeArguments)
					{
						genericArgument.BuildFullName(nameBuilder, writeGenerics = true);
						nameBuilder.Append(", ");
					}
					nameBuilder.Length -= 2;
					nameBuilder.Append(">");
				}
				return nameBuilder;
			}
	
			private string GetFullName()
			{
				return this.BuildFullName(new StringBuilder(), writeGenerics: false).ToString();
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				if (this.typeArguments.Count == 0 &&
					this.expression == null)
				{
					if (ExpressionConstants.SystemTypes.TryGetValue(this.Name, out var systemTypeName) ||
						ExpressionConstants.TypeAliases.TryGetValue(this.Name, out systemTypeName))
					{
						return systemTypeName;
					}
	
					return this.Name;
				}
				else if (!string.IsNullOrEmpty(this.displayName))
				{
					return this.displayName;
				}
				else if (this.expression == null && this.Name == ExpressionConstants.KNOWN_TYPE_ARRAY && this.typeArguments.Count == 1)
				{
					return this.displayName = this.typeArguments[0] + "[]";
				}
				else
				{
					var nameBuilder = this.BuildFullName(new StringBuilder(), writeGenerics: true);
					return this.displayName = nameBuilder.ToString();
				}
			}
		}
	

		private readonly struct TypeTuple : IEquatable<TypeTuple>
		{
			private readonly int hashCode;
	
			public readonly Type[] Types;
	
			public TypeTuple(params Type[] types)
			{
				if (types == null) throw new ArgumentNullException(nameof(types));
	
				this.Types = types;
	
				unchecked
				{
					this.hashCode = 17;
					foreach (var type in types)
					{
						if (type == null) throw new ArgumentException("One of array's element is null.", nameof(types));
	
						this.hashCode = this.hashCode * 23 + type.GetHashCode();
					}
				}
			}
	
			public bool Equals(TypeTuple other)
			{
				if (this.Types == other.Types) return true;
				if (this.Types == null || other.Types == null) return false;
				if (this.Types.Length != other.Types.Length) return false;
	
				for (var i = 0; i < this.Types.Length; i++)
					if (this.Types[i] != other.Types[i])
						return false;
				return true;
			}
			public override int GetHashCode()
			{
				return this.hashCode;
			}
			public override bool Equals(object obj)
			{
				if (obj is TypeTuple tuple)
				{
					return this.Equals(tuple);
				}
				return false;
			}
	
			public override string ToString()
			{
				if (this.Types != null)
				{
					var sb = new System.Text.StringBuilder();
					foreach (var type in this.Types)
						sb.Append(type.Name).Append(", ");
					if (sb.Length > 2)
						sb.Length -= 2;
					return sb.ToString();
				}
				else
					return "empty";
			}
		}
	

		private sealed class UInt16TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static UInt16TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToUInt16() & arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToUInt16() | arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToUInt16() ^ arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToUInt16() * arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() * arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToUInt16() / arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() / arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToUInt16(), arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToUInt16() % arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToUInt16() + arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() + arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToUInt16() - arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() - arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() > arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() >= arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() < arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() <= arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() == arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() != arguments[1].ToUInt16()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToUInt16()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToUInt16()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToUInt16()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToUInt16()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToUInt16())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToUInt16())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToUInt16())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToUInt16())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToUInt16())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToUInt16())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToUInt16())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToUInt16())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToUInt16())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToUInt16())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToUInt16())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToUInt16())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToUInt16(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public UInt16TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(UInt16), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(UInt16), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(UInt16), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value1", typeof(UInt16), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class UInt32TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static UInt32TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<uint>((_, arguments) => (uint)(arguments[0].ToUInt32() & arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<uint>((_, arguments) => (uint)(arguments[0].ToUInt32() | arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<uint>((_, arguments) => (uint)(arguments[0].ToUInt32() ^ arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<uint>((_, arguments) => (uint)unchecked(arguments[0].ToUInt32() * arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<uint>((_, arguments) => (int)checked(arguments[0].ToUInt32() * arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<uint>((_, arguments) => (uint)unchecked(arguments[0].ToUInt32() / arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() / arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<uint>((_, arguments) => (double)Math.Pow(arguments[0].ToUInt32(), arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<uint>((_, arguments) => (uint)(arguments[0].ToUInt32() % arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<uint>((_, arguments) => (uint)unchecked(arguments[0].ToUInt32() + arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() + arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<uint>((_, arguments) => (uint)unchecked(arguments[0].ToUInt32() - arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() - arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() > arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() >= arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() < arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() <= arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() == arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() != arguments[1].ToUInt32()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<uint>((_, arguments) => (uint)unchecked(+arguments[0].ToUInt32()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<long>((_, arguments) => (long)unchecked(-arguments[0].ToUInt32()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<long>((_, arguments) => (long)checked(-arguments[0].ToUInt32()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<uint>((_, arguments) => (uint)unchecked(~arguments[0].ToUInt32()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToUInt32())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToUInt32())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToUInt32())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToUInt32())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToUInt32())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToUInt32())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToUInt32())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToUInt32())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToUInt32())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToUInt32())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToUInt32())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToUInt32())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToUInt32(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public UInt32TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(UInt32), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(UInt32), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(UInt32), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(UInt32), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class UInt64TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static UInt64TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)(arguments[0].ToUInt64() & arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)(arguments[0].ToUInt64() | arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)(arguments[0].ToUInt64() ^ arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)unchecked(arguments[0].ToUInt64() * arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<ulong>((_, arguments) => (int)checked(arguments[0].ToUInt64() * arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)unchecked(arguments[0].ToUInt64() / arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<ulong>((_, arguments) => (uint)checked(arguments[0].ToUInt64() / arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<ulong>((_, arguments) => (double)Math.Pow(arguments[0].ToUInt64(), arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)(arguments[0].ToUInt64() % arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)unchecked(arguments[0].ToUInt64() + arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)checked(arguments[0].ToUInt64() + arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)unchecked(arguments[0].ToUInt64() - arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)checked(arguments[0].ToUInt64() - arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)checked(arguments[0].ToUInt64() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)checked(arguments[0].ToUInt64() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() > arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() >= arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() < arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() <= arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() == arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() != arguments[1].ToUInt64()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<ulong>((_, arguments) => (ulong)unchecked(+arguments[0].ToUInt64()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<uint>((_, arguments) => (ulong)unchecked(~arguments[0].ToUInt64()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToUInt64())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToUInt64())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToUInt64())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToUInt64())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToUInt64())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToUInt64())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToUInt64())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToUInt64())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToUInt64())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToUInt64())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToUInt64())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToUInt64())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToUInt64(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public UInt64TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(UInt64), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(UInt64), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(UInt64), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(UInt64), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class UInt8TypeDescription : ReflectionTypeDescription
		{
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static UInt8TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToByte() & arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToByte() | arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToByte() ^ arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToByte() * arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() * arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToByte() / arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() / arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToByte(), arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToByte() % arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToByte() + arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() + arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToByte() - arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() - arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() > arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() >= arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() < arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() <= arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() == arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() != arguments[1].ToByte()));
				// ReSharper enable RedundantOverflowCheckingContext
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToByte()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToByte()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToByte()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToByte()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToByte())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToByte())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToByte())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToByte())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToByte())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToByte())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToByte())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToByte())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToByte())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToByte())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToByte())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToByte())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToByte(uncheckedConversion: true))),
				});
			}
			/// <inheritdoc />
			public UInt8TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Byte), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(Byte), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Byte), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(Byte), isRequired: true)
					});
			}
		}
	

		private class UnaryExpression : FormulaExpression
		{
			private readonly FormulaExpression expression;
			private readonly UnaryOperationType unaryOperationType;
			private readonly UnaryOperationType fallbackUnaryOperationType;
	
			public UnaryExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, ExpressionConstants.EXPRESSION_ATTRIBUTE);
	
				var expressionType = ExpressionBuildHelper.GetString(expressionObj, ExpressionConstants.EXPRESSION_TYPE_ATTRIBUTE);
				this.unaryOperationType = MapUnaryOperationType(expressionType);
	
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (this.unaryOperationType)
				{
					case UnaryOperationType.NegateChecked: this.fallbackUnaryOperationType = UnaryOperationType.Negate; break;
					default: this.fallbackUnaryOperationType = this.unaryOperationType; break;
				}
			}
	
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var operand = this.expression.Execute(context);
				if (operand.IsNull)
				{
					return VariableValue.Null;
				}
	
				switch (this.unaryOperationType)
				{
					case UnaryOperationType.Group:
					case UnaryOperationType.UncheckedScope:
					case UnaryOperationType.CheckedScope: return operand;
					case UnaryOperationType.UnaryPlus:
					case UnaryOperationType.Negate:
					case UnaryOperationType.NegateChecked:
					case UnaryOperationType.Not:
					case UnaryOperationType.Complement: break;
					default: throw FormulaException.UnknownUnaryExpression(this.unaryOperationType.ToString());
				}
	
				var arguments = new Dictionary<string, VariableValue> {
					{ "0", operand }
				};
	
				var leftValueType = context.TypeResolver.GetTypeDescription(operand.Type);
				if (leftValueType.TryGetUnaryOperation(this.unaryOperationType, out var binaryOperation) &&
					binaryOperation.TryInvoke(VariableValue.Null, arguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
				else if (this.fallbackUnaryOperationType != this.unaryOperationType && // try fallback unary operation
						leftValueType.TryGetUnaryOperation(this.fallbackUnaryOperationType, out binaryOperation) &&
						binaryOperation.TryInvoke(VariableValue.Null, arguments, expectedType: null, typeArguments: null, out result))
				{
					return result;
				}
				throw FormulaException.MissingUnaryOperation(this.unaryOperationType, operand);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				var enclose = !(this.expression is ConstantExpression);
				switch (this.unaryOperationType)
				{
					case UnaryOperationType.UnaryPlus: stringBuilder.Append("+"); break;
					case UnaryOperationType.Negate:
					case UnaryOperationType.NegateChecked: stringBuilder.Append("-"); break;
					case UnaryOperationType.Not: stringBuilder.Append("!"); break;
					case UnaryOperationType.Complement: stringBuilder.Append("~"); break;
					case UnaryOperationType.UncheckedScope:
						enclose = true;
						stringBuilder.Append("unchecked");
						break;
					case UnaryOperationType.CheckedScope:
						enclose = true;
						stringBuilder.Append("checked");
						break;
					case UnaryOperationType.Group:
						enclose = true;
						break;
					default: stringBuilder.Append(this.unaryOperationType); break;
				}
				if (enclose)
				{
					stringBuilder.Append("(");
				}
				this.expression.BuildDebugView(stringBuilder);
				if (enclose)
				{
					stringBuilder.Append(")");
				}
			}
	
			private static UnaryOperationType MapUnaryOperationType(string expressionType)
			{
				UnaryOperationType unaryOperationType;
				switch (expressionType)
				{
					case ExpressionConstants.EXPRESSION_TYPE_UNCHECKED_SCOPE: unaryOperationType = UnaryOperationType.UncheckedScope; break;
					case ExpressionConstants.EXPRESSION_TYPE_CHECKED_SCOPE: unaryOperationType = UnaryOperationType.CheckedScope; break;
					case ExpressionConstants.EXPRESSION_TYPE_GROUP: unaryOperationType = UnaryOperationType.Group; break;
					case ExpressionConstants.EXPRESSION_TYPE_UNARY_PLUS: unaryOperationType = UnaryOperationType.UnaryPlus; break;
					case ExpressionConstants.EXPRESSION_TYPE_NEGATE: unaryOperationType = UnaryOperationType.Negate; break;
					case ExpressionConstants.EXPRESSION_TYPE_NEGATE_CHECKED: unaryOperationType = UnaryOperationType.NegateChecked; break;
					case ExpressionConstants.EXPRESSION_TYPE_NOT: unaryOperationType = UnaryOperationType.Not; break;
					case ExpressionConstants.EXPRESSION_TYPE_COMPLEMENT: unaryOperationType = UnaryOperationType.Complement; break;
					default: throw FormulaException.UnknownUnaryExpression(expressionType);
				}
				return unaryOperationType;
			}
		}
	

		public enum UnaryOperationType
		{
			UnaryPlus,
			Negate,
			NegateChecked,
			Not,
			Complement,
			UncheckedScope,
			CheckedScope,
			Group,
		}
	

		private sealed class UnboundLambda
		{
			private readonly KeyValuePair<string, Type>[] parameters;
			private readonly FormulaExpression body;
			private readonly FormulaExecutionContext context;
	
			public UnboundLambda(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
	
				this.parameters = parameters;
				this.body = body;
				this.context = context;
			}
	
			public bool IsSignatureMatching(Type delegateType)
			{
				var invokeMethod = delegateType.GetMethod(nameof(Action.Invoke), BindingFlags.Public | BindingFlags.Instance);
				if (invokeMethod == null)
				{
					return false;
				}
				var parameters = invokeMethod.GetParameters();
				if (parameters.Length != this.parameters.Length)
				{
					return false;
				}
	
				for (var index = 0; index < parameters.Length; index++)
				{
					var parameter = parameters[index];
					var argument = this.parameters[index];
					if (argument.Value == null)
					{
						continue;
					}
	
					if (!parameter.ParameterType.IsAssignableFrom(argument.Value))
					{
						return false;
					}
				}
	
				return true;
			}
	
			public Delegate BindTo(Type delegateType)
			{
				if (delegateType == null) throw new ArgumentNullException(nameof(delegateType));
	
				var invokeMethod = delegateType.GetMethod(nameof(Action.Invoke), BindingFlags.Public | BindingFlags.Instance);
				if (invokeMethod == null) throw new ArgumentException($"Missing required method 'Invoke' on '{delegateType}' delegate type.");
	
				var isVoidResult = invokeMethod.ReturnType == typeof(void);
				var parameters = invokeMethod.GetParameters();
				var signature = GetFuncSignature(invokeMethod, parameters);
	
				var boundLambdaFuncType = isVoidResult ? Expression.GetActionType(signature) : Expression.GetFuncType(signature);
	
				var boundLambdaFuncInvokeMethod = boundLambdaFuncType.GetMethod(nameof(Action.Invoke), BindingFlags.Public | BindingFlags.Instance);
				if (boundLambdaFuncInvokeMethod == null) throw new ArgumentException($"Missing required method 'Invoke' on '{boundLambdaFuncType}' delegate type.");
	
				var prepareMethodDefinition = typeof(LambdaFunctions)
					.GetMethods(BindingFlags.Static | BindingFlags.Public)
					.FirstOrDefault(m =>
						m.Name == (isVoidResult ? nameof(LambdaFunctions.Action) : nameof(LambdaFunctions.Func)) &&
						m.GetGenericArguments().Length == signature.Length);
	
				if (prepareMethodDefinition == null) throw new ArgumentException($"Missing '{nameof(LambdaFunctions.Action)}' or '{nameof(LambdaFunctions.Func)}' on '{typeof(LambdaFunctions)}' type with {signature.Length} generic arguments.");
				var prepareMethod = prepareMethodDefinition.MakeGenericMethod(signature);
				var boundLambdaFunc = prepareMethod.Invoke(null, new object[] { this.body, this.parameters, this.context });
	
				return Delegate.CreateDelegate(delegateType, boundLambdaFunc, boundLambdaFuncInvokeMethod, throwOnBindFailure: true);
			}
	
			private static Type[] GetFuncSignature(MethodInfo methodInfo, ParameterInfo[] parameters)
			{
				if (methodInfo == null) throw new ArgumentNullException(nameof(methodInfo));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
	
				var isVoidResult = methodInfo.ReturnType == typeof(void);
				var signature = new Type[parameters.Length + (isVoidResult ? 0 : 1)];
				for (var i = 0; i < parameters.Length; i++)
				{
					signature[i] = parameters[i].ParameterType;
				}
	
				if (!isVoidResult)
				{
					signature[signature.Length - 1] = methodInfo.ReturnType;
				}
	
				return signature;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				var parameters = string.Join(", ", this.parameters.Select(p => p.Key));
				return $"({parameters}) -> any";
	
			}
		}
	

		public readonly struct VariableValue
		{
			private class TypeCodeRef
			{
				public static readonly TypeCodeRef Boolean = new TypeCodeRef(TypeCode.Boolean, typeof(bool));
				public static readonly TypeCodeRef Char = new TypeCodeRef(TypeCode.Char, typeof(char));
				public static readonly TypeCodeRef SByte = new TypeCodeRef(TypeCode.SByte, typeof(sbyte));
				public static readonly TypeCodeRef Byte = new TypeCodeRef(TypeCode.Byte, typeof(byte));
				public static readonly TypeCodeRef Int16 = new TypeCodeRef(TypeCode.Int16, typeof(short));
				public static readonly TypeCodeRef UInt16 = new TypeCodeRef(TypeCode.UInt16, typeof(ushort));
				public static readonly TypeCodeRef Int32 = new TypeCodeRef(TypeCode.Int32, typeof(int));
				public static readonly TypeCodeRef UInt32 = new TypeCodeRef(TypeCode.UInt32, typeof(uint));
				public static readonly TypeCodeRef Int64 = new TypeCodeRef(TypeCode.Int64, typeof(long));
				public static readonly TypeCodeRef UInt64 = new TypeCodeRef(TypeCode.UInt64, typeof(ulong));
				public static readonly TypeCodeRef Single = new TypeCodeRef(TypeCode.Single, typeof(float));
				public static readonly TypeCodeRef Double = new TypeCodeRef(TypeCode.Double, typeof(double));
				public static readonly TypeCodeRef DateTime = new TypeCodeRef(TypeCode.DateTime, typeof(DateTime));
				public static readonly TypeCodeRef TimeSpan = new TypeCodeRef(TypeCodes.TIME_SPAN_CODE, typeof(TimeSpan));
	
				private static readonly Dictionary<Type, TypeCodeRef> EnumTypeCodes = new Dictionary<Type, TypeCodeRef>();
	
				public readonly TypeCode TypeCode;
				public readonly Type Type;
	
				private TypeCodeRef(TypeCode typeCode, Type type)
				{
					if (type == null) throw new ArgumentNullException(nameof(type));
	
					this.TypeCode = typeCode;
					this.Type = type;
				}
	
				public static TypeCodeRef GetOrCreateEnumTypeCodeRef(Type enumType)
				{
					lock (EnumTypeCodes)
					{
						if (EnumTypeCodes.TryGetValue(enumType, out var enumTypeCodeRef))
						{
							return enumTypeCodeRef;
						}
	
						EnumTypeCodes[enumType] = enumTypeCodeRef = new TypeCodeRef(TypeCodes.GetTypeCode(enumType), enumType);
						return enumTypeCodeRef;
					}
				}
			}
	
			public static readonly VariableValue Null = new VariableValue(null);
	
			private readonly long binaryValue;
			private readonly object refValue;
	
			public bool IsNull => this.binaryValue == 0 && this.refValue == null;
			public Type Type => this.GetValueType();
			public TypeCode TypeCode => this.GetValueTypeCode();
	
			private VariableValue(TypeCodeRef typeCodeRef, long binaryValue)
			{
				this.refValue = typeCodeRef;
				this.binaryValue = binaryValue;
			}
			public VariableValue(object value)
			{
				if (value is VariableValue variableValue)
				{
					this.binaryValue = variableValue.binaryValue;
					this.refValue = variableValue.refValue;
					return;
				}
				else if (value == null)
				{
					this.binaryValue = default;
					this.refValue = null;
					return;
				}
	
				var valueType = value.GetType();
				var valueTypeCode = TypeCodes.GetTypeCode(valueType);
				if (valueType.IsEnum)
				{
					this.refValue = TypeCodeRef.GetOrCreateEnumTypeCodeRef(valueType);
					if (Enum.GetUnderlyingType(valueType) == typeof(ulong))
					{
						this.binaryValue = unchecked((long)Convert.ToUInt64(value, CultureInfo.InvariantCulture));
					}
					else
					{
						this.binaryValue = Convert.ToInt64(value, CultureInfo.InvariantCulture);
					}
					return;
				}
	
				switch (valueTypeCode)
				{
					case TypeCode.Boolean:
						this.binaryValue = (bool)value ? 1 : 0;
						this.refValue = TypeCodeRef.Boolean;
						break;
					case TypeCode.Byte:
						this.binaryValue = (byte)value;
						this.refValue = TypeCodeRef.Byte;
						break;
					case TypeCode.SByte:
						this.binaryValue = (sbyte)value;
						this.refValue = TypeCodeRef.SByte;
						break;
					case TypeCode.Char:
						this.binaryValue = (char)value;
						this.refValue = TypeCodeRef.Char;
						break;
					case TypeCode.Double:
						this.binaryValue = BitConverter.DoubleToInt64Bits((double)value);
						this.refValue = TypeCodeRef.Double;
						break;
					case TypeCode.Int16:
						this.binaryValue = (short)value;
						this.refValue = TypeCodeRef.Int16;
						break;
					case TypeCode.Int32:
						this.binaryValue = (int)value;
						this.refValue = TypeCodeRef.Int32;
						break;
					case TypeCode.Int64:
						this.binaryValue = (long)value;
						this.refValue = TypeCodeRef.Int64;
						break;
					case TypeCode.Single:
						this.binaryValue = BitConverter.DoubleToInt64Bits((float)value);
						this.refValue = TypeCodeRef.Single;
						break;
					case TypeCode.UInt16:
						this.binaryValue = (ushort)value;
						this.refValue = TypeCodeRef.UInt16;
						break;
					case TypeCode.UInt32:
						this.binaryValue = (uint)value;
						this.refValue = TypeCodeRef.UInt32;
						break;
					case TypeCode.UInt64:
						this.binaryValue = unchecked((long)(ulong)value);
						this.refValue = TypeCodeRef.UInt64;
						break;
					case TypeCodes.TIME_SPAN_CODE:
						this.binaryValue = ((TimeSpan)value).Ticks;
						this.refValue = TypeCodeRef.TimeSpan;
						break;
					case TypeCode.DateTime:
						this.binaryValue = ((DateTime)value).ToBinary();
						this.refValue = TypeCodeRef.DateTime;
						break;
					case TypeCode.DBNull:
					case TypeCode.Decimal:
					case TypeCode.Empty:
					case TypeCode.Object:
					case TypeCode.String:
					default:
						this.binaryValue = 0;
						this.refValue = value;
						break;
				}
			}
			public VariableValue(char value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Char;
			}
			public VariableValue(bool value)
			{
				this.binaryValue = value ? 1 : 0;
				this.refValue = TypeCodeRef.Boolean;
			}
			public VariableValue(byte value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Byte;
			}
			public VariableValue(sbyte value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.SByte;
			}
			public VariableValue(short value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Int16;
			}
			public VariableValue(ushort value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.UInt16;
			}
			public VariableValue(int value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Int32;
			}
			public VariableValue(uint value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.UInt32;
			}
			public VariableValue(long value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Int64;
			}
			public VariableValue(ulong value)
			{
				this.binaryValue = unchecked((long)value);
				this.refValue = TypeCodeRef.UInt64;
			}
			public VariableValue(float value)
			{
				this.binaryValue = BitConverter.DoubleToInt64Bits(value);
				this.refValue = TypeCodeRef.Single;
			}
			public VariableValue(double value)
			{
				this.binaryValue = BitConverter.DoubleToInt64Bits(value);
				this.refValue = TypeCodeRef.Double;
			}
			public VariableValue(DateTime value)
			{
				this.binaryValue = value.ToBinary();
				this.refValue = TypeCodeRef.DateTime;
			}
			public VariableValue(TimeSpan value)
			{
				this.binaryValue = value.Ticks;
				this.refValue = TypeCodeRef.TimeSpan;
			}
	
			private Type GetValueType()
			{
				if (this.refValue is TypeCodeRef typeCodeRef)
				{
					return typeCodeRef.Type;
				}
				else
				{
					return this.refValue?.GetType() ?? typeof(object);
				}
			}
			private TypeCode GetValueTypeCode()
			{
				if (this.refValue is TypeCodeRef typeCodeRef)
				{
					return typeCodeRef.TypeCode;
				}
				else
				{
					return TypeCodes.GetTypeCode(this.refValue?.GetType() ?? typeof(object));
				}
			}
			public object ToObject()
			{
				if (this.refValue is TypeCodeRef typeCodeRef)
				{
					var valueTypeCode = typeCodeRef.TypeCode;
					var result = default(object);
					switch (valueTypeCode)
					{
						case TypeCode.Boolean: result = this.binaryValue > 0; break;
						case TypeCode.Char: result = unchecked((char)this.binaryValue); break;
						case TypeCode.SByte: result = unchecked((sbyte)this.binaryValue); break;
						case TypeCode.Byte: result = unchecked((byte)this.binaryValue); break;
						case TypeCode.Int16: result = unchecked((short)this.binaryValue); break;
						case TypeCode.UInt16: result = unchecked((ushort)this.binaryValue); break;
						case TypeCode.Int32: result = unchecked((int)this.binaryValue); break;
						case TypeCode.UInt32: result = unchecked((uint)this.binaryValue); break;
						case TypeCode.Int64: result = this.binaryValue; break;
						case TypeCode.UInt64: result = unchecked((ulong)this.binaryValue); break;
						case TypeCode.Single: result = (float)BitConverter.Int64BitsToDouble(this.binaryValue); break;
						case TypeCode.Double: result = BitConverter.Int64BitsToDouble(this.binaryValue); break;
						case TypeCode.DateTime: result = DateTime.FromBinary(this.binaryValue); break;
						case TypeCodes.TIME_SPAN_CODE: result = TimeSpan.FromTicks(this.binaryValue); break;
						case TypeCode.String:
						case TypeCode.Empty:
						case TypeCode.Object:
						case TypeCode.Decimal:
						case TypeCode.DBNull:
						default: throw new ArgumentOutOfRangeException($"Unexpected type of TypeCodeRef '{valueTypeCode}' while one of blittable types are expected.");
					}
					if (typeCodeRef.Type.IsEnum)
					{
						result = Enum.ToObject(typeCodeRef.Type, result);
					}
					return result;
				}
				else
				{
					return this.refValue;
				}
			}
			public object ToType(Type toType)
			{
				if (toType == null) throw new ArgumentNullException(nameof(toType));
	
				var isNullable = toType.IsGenericType && Nullable.GetUnderlyingType(toType) != toType;
				if (isNullable && this.IsNull)
				{
					return null;
				}
	
				if (toType == typeof(object))
				{
					return this.ToObject();
				}
				else if (toType == typeof(string))
				{
					return this.ToString();
				}
				else if (toType == typeof(char))
				{
					return this.ToChar();
				}
				else if (toType == typeof(bool))
				{
					return this.ToBoolean();
				}
				else if (toType == typeof(byte))
				{
					return this.ToByte();
				}
				else if (toType == typeof(sbyte))
				{
					return this.ToSByte();
				}
				else if (toType == typeof(short))
				{
					return this.ToInt16();
				}
				else if (toType == typeof(ushort))
				{
					return this.ToUInt16();
				}
				else if (toType == typeof(int))
				{
					return this.ToInt32();
				}
				else if (toType == typeof(uint))
				{
					return this.ToUInt32();
				}
				else if (toType == typeof(long))
				{
					return this.ToInt64();
				}
				else if (toType == typeof(ulong))
				{
					return this.ToUInt64();
				}
				else if (toType == typeof(float))
				{
					return this.ToSingle();
				}
				else if (toType == typeof(double))
				{
					return this.ToDouble();
				}
				else if (toType == typeof(DateTime))
				{
					return this.ToDateTime();
				}
				else if (toType == typeof(TimeSpan))
				{
					return this.ToTimeSpan();
				}
				else if (toType == typeof(decimal))
				{
					return this.ToDecimal();
				}
				else if (toType.IsEnum)
				{
					var underlyingType = Enum.GetUnderlyingType(toType);
					return Enum.ToObject(toType, this.ToType(underlyingType));
				}
				else
				{
					var value = this.ToObject();
					if (toType.IsInstanceOfType(value))
					{
						return value;
					}
					else
					{
						throw new InvalidCastException($"Unable to cast value of type '{value?.GetType().FullName ?? "<null>"}' to type '{toType.FullName}'.");
					}
				}
			}
			public bool CanFitInto(TypeCode targetTypeCode)
			{
				var currentTypeCode = this.TypeCode;
				if (currentTypeCode == targetTypeCode)
				{
					return true;
				}
	
				// try compact integer type
				if (TypeCodes.IsInteger(currentTypeCode))
				{
					// ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
					switch (currentTypeCode)
					{
						case TypeCode.UInt64:
							currentTypeCode = TypeCode.UInt64;
							var uint64Value = unchecked((ulong)this.binaryValue);
							if (uint64Value <= long.MaxValue)
							{
								goto case TypeCode.Int64;
							}
							break;
						case TypeCode.Int64:
							currentTypeCode = TypeCode.Int64;
							if (this.binaryValue >= int.MinValue && this.binaryValue <= int.MaxValue) goto case TypeCode.Int32;
							else if (this.binaryValue >= uint.MinValue && this.binaryValue <= uint.MaxValue) goto case TypeCode.UInt32;
							break;
						case TypeCode.UInt32:
							currentTypeCode = TypeCode.UInt32;
							if (this.binaryValue >= short.MinValue && this.binaryValue <= short.MaxValue) goto case TypeCode.Int16;
							else if (this.binaryValue >= ushort.MinValue && this.binaryValue <= ushort.MaxValue) goto case TypeCode.UInt16;
							break;
						case TypeCode.Int32:
							currentTypeCode = TypeCode.Int32;
							if (this.binaryValue >= short.MinValue && this.binaryValue <= short.MaxValue) goto case TypeCode.Int16;
							else if (this.binaryValue >= ushort.MinValue && this.binaryValue <= ushort.MaxValue) goto case TypeCode.UInt16;
							break;
						case TypeCode.Int16:
							currentTypeCode = TypeCode.Int16;
							if (this.binaryValue >= sbyte.MinValue && this.binaryValue <= sbyte.MaxValue) goto case TypeCode.SByte;
							else if (this.binaryValue >= byte.MinValue && this.binaryValue <= byte.MaxValue) goto case TypeCode.Byte;
							break;
						case TypeCode.UInt16:
							currentTypeCode = TypeCode.UInt16;
							if (this.binaryValue >= sbyte.MinValue && this.binaryValue <= sbyte.MaxValue) goto case TypeCode.SByte;
							else if (this.binaryValue >= byte.MinValue && this.binaryValue <= byte.MaxValue) goto case TypeCode.Byte;
							break;
						case TypeCode.SByte:
							currentTypeCode = TypeCode.SByte;
							break;
						case TypeCode.Byte:
							currentTypeCode = TypeCode.Byte;
							break;
					}
				}
	
	
				if (TypeCodes.CanCoerceNumberLike(targetTypeCode, currentTypeCode))
				{
					return true;
				}
	
				if (TypeCodes.IsUnsignedInteger(targetTypeCode) &&
					TypeCodes.IsSignedInteger(currentTypeCode) && this.binaryValue >= 0 &&
					TypeCodes.CanCoerceNumberLike(targetTypeCode, TypeCodes.MakeUnsigned(currentTypeCode)))
				{
					return true;
				}
	
				if (targetTypeCode == TypeCode.Byte && currentTypeCode == TypeCode.SByte)
				{
					return this.binaryValue >= byte.MinValue && this.binaryValue <= byte.MaxValue;
				}
				else if (targetTypeCode == TypeCode.SByte && currentTypeCode == TypeCode.Byte)
				{
					return this.binaryValue >= sbyte.MinValue && this.binaryValue <= sbyte.MaxValue;
				}
	
				else if (targetTypeCode == TypeCode.Int64 && currentTypeCode == TypeCode.UInt64)
				{
					return unchecked((ulong)this.binaryValue) <= long.MaxValue;
				}
				return false;
			}
	
			public long ToInt64(bool uncheckedConversion = false)
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCode.UInt64 && uncheckedConversion == false)
				{
					var uint64Value = unchecked((ulong)this.binaryValue);
					return checked((long)uint64Value);
				}
				else if (TypeCodes.IsInteger(typeCode))
				{
					return this.binaryValue;
				}
				else
				{
					return Convert.ToInt64(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public ulong ToUInt64(bool uncheckedConversion = false)
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCode.UInt64)
				{
					return unchecked((ulong)this.binaryValue);
				}
				else if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((ulong)this.binaryValue) : checked((ulong)this.binaryValue);
				}
				else
				{
					return Convert.ToUInt64(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public int ToInt32(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((int)this.binaryValue) : checked((int)this.binaryValue);
				}
				else
				{
					return Convert.ToInt32(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public uint ToUInt32(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((uint)this.binaryValue) : checked((uint)this.binaryValue);
				}
				else
				{
					return Convert.ToUInt32(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public short ToInt16(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((short)this.binaryValue) : checked((short)this.binaryValue);
				}
				else
				{
					return Convert.ToInt16(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public ushort ToUInt16(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((ushort)this.binaryValue) : checked((ushort)this.binaryValue);
				}
				else
				{
					return Convert.ToUInt16(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public sbyte ToSByte(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((sbyte)this.binaryValue) : checked((sbyte)this.binaryValue);
				}
				else
				{
					return Convert.ToSByte(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public byte ToByte(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((byte)this.binaryValue) : checked((byte)this.binaryValue);
				}
				else
				{
					return Convert.ToByte(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public char ToChar(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((char)this.binaryValue) : checked((char)this.binaryValue);
				}
				else
				{
					return Convert.ToChar(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public double ToDouble()
			{
				var typeCode = this.TypeCode;
				if (TypeCodes.IsInteger(typeCode) || typeCode == TypeCode.Char)
				{
					return typeCode == TypeCode.UInt64 ? unchecked((ulong)this.binaryValue) : (double)this.binaryValue;
				}
				else if (typeCode == TypeCode.Single || typeCode == TypeCode.Double)
				{
					return BitConverter.Int64BitsToDouble(this.binaryValue);
				}
				else
				{
					return Convert.ToDouble(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public float ToSingle()
			{
				var typeCode = this.TypeCode;
				if (TypeCodes.IsInteger(typeCode) || typeCode == TypeCode.Char)
				{
					return typeCode == TypeCode.UInt64 ? unchecked((ulong)this.binaryValue) : (float)this.binaryValue;
				}
				else if (typeCode == TypeCode.Single || typeCode == TypeCode.Double)
				{
					return (float)BitConverter.Int64BitsToDouble(this.binaryValue);
				}
				else
				{
					return Convert.ToSingle(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public decimal ToDecimal()
			{
				var typeCode = this.TypeCode;
				if (TypeCodes.IsInteger(typeCode) || typeCode == TypeCode.Char)
				{
					return typeCode == TypeCode.UInt64 ? unchecked((ulong)this.binaryValue) : (decimal)this.binaryValue;
				}
				else if (typeCode == TypeCode.Single || typeCode == TypeCode.Double)
				{
					return (decimal)BitConverter.Int64BitsToDouble(this.binaryValue);
				}
				else
				{
					return Convert.ToDecimal(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public DateTime ToDateTime()
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCode.DateTime)
				{
					return DateTime.FromBinary(this.binaryValue);
				}
				else
				{
					return Convert.ToDateTime(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public TimeSpan ToTimeSpan()
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCodes.TIME_SPAN_CODE)
				{
					return TimeSpan.FromTicks(this.binaryValue);
				}
				else
				{
					return ToTimeSpan(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public bool ToBoolean()
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCode.Boolean)
				{
					return this.binaryValue > 0;
				}
				else
				{
					return Convert.ToBoolean(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public T To<T>()
			{
				if (typeof(T) == typeof(long)) return (T)(object)this.ToInt64();
				else if (typeof(T) == typeof(ulong)) return (T)(object)this.ToUInt64();
				else if (typeof(T) == typeof(int)) return (T)(object)this.ToInt32();
				else if (typeof(T) == typeof(uint)) return (T)(object)this.ToUInt32();
				else if (typeof(T) == typeof(short)) return (T)(object)this.ToInt16();
				else if (typeof(T) == typeof(ushort)) return (T)(object)this.ToUInt16();
				else if (typeof(T) == typeof(sbyte)) return (T)(object)this.ToSByte();
				else if (typeof(T) == typeof(byte)) return (T)(object)this.ToByte();
				else if (typeof(T) == typeof(char)) return (T)(object)this.ToChar();
				else if (typeof(T) == typeof(double)) return (T)(object)this.ToDouble();
				else if (typeof(T) == typeof(float)) return (T)(object)this.ToSingle();
				else if (typeof(T) == typeof(decimal)) return (T)(object)this.ToDecimal();
				else if (typeof(T) == typeof(DateTime)) return (T)(object)this.ToDateTime();
				else if (typeof(T) == typeof(TimeSpan)) return (T)(object)this.ToTimeSpan();
				else if (typeof(T) == typeof(bool)) return (T)(object)this.ToBoolean();
				else
				{
					var objValue = this.ToObject();
					if (objValue is T typeValue)
					{
						return typeValue;
					}
					else if (typeof(T).IsEnum && objValue is string enumValueString)
					{
						return (T)Enum.Parse(typeof(T), enumValueString, ignoreCase: true);
					}
					else if (typeof(T).IsEnum)
					{
						return (T)Enum.ToObject(typeof(T), objValue);
					}
					else
					{
						return (T)Convert.ChangeType(this.ToObject(), typeof(T), CultureInfo.InvariantCulture);
					}
				}
			}
	
			public static implicit operator VariableValue(char value) { return new VariableValue(value); }
			public static implicit operator VariableValue(bool value) { return new VariableValue(value); }
			public static implicit operator VariableValue(byte value) { return new VariableValue(value); }
			public static implicit operator VariableValue(sbyte value) { return new VariableValue(value); }
			public static implicit operator VariableValue(short value) { return new VariableValue(value); }
			public static implicit operator VariableValue(ushort value) { return new VariableValue(value); }
			public static implicit operator VariableValue(int value) { return new VariableValue(value); }
			public static implicit operator VariableValue(uint value) { return new VariableValue(value); }
			public static implicit operator VariableValue(long value) { return new VariableValue(value); }
			public static implicit operator VariableValue(ulong value) { return new VariableValue(value); }
			public static implicit operator VariableValue(float value) { return new VariableValue(value); }
			public static implicit operator VariableValue(double value) { return new VariableValue(value); }
			public static implicit operator VariableValue(DateTime value) { return new VariableValue(value); }
			public static implicit operator VariableValue(TimeSpan value) { return new VariableValue(value); }
			public static implicit operator VariableValue(decimal value) { return new VariableValue(value); }
			public static implicit operator VariableValue(string value) { return new VariableValue(value); }
	
			public static VariableValue FromEnum(Type enumType, long value)
			{
				if (!enumType.IsEnum) throw new ArgumentException($"Type '{enumType}' should be enum type.");
	
				var typeCodeRef = TypeCodeRef.GetOrCreateEnumTypeCodeRef(enumType);
				return new VariableValue(typeCodeRef, value);
			}
	
			public static TimeSpan ToTimeSpan(object value, IFormatProvider formatProvider)
			{
				if (value == null) throw new ArgumentNullException(nameof(value));
	
				if (value is TimeSpan span)
				{
					return span;
				}
				if (value is byte byteValue)
				{
					return TimeSpan.FromTicks(byteValue);
				}
				else if (value is sbyte sByteValue)
				{
					return TimeSpan.FromTicks(sByteValue);
				}
				else if (value is short shortValue)
				{
					return TimeSpan.FromTicks(shortValue);
				}
				else if (value is ushort ushortValue)
				{
					return TimeSpan.FromTicks(ushortValue);
				}
				else if (value is int intValue)
				{
					return TimeSpan.FromTicks(intValue);
				}
				else if (value is uint uintValue)
				{
					return TimeSpan.FromTicks(uintValue);
				}
				else if (value is long longValue)
				{
					return TimeSpan.FromTicks(longValue);
				}
				else if (value is ulong ulongValue)
				{
					return TimeSpan.FromTicks((long)ulongValue);
				}
				else if (value is float floatValue)
				{
					return TimeSpan.FromTicks(checked((long)floatValue));
				}
				else if (value is double doubleValue)
				{
					return TimeSpan.FromTicks(checked((long)doubleValue));
				}
				else if (value is decimal decimalValue)
				{
					return TimeSpan.FromTicks((long)decimalValue);
				}
				else
				{
					var stringValue = Convert.ToString(value, formatProvider) ?? value.ToString();
					if (stringValue.All(char.IsDigit))
					{
						return TimeSpan.FromTicks(long.Parse(stringValue));
					}
					else
					{
						return TimeSpan.Parse(stringValue, formatProvider);
					}
				}
			}
	
			public static Expression ToVariableValueExpression(Expression valueExpression)
			{
				if (valueExpression == null) throw new ArgumentNullException(nameof(valueExpression));
	
				var expressionType = valueExpression.Type;
				var constructor = typeof(VariableValue).GetConstructor(new[] { expressionType });
				if (constructor != null)
				{
					return Expression.New(constructor, valueExpression);
				}
	
				constructor = typeof(VariableValue).GetConstructor(new[] { typeof(object) });
				if (constructor == null)
				{
					throw new InvalidOperationException($"There is no .ctr(object value) constructor on '{typeof(VariableValue)}' type. Make sure it is not removed by IL Linker.");
				}
				return Expression.New(constructor, Expression.Convert(valueExpression, typeof(object)));
			}
			public static Expression FromVariableValueExpression(Expression variableValueExpression, Type expectedType)
			{
				if (variableValueExpression == null) throw new ArgumentNullException(nameof(variableValueExpression));
				if (expectedType == null) throw new ArgumentNullException(nameof(expectedType));
	
				var convertMethod = typeof(VariableValue).GetMethod("op_Explicit", BindingFlags.Static | BindingFlags.Public, null, new[] { expectedType }, null);
				if (convertMethod != null)
				{
					return Expression.Call(convertMethod, variableValueExpression);
				}
	
				convertMethod = typeof(VariableValue)
					.GetMethods(BindingFlags.Instance | BindingFlags.Public)
					.FirstOrDefault(method => method.Name.StartsWith("To") && method.ReturnType == expectedType);
				if (convertMethod != null)
				{
					var parameterExpressions = Array.ConvertAll(convertMethod.GetParameters(), parameter => parameter.HasDefaultValue ?
						Expression.Constant(parameter.DefaultValue) :
						(Expression)Expression.Default(parameter.ParameterType)
					);
	
					return Expression.Call(variableValueExpression, convertMethod, parameterExpressions);
				}
	
				var toObjectCall = Expression.Call(variableValueExpression, nameof(ToObject), Type.EmptyTypes);
				return Expression.Convert(toObjectCall, expectedType);
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				var value = this.ToObject();
				return Convert.ToString(value, CultureInfo.InvariantCulture) ?? string.Empty;
			}
		}
	
	}
#endif
}


