// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace GameDevWare.Charon.Editor
{
    using System;

    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public partial class CSharp73GameDataFromAssetGenerator : CSharp73GameDataFromAssetGeneratorBase
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {

	// ReSharper disable All
	this.ToolsVersion = this.ToolsVersion ?? this.GetType().Assembly.GetName().Version.ToString();
	this.ToolsName = this.ToolsName ?? this.GetType().Assembly.GetName().Name;
	this.GameDataClassName = this.GameDataClassName ?? "GameData";
	this.AssetClassName = this.AssetClassName ?? "GameDataAsset";

            this.Write("//------------------------------------------------------------------------------\r\n// <auto-generated>\r\n//\t This code was generated by a tool.\r\n//\t Changes to this file may cause incorrect behavior and will be lost if\r\n//\t the code is regenerated.\r\n// </auto-generated>\r\n//------------------------------------------------------------------------------\r\n\r\n/*\r\n\tCopyright (c) 2025 GameDevWare, Denis Zykov\r\n\r\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\r\n\tof this software and associated documentation files (the \"Software\"), to deal\r\n\tin the Software without restriction, including without limitation the rights\r\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n\tcopies of the Software, and to permit persons to whom the Software is\r\n\tfurnished to do so, subject to the following conditions:\r\n\r\n\tThe above copyright notice and this permission notice shall be included in\r\n\tall copies or substantial portions of the Software.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n\tTHE SOFTWARE.\r\n*/\r\n\r\n// ReSharper disable All\r\n\r\nnamespace ");

            this.Write(this.ToStringHelper.ToStringWithCulture(this.Namespace));

            #line default
            #line hidden
            this.Write("\r\n{\r\n\tusing System;\r\n\tusing System.IO;\r\n\tusing System.Collections.Generic;\r\n\tusing System.Text;\r\n\tusing UnityEngine;\r\n\tusing Unity.Collections;\r\n\tusing GameDevWare.Charon;\r\n\r\n\t[Serializable, PreferBinarySerialization]\r\n    [global::System.CodeDom.Compiler.GeneratedCode(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(this.ToolsName));

            #line default
            #line hidden
            this.Write("\", \"");

            this.Write(this.ToStringHelper.ToStringWithCulture(this.ToolsVersion));

            #line default
            #line hidden
            this.Write("\")]\r\n\tpublic partial class ");

            this.Write(this.ToStringHelper.ToStringWithCulture(this.AssetClassName));

            #line default
            #line hidden
            this.Write(" : GameDataBase, ISerializationCallbackReceiver\r\n\t{\r\n\t\t[SerializeField, HideInInspector]\r\n\t\tprivate byte[] gameDataBytes;\r\n\t\t[SerializeField, HideInInspector]\r\n\t\tprivate GameDataFormat format;\r\n\t\t[NonSerialized, HideInInspector]\r\n\t\tpublic ");

            this.Write(this.ToStringHelper.ToStringWithCulture(this.GameDataClassName));

            #line default
            #line hidden
            this.Write(" GameData;\r\n\r\n\t\t/// <inheritdoc />\r\n\t\tpublic override string RevisionHash => this.GameData?.RevisionHash;\r\n\t\t/// <inheritdoc />\r\n\t\tpublic override string GameDataVersion => this.GameData?.GameDataVersion;\r\n\r\n\t\tprivate ");

            this.Write(this.ToStringHelper.ToStringWithCulture(this.AssetClassName));

            #line default
            #line hidden
            this.Write("()\r\n\t\t{\r\n\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc />\r\n\t\tvoid ISerializationCallbackReceiver.OnBeforeSerialize()\r\n\t\t{\r\n\t\t\tthis.OnBeforeSerialize();\r\n\t\t}\r\n\t\t/// <inheritdoc />\r\n\t\tvoid ISerializationCallbackReceiver.OnAfterDeserialize()\r\n\t\t{\r\n\t\t\tthis.OnAfterDeserialize();\r\n\r\n\t\t\tif (this.gameDataBytes == null || this.gameDataBytes.Length == 0)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tusing var gameDataStream = new MemoryStream(this.gameDataBytes, 0, this.gameDataBytes.Length, writable: false);\r\n\t\t\tif (!this.TryLoad(gameDataStream, this.format))\r\n\t\t\t{\r\n\t\t\t\tthrow new InvalidOperationException(string.Format(\"Unknown file format '{0}'.\", this.format));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc />\r\n\t\tpublic override void Save(Stream gameDataStream, GameDataFormat format)\r\n\t\t{\r\n\t\t\tif (gameDataStream == null) throw new ArgumentNullException(nameof(gameDataStream));\r\n\r\n\t\t\tthis.OnBeforeSave(ref gameDataStream, ref format);\r\n\r\n\t\t\tthis.format = format;\r\n\t\t\tthis.gameDataBytes = new byte[(int)gameDataStream.Length];\r\n\t\t\tgameDataStream.Position = 0;\r\n\r\n\t\t\tvar offset = 0;\r\n\t\t\tvar read = 0;\r\n\t\t\twhile ((read = gameDataStream.Read(this.gameDataBytes, offset, this.gameDataBytes.Length - offset)) > 0 &&\r\n\t\t\t\toffset < this.gameDataBytes.Length)\r\n\t\t\t{\r\n\t\t\t\toffset += read;\r\n\t\t\t}\r\n\r\n\t\t\tif (offset != this.gameDataBytes.Length) throw new InvalidOperationException(\"Failed to read whole stream into byte array.\");\r\n\r\n\t\t\tthis.OnAfterSave();\r\n\r\n\t\t\tusing var gameDataMemoryStream = new MemoryStream(this.gameDataBytes, 0, this.gameDataBytes.Length, writable: false);\r\n\t\t\tif (!this.TryLoad(gameDataMemoryStream, this.format))\r\n\t\t\t{\r\n\t\t\t\tthrow new InvalidOperationException(string.Format(\"Unknown file format '{0}'.\", this.format));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc />\r\n\t\tpublic override bool TryLoad(Stream gameDataStream, GameDataFormat format)\r\n\t\t{\r\n\t\t\tif (gameDataStream == null) throw new ArgumentNullException(nameof(gameDataStream));\r\n\r\n\t\t\tthis.OnBeforeSave(ref gameDataStream, ref format);\r\n\r\n\t\t\tvar success = false;\r\n\t\t\tswitch (format)\r\n\t\t\t{\r\n\t\t\t\tcase GameDataFormat.Json:\r\n\t\t\t\t\tthis.GameData = new ");

            this.Write(this.ToStringHelper.ToStringWithCulture(this.GameDataClassName));

            #line default
            #line hidden
            this.Write("(gameDataStream, new Formatters.GameDataLoadOptions { Format = Formatters.GameDataFormat.Json });\r\n\t\t\t\t\tsuccess = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase GameDataFormat.MessagePack:\r\n\t\t\t\t\tthis.GameData = new ");

            this.Write(this.ToStringHelper.ToStringWithCulture(this.GameDataClassName));

            #line default
            #line hidden
            this.Write("(gameDataStream, new Formatters.GameDataLoadOptions { Format = Formatters.GameDataFormat.MessagePack });\r\n\t\t\t\t\tsuccess = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tsuccess = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tthis.OnAfterLoad(ref success);\r\n\t\t\treturn success;\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc />\r\n\t\tpublic override object FindGameDataDocumentById(string schemaNameOrId, string id)\r\n\t\t{\r\n\t\t\tif (schemaNameOrId == null) throw new ArgumentNullException(nameof(schemaNameOrId));\r\n\r\n\t\t\treturn this.GameData.FindDocument(schemaNameOrId, id);\r\n\t\t}\r\n\t\t/// <inheritdoc />\r\n\t\tpublic override IEnumerable<string> GetDocumentIds(string schemaNameOrId)\r\n\t\t{\r\n\t\t\tif (schemaNameOrId == null) throw new ArgumentNullException(nameof(schemaNameOrId));\r\n\r\n\t\t\treturn this.GameData.GetDocumentIds(schemaNameOrId);\r\n\t\t}\r\n\t\t/// <inheritdoc />\r\n\t\tpublic override IEnumerable<string> GetDocumentSchemaNames()\r\n\t\t{\r\n\t\t\treturn this.GameData.GetDocumentSchemaNames();\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Extension method invoked at the start of the <see cref=\"Save\"/> method.\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"gameDataStream\">The data stream used to save the asset. Must be a seekable stream with a known length.</param>\r\n\t\t/// <param name=\"format\">The format of the game data stream.</param>\r\n\t\tpartial void OnBeforeSave(ref Stream gameDataStream, ref GameDataFormat format);\r\n\r\n\t\t/// <summary>\r\n\t\t/// Extension method invoked at the end of the <see cref=\"Save\"/> method.\r\n\t\t/// </summary>\r\n\t\tpartial void OnAfterSave();\r\n\r\n\t\t/// <summary>\r\n\t\t/// Extension method invoked at the start of the <see cref=\"TryLoad\"/> method.\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"gameDataStream\">The data stream used to load the asset. Must be a seekable stream with a known length.</param>\r\n\t\t/// <param name=\"format\">The format of the game data stream.</param>\r\n\t\tpartial void OnBeforeLoad(ref Stream gameDataStream, ref GameDataFormat format);\r\n\r\n\t\t/// <summary>\r\n\t\t/// Extension method invoked at the end of the <see cref=\"TryLoad\"/> method.\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"success\">A flag indicating whether the load operation was successful.</param>\r\n\t\tpartial void OnAfterLoad(ref bool success);\r\n\r\n\t\t/// <summary>\r\n\t\t/// Extension method invoked at the end of the <see cref=\"ISerializationCallbackReceiver.OnAfterDeserialize\"/> method.\r\n\t\t/// </summary>\r\n\t\tpartial void OnAfterDeserialize();\r\n\r\n\t\t/// <summary>\r\n\t\t/// Extension method invoked at the end of the <see cref=\"ISerializationCallbackReceiver.OnBeforeSerialize\"/> method.\r\n\t\t/// </summary>\r\n\t\tpartial void OnBeforeSerialize();\r\n\t}\r\n}\r\n\r\n");
            return this.GenerationEnvironment.ToString();
        }


	public string ToolsVersion { get; set; }
	public string ToolsName { get; set; }

	public string Namespace { get; set; }
	public string AssetClassName { get; set; }
	public string GameDataClassName { get; set; }

    }
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public class CSharp73GameDataFromAssetGeneratorBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0)
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
