<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GameDevWare.Charon</name>
    </assembly>
    <members>
        <member name="T:GameDevWare.Charon.AssetLoaderGenerator">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.AssetLoaderGenerator.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.AssetLoaderGeneratorBase">
            <summary>
            Base class for this transformation
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.AssetLoaderGeneratorBase.GenerationEnvironment">
            <summary>
            The string builder that generation-time code is using to assemble generated output
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.AssetLoaderGeneratorBase.Errors">
            <summary>
            The error collection for the generation process
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.AssetLoaderGeneratorBase.indentLengths">
            <summary>
            A list of the lengths of each indent that was added with PushIndent
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.AssetLoaderGeneratorBase.CurrentIndent">
            <summary>
            Gets the current indent we use when adding lines to the output
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.AssetLoaderGeneratorBase.Session">
            <summary>
            Current transformation session
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.AssetLoaderGeneratorBase.Write(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.AssetLoaderGeneratorBase.WriteLine(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.AssetLoaderGeneratorBase.Write(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.AssetLoaderGeneratorBase.WriteLine(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.AssetLoaderGeneratorBase.Error(System.String)">
            <summary>
            Raise an error
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.AssetLoaderGeneratorBase.Warning(System.String)">
            <summary>
            Raise a warning
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.AssetLoaderGeneratorBase.PushIndent(System.String)">
            <summary>
            Increase the indent
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.AssetLoaderGeneratorBase.PopIndent">
            <summary>
            Remove the last indent that was added with PushIndent
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.AssetLoaderGeneratorBase.ClearIndent">
            <summary>
            Remove any indentation
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.AssetLoaderGeneratorBase.ToStringInstanceHelper">
            <summary>
            Utility class to produce culture-oriented representation of an object as a string.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.AssetLoaderGeneratorBase.ToStringInstanceHelper.FormatProvider">
            <summary>
            Gets or sets format provider to be used by ToStringWithCulture method.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.AssetLoaderGeneratorBase.ToStringInstanceHelper.ToStringWithCulture(System.Object)">
            <summary>
            This is called from the compile/run appdomain to convert objects within an expression block to a string
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.AssetLoaderGeneratorBase.ToStringHelper">
            <summary>
            Helper to produce culture-oriented representation of an object as a string
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Checksum.Adler32">
             <summary>
             Computes Adler32 checksum for a stream of data. An Adler32
             checksum is not as reliable as a CRC32 checksum, but a lot faster to
             compute.
            
             The specification for Adler32 may be found in RFC 1950.
             ZLIB Compressed Data Format Specification version 3.3)
            
            
             From that document:
            
                  "ADLER32 (Adler-32 checksum)
                   This contains a checksum value of the uncompressed data
                   (excluding any dictionary data) computed according to Adler-32
                   algorithm. This algorithm is a 32-bit extension and improvement
                   of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
                   standard.
            
                   Adler-32 is composed of two sums accumulated per byte: s1 is
                   the sum of all bytes, s2 is the sum of all s1 values. Both sums
                   are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
                   Adler-32 checksum is stored as s2*65536 + s1 in most-
                   significant-byte first (network) order."
            
              "8.2. The Adler-32 algorithm
            
                The Adler-32 algorithm is much faster than the CRC32 algorithm yet
                still provides an extremely low probability of undetected errors.
            
                The modulo on unsigned long accumulators can be delayed for 5552
                bytes, so the modulo operation time is negligible.  If the bytes
                are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
                and order sensitive, unlike the first sum, which is just a
                checksum.  That 65521 is prime is important to avoid a possible
                large class of two-byte errors that leave the check unchanged.
                (The Fletcher checksum uses 255, which is not prime and which also
                makes the Fletcher check insensitive to single byte changes 0 -
                255.)
            
                The sum s1 is initialized to 1 instead of zero to make the length
                of the sequence part of s2, so that the length does not have to be
                checked separately. (Any sequence of zeroes has a Fletcher
                checksum of zero.)"
             </summary>
             <see cref="T:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream"/>
             <see cref="!:DeflaterOutputStream"/>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Checksum.Adler32.BASE">
            <summary>
            largest prime smaller than 65536
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Checksum.Adler32.checkValue">
            <summary>
            The CRC data checksum so far.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.Adler32.#ctor">
            <summary>
            Initialise a default instance of <see cref="T:GameDevWare.Charon.Packages.Checksum.Adler32"></see>
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.Adler32.Reset">
            <summary>
            Resets the Adler32 data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Checksum.Adler32.Value">
            <summary>
            Returns the Adler32 data checksum computed so far.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.Adler32.Update(System.Int32)">
            <summary>
            Updates the checksum with the byte b.
            </summary>
            <param name="bval">
            The data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.Adler32.Update(System.Byte[])">
            <summary>
            Updates the Adler32 data checksum with the bytes taken from
            a block of data.
            </summary>
            <param name="buffer">Contains the data to update the checksum with.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.Adler32.Update(System.ArraySegment{System.Byte})">
            <summary>
            Update Adler32 data checksum based on a portion of a block of data
            </summary>
            <param name = "segment">
            The chunk of data to add
            </param>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Checksum.Crc32">
             <summary>
             CRC-32 with reversed data and unreversed output
             </summary>
             <remarks>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+x^0.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </remarks>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Checksum.Crc32.checkValue">
            <summary>
            The CRC data checksum so far.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.Crc32.#ctor">
            <summary>
            Initialise a default instance of <see cref="T:GameDevWare.Charon.Packages.Checksum.Crc32"></see>
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.Crc32.Reset">
            <summary>
            Resets the CRC data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Checksum.Crc32.Value">
            <summary>
            Returns the CRC data checksum computed so far.
            </summary>
            <remarks>Reversed Out = false</remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.Crc32.Update(System.Int32)">
            <summary>
            Updates the checksum with the int bval.
            </summary>
            <param name = "bval">
            the byte is taken as the lower 8 bits of bval
            </param>
            <remarks>Reversed Data = true</remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.Crc32.Update(System.Byte[])">
            <summary>
            Updates the CRC data checksum with the bytes taken from
            a block of data.
            </summary>
            <param name="buffer">Contains the data to update the CRC with.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.Crc32.Update(System.ArraySegment{System.Byte})">
            <summary>
            Update CRC data checksum based on a portion of a block of data
            </summary>
            <param name = "segment">
            The chunk of data to add
            </param>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Checksum.IChecksum">
            <summary>
            Interface to compute a data checksum used by checked input/output streams.
            A data checksum can be updated by one byte or with a byte array. After each
            update the value of the current checksum can be returned by calling
            <code>getValue</code>. The complete checksum object can also be reset
            so it can be used again with new data.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.IChecksum.Reset">
            <summary>
            Resets the data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Checksum.IChecksum.Value">
            <summary>
            Returns the data checksum computed so far.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.IChecksum.Update(System.Int32)">
            <summary>
            Adds one byte to the data checksum.
            </summary>
            <param name = "bval">
            the data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.IChecksum.Update(System.Byte[])">
            <summary>
            Updates the data checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Checksum.IChecksum.Update(System.ArraySegment{System.Byte})">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "segment">
            The chunk of data to add
            </param>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.CompressionMethod">
            <summary>
            The kind of compression used for an entry in an archive
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.CompressionMethod.Stored">
            <summary>
            A direct copy of the file contents is held in the archive
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.CompressionMethod.Deflated">
            <summary>
            Common Zip compression method using a sliding dictionary
            of up to 32KB and secondary compression from Huffman/Shannon-Fano trees
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.CompressionMethod.Deflate64">
            <summary>
            An extension to deflate with a 64KB window. Not supported by #Zip currently
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.CompressionMethod.BZip2">
            <summary>
            BZip2 compression. Not supported by #Zip.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.CompressionMethod.WinZipAES">
            <summary>
            WinZip special for AES encryption, Now supported by #Zip.
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.GeneralBitFlags">
            <summary>
            Defines the contents of the general bit flags field for an archive entry.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.Encrypted">
            <summary>
            Bit 0 if set indicates that the file is encrypted
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.Method">
            <summary>
            Bits 1 and 2 - Two bits defining the compression method (only for Method 6 Imploding and 8,9 Deflating)
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.Descriptor">
            <summary>
            Bit 3 if set indicates a trailing data desciptor is appended to the entry data
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.ReservedPKware4">
            <summary>
            Bit 4 is reserved for use with method 8 for enhanced deflation
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.Patched">
            <summary>
            Bit 5 if set indicates the file contains Pkzip compressed patched data.
            Requires version 2.7 or greater.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.StrongEncryption">
            <summary>
            Bit 6 if set indicates strong encryption has been used for this entry.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.Unused7">
            <summary>
            Bit 7 is currently unused
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.Unused8">
            <summary>
            Bit 8 is currently unused
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.Unused9">
            <summary>
            Bit 9 is currently unused
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.Unused10">
            <summary>
            Bit 10 is currently unused
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.UnicodeText">
            <summary>
            Bit 11 if set indicates the filename and
            comment fields for this file must be encoded using UTF-8.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.EnhancedCompress">
            <summary>
            Bit 12 is documented as being reserved by PKware for enhanced compression.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.HeaderMasked">
            <summary>
            Bit 13 if set indicates that values in the local header are masked to hide
            their actual values, and the central directory is encrypted.
            </summary>
            <remarks>
            Used when encrypting the central directory contents.
            </remarks>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.ReservedPkware14">
            <summary>
            Bit 14 is documented as being reserved for use by PKware
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.GeneralBitFlags.ReservedPkware15">
            <summary>
            Bit 15 is documented as being reserved for use by PKware
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.UseZip64">
            <summary>
            Determines how entries are tested to see if they should use Zip64 extensions or not.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.UseZip64.Off">
            <summary>
            Zip64 will not be forced on entries during processing.
            </summary>
            <remarks>An entry can have this overridden if required <see cref="M:GameDevWare.Charon.Packages.Zip.ZipEntry.ForceZip64"></see></remarks>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.UseZip64.On">
            <summary>
            Zip64 should always be used.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.UseZip64.Dynamic">
            <summary>
            #ZipLib will determine use based on entry values when added to archive.
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.Compression.DeflaterConstants">
            <summary>
            This class contains constants used for deflation.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.DeflaterConstants.DEFLATED">
            <summary>
            The compression method.  This is the only method supported so far.
            There is no need to use this constant at all.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.DeflaterConstants.STORED_BLOCK">
            <summary>
            Written to Zip file to identify a stored block
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.DeflaterConstants.STATIC_TREES">
            <summary>
            Identifies static tree in Zip file
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.DeflaterConstants.DYN_TREES">
            <summary>
            Identifies dynamic tree in Zip file
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.DeflaterConstants.BitReverse(System.Int32)">
            <summary>
            Reverse the bits of a 16 bit value.
            </summary>
            <param name="toReverse">Value to reverse bits</param>
            <returns>Value with bits reversed</returns>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.Compression.Inflater">
             <summary>
             Inflater is used to decompress data that has been compressed according
             to the "deflate" standard described in rfc1951.
            
             By default Zlib (rfc1950) headers and footers are expected in the input.
             You can use constructor <code> public Inflater(bool noHeader)</code> passing true
             if there is no Zlib header information
            
             The usage is as following.  First you have to set some input with
             <code>SetInput()</code>, then Inflate() it.  If inflate doesn't
             inflate any bytes there may be three reasons:
             <ul>
             <li>IsNeedingInput() returns true because the input buffer is empty.
             You have to provide more input with <code>SetInput()</code>.
             NOTE: IsNeedingInput() also returns true when, the stream is finished.
             </li>
             <li>IsNeedingDictionary() returns true, you have to provide a preset
                dictionary with <code>SetDictionary()</code>.</li>
             <li>IsFinished returns true, the inflater has finished.</li>
             </ul>
             Once the first output byte is produced, a dictionary will not be
             needed at a later stage.
            
             author of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Inflater.CPLENS">
            <summary>
            Copy lengths for literal codes 257..285
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Inflater.CPLEXT">
            <summary>
            Extra bits for literal codes 257..285
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Inflater.CPDIST">
            <summary>
            Copy offsets for distance codes 0..29
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Inflater.CPDEXT">
            <summary>
            Extra bits for distance codes
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Inflater.DECODE_HEADER">
            <summary>
            These are the possible states for an inflater
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Inflater.mode">
            <summary>
            This variable contains the current state.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Inflater.readAdler">
            <summary>
            The adler checksum of the dictionary or of the decompressed
            stream, as it is written in the header resp. footer of the
            compressed stream.
            Only valid if mode is DECODE_DICT or DECODE_CHKSUM.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Inflater.neededBits">
            <summary>
            The number of bits needed to complete the current state.  This
            is valid, if mode is DECODE_DICT, DECODE_CHKSUM,
            DECODE_HUFFMAN_LENBITS or DECODE_HUFFMAN_DISTBITS.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Inflater.isLastBlock">
            <summary>
            True, if the last block flag was set in the last block of the
            inflated stream.  This means that the stream ends after the
            current block.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Inflater.totalOut">
            <summary>
            The total number of inflated bytes.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Inflater.totalIn">
            <summary>
            The total number of bytes set with setInput().  This is not the
            value returned by the TotalIn property, since this also includes the
            unprocessed input.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Inflater.noHeader">
            <summary>
            This variable stores the noHeader flag that was given to the constructor.
            True means, that the inflated stream doesn't contain a Zlib header or
            footer.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.#ctor">
            <summary>
            Creates a new inflater or RFC1951 decompressor
            RFC1950/Zlib headers and footers will be expected in the input data
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.#ctor(System.Boolean)">
             <summary>
             Creates a new inflater.
             </summary>
             <param name="noHeader">
             True if no RFC1950/Zlib header and footer fields are expected in the input data
            
             This is used for GZIPed/Zipped input.
            
             For compatibility with
             Sun JDK you should provide one byte of input more than needed in
             this case.
             </param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.Reset">
            <summary>
            Resets the inflater so that a new stream can be decompressed.  All
            pending input and output will be discarded.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.DecodeHeader">
            <summary>
            Decodes a zlib/RFC1950 header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
            <exception cref="T:GameDevWare.Charon.Packages.SharpZipBaseException">
            The header is invalid.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.DecodeDict">
            <summary>
            Decodes the dictionary checksum after the deflate header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.DecodeHuffman">
            <summary>
            Decodes the huffman encoded symbols in the input stream.
            </summary>
            <returns>
            false if more input is needed, true if output window is
            full or the current block ends.
            </returns>
            <exception cref="T:GameDevWare.Charon.Packages.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.DecodeChksum">
            <summary>
            Decodes the adler checksum after the deflate stream.
            </summary>
            <returns>
            false if more input is needed.
            </returns>
            <exception cref="T:GameDevWare.Charon.Packages.SharpZipBaseException">
            If checksum doesn't match.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.Decode">
            <summary>
            Decodes the deflated stream.
            </summary>
            <returns>
            false if more input is needed, or if finished.
            </returns>
            <exception cref="T:GameDevWare.Charon.Packages.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
            <param name="index">
            The index into buffer where the dictionary starts.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No dictionary is needed.
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.SharpZipBaseException">
            The adler checksum for the buffer is invalid
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.SetInput(System.Byte[])">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            the input.
            </param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            The source of input data
            </param>
            <param name="index">
            The index into buffer where the input starts.
            </param>
            <param name="count">
            The number of bytes of input to use.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No input is needed.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The index and/or count are wrong.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.Inflate(System.Byte[])">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether IsNeedingDictionary(),
            IsNeedingInput() or IsFinished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <returns>
            The number of bytes written to the buffer, 0 if no further
            output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if buffer has length 0.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.Inflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether needsDictionary(),
            needsInput() or finished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <param name="offset">
            the offset in buffer where storing starts.
            </param>
            <param name="count">
            the maximum number of bytes to output.
            </param>
            <returns>
            the number of bytes written to the buffer, 0 if no further output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if count is less than 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if the index and / or count are wrong.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Inflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput().
            NOTE: This method also returns true when the stream is finished.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Inflater.IsNeedingDictionary">
            <summary>
            Returns true, if a preset dictionary is needed to inflate the input.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Inflater.IsFinished">
            <summary>
            Returns true, if the inflater has finished.  This means, that no
            input is needed and no output can be produced.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Inflater.Adler">
            <summary>
            Gets the adler checksum.  This is either the checksum of all
            uncompressed bytes returned by inflate(), or if needsDictionary()
            returns true (and thus no output was yet produced) this is the
            adler checksum of the expected dictionary.
            </summary>
            <returns>
            the adler checksum.
            </returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Inflater.TotalOut">
            <summary>
            Gets the total number of output bytes returned by Inflate().
            </summary>
            <returns>
            the total number of output bytes.
            </returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Inflater.TotalIn">
            <summary>
            Gets the total number of processed compressed input bytes.
            </summary>
            <returns>
            The total number of bytes of processed input bytes.
            </returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Inflater.RemainingInput">
            <summary>
            Gets the number of unprocessed input bytes.  Useful, if the end of the
            stream is reached and you want to further process the bytes after
            the deflate stream.
            </summary>
            <returns>
            The number of bytes of the input which have not been processed.
            </returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.InflaterDynHeader.AttemptRead">
            <summary>
            Continue decoding header from <see cref="F:GameDevWare.Charon.Packages.Zip.Compression.InflaterDynHeader.input"/> until more bits are needed or decoding has been completed
            </summary>
            <returns>Returns whether decoding could be completed</returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.InflaterDynHeader.LiteralLengthTree">
            <summary>
            Get literal/length huffman tree, must not be used before <see cref="M:GameDevWare.Charon.Packages.Zip.Compression.InflaterDynHeader.AttemptRead"/> has returned true
            </summary>
            <exception cref="T:GameDevWare.Charon.Packages.StreamDecodingException">If hader has not been successfully read by the state machine</exception>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.InflaterDynHeader.DistanceTree">
            <summary>
            Get distance huffman tree, must not be used before <see cref="M:GameDevWare.Charon.Packages.Zip.Compression.InflaterDynHeader.AttemptRead"/> has returned true
            </summary>
            <exception cref="T:GameDevWare.Charon.Packages.StreamDecodingException">If hader has not been successfully read by the state machine</exception>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.Compression.InflaterHuffmanTree">
            <summary>
            Huffman tree used for inflation
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.InflaterHuffmanTree.defLitLenTree">
            <summary>
            Literal length tree
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.InflaterHuffmanTree.defDistTree">
            <summary>
            Distance tree
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.InflaterHuffmanTree.#ctor(System.ArraySegment{System.Byte})">
            <summary>
            Constructs a Huffman tree from the array of code lengths.
            </summary>
            <param name = "codeLengths">
            the array of code lengths
            </param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.InflaterHuffmanTree.GetSymbol(GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator)">
            <summary>
            Reads the next symbol from input.  The symbol is encoded using the
            huffman tree.
            </summary>
            <param name="input">
            input the input source.
            </param>
            <returns>
            the next symbol, or -1 if not enough input is available.
            </returns>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer">
            <summary>
            An input buffer customised for use by <see cref="T:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream"/>
            </summary>
            <remarks>
            The buffer supports decryption of incoming data.
            </remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream)">
            <summary>
            Initialise a new instance of <see cref="T:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer"/> with a default buffer size
            </summary>
            <param name="stream">The stream to buffer.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Initialise a new instance of <see cref="T:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer"/>
            </summary>
            <param name="stream">The stream to buffer.</param>
            <param name="bufferSize">The size to use for the buffer</param>
            <remarks>A minimum buffer size of 1KB is permitted.  Lower sizes are treated as 1KB.</remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.RawLength">
            <summary>
            Get the length of bytes bytes in the <see cref="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.RawData"/>
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.RawData">
            <summary>
            Get the contents of the raw data buffer.
            </summary>
            <remarks>This may contain encrypted data.</remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.ClearTextLength">
            <summary>
            Get the number of useable bytes in <see cref="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.ClearText"/>
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.ClearText">
            <summary>
            Get the contents of the clear text buffer.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.Available">
            <summary>
            Get/set the number of bytes available
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.SetInflaterInput(GameDevWare.Charon.Packages.Zip.Compression.Inflater)">
            <summary>
            Call <see cref="M:GameDevWare.Charon.Packages.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)"/> passing the current clear text buffer contents.
            </summary>
            <param name="inflater">The inflater to set input for.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.Fill">
            <summary>
            Fill the buffer from the underlying input stream.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[])">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="buffer">The buffer to fill</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="outBuffer">The buffer to read into</param>
            <param name="offset">The offset to start reading data into.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.ReadClearTextBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read clear text data from the input stream.
            </summary>
            <param name="outBuffer">The buffer to add data to.</param>
            <param name="offset">The offset to start adding data at.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes actually read.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.ReadLeByte">
            <summary>
            Read a <see cref="T:System.Byte"/> from the input stream.
            </summary>
            <returns>Returns the byte read.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.ReadLeShort">
            <summary>
            Read an <see cref="T:System.Int16"/> in little endian byte order.
            </summary>
            <returns>The short value read case to an int.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.ReadLeInt">
            <summary>
            Read an <see cref="T:System.Int32"/> in little endian byte order.
            </summary>
            <returns>The int value read.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.ReadLeLong">
            <summary>
            Read a <see cref="T:System.Int64"/> in little endian byte order.
            </summary>
            <returns>The long value read.</returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer.CryptoTransform">
            <summary>
            Get/set the <see cref="T:System.Security.Cryptography.ICryptoTransform"/> to apply to any data.
            </summary>
            <remarks>Set this value to null to have no transform applied.</remarks>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream">
             <summary>
             This filter stream is used to decompress data compressed using the "deflate"
             format. The "deflate" format is described in RFC 1951.
            
             This stream may form the basis for other decompression filters, such
             as the <see cref="!:ICSharpCode.SharpZipLib.GZip.GZipInputStream">GZipInputStream</see>.
            
             Author of the original java version : John Leuner.
             </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream)">
            <summary>
            Create an InflaterInputStream with the default decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,GameDevWare.Charon.Packages.Zip.Compression.Inflater)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The source of input data
            </param>
            <param name = "inf">
            The decompressor used to decompress data read from baseInputStream
            </param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,GameDevWare.Charon.Packages.Zip.Compression.Inflater,System.Int32)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and the specified buffer size.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
            <param name = "inflater">
            The decompressor to use
            </param>
            <param name = "bufferSize">
            Size of the buffer to use
            </param>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner">
            <summary>
            Gets or sets a flag indicating ownership of underlying stream.
            When the flag is true <see cref="M:System.IO.Stream.Dispose" /> will close the underlying stream also.
            </summary>
            <remarks>The default value is true.</remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.Skip(System.Int64)">
            <summary>
            Skip specified number of bytes of uncompressed data
            </summary>
            <param name ="count">
            Number of bytes to skip
            </param>
            <returns>
            The number of bytes skipped, zero if the end of
            stream has been reached
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="count">The number of bytes</paramref> to skip is less than or equal to zero.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.StopDecrypting">
            <summary>
            Clear any cryptographic state.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.Available">
            <summary>
            Returns 0 once the end of the stream (EOF) has been reached.
            Otherwise returns 1.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.Fill">
            <summary>
            Fills the buffer with more data to decompress.
            </summary>
            <exception cref="T:GameDevWare.Charon.Packages.SharpZipBaseException">
            Stream ends early
            </exception>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.CanSeek">
            <summary>
            Gets a value of false indicating seeking is not supported for this stream.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.CanWrite">
            <summary>
            Gets a value of false indicating that this stream is not writeable.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.Length">
            <summary>
            A value representing the length of the stream in bytes.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.Position">
            <summary>
            The current position within the stream.
            Throws a NotSupportedException when attempting to set the position
            </summary>
            <exception cref="T:System.NotSupportedException">Attempting to set the position</exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.Flush">
            <summary>
            Flushes the baseInputStream
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="offset">The relative offset to seek to.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> defining where to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.SetLength(System.Int64)">
            <summary>
            Set the length of the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="value">The new length value for the stream.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to stream and advances the current position
            This method always throws a NotSupportedException
            </summary>
            <param name="buffer">Thew buffer containing data to write.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.WriteByte(System.Byte)">
            <summary>
            Writes one byte to the current stream and advances the current position
            Always throws a NotSupportedException
            </summary>
            <param name="value">The byte to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.Dispose(System.Boolean)">
            <summary>
            Closes the input stream.  When <see cref="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner"></see>
            is true the underlying stream is also closed.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads decompressed data into the provided buffer byte array
            </summary>
            <param name ="buffer">
            The array to read and decompress data into
            </param>
            <param name ="offset">
            The offset indicating where the data should be placed
            </param>
            <param name ="count">
            The number of bytes to decompress
            </param>
            <returns>The number of bytes read.  Zero signals the end of stream</returns>
            <exception cref="T:GameDevWare.Charon.Packages.SharpZipBaseException">
            Inflater needs a dictionary
            </exception>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.inf">
            <summary>
            Decompressor for this stream
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.inputBuffer">
            <summary>
            <see cref="T:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputBuffer">Input buffer</see> for this stream.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.baseInputStream">
            <summary>
            Base stream the inflater reads from.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.csize">
            <summary>
            The compressed size
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream.isClosed">
            <summary>
            Flag indicating wether this instance has been closed or not.
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.Compression.Streams.OutputWindow">
            <summary>
            Contains the output from the Inflation process.
            We need to have a window so that we can refer backwards into the output stream
            to repeat stuff.<br/>
            Author of the original java version : John Leuner
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.OutputWindow.Write(System.Int32)">
            <summary>
            Write a byte to this output window
            </summary>
            <param name="value">value to write</param>
            <exception cref="T:System.InvalidOperationException">
            if window is full
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.OutputWindow.Repeat(System.Int32,System.Int32)">
            <summary>
            Append a byte pattern already in the window itself
            </summary>
            <param name="length">length of pattern to copy</param>
            <param name="distance">distance from end of window pattern occurs</param>
            <exception cref="T:System.InvalidOperationException">
            If the repeated data overflows the window
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.OutputWindow.CopyStored(GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator,System.Int32)">
            <summary>
            Copy from input manipulator to internal window
            </summary>
            <param name="input">source of data</param>
            <param name="length">length of data to copy</param>
            <returns>the number of bytes copied</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.OutputWindow.CopyDict(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy dictionary to window
            </summary>
            <param name="dictionary">source dictionary</param>
            <param name="offset">offset of start in source dictionary</param>
            <param name="length">length of dictionary</param>
            <exception cref="T:System.InvalidOperationException">
            If window isnt empty
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.OutputWindow.GetFreeSpace">
            <summary>
            Get remaining unfilled space in window
            </summary>
            <returns>Number of bytes left in window</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.OutputWindow.GetAvailable">
            <summary>
            Get bytes available for output in window
            </summary>
            <returns>Number of bytes filled</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.OutputWindow.CopyOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy contents of window to output
            </summary>
            <param name="output">buffer to copy to</param>
            <param name="offset">offset to start at</param>
            <param name="len">number of bytes to count</param>
            <returns>The number of bytes copied</returns>
            <exception cref="T:System.InvalidOperationException">
            If a window underflow occurs
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.OutputWindow.Reset">
            <summary>
            Reset by clearing window so <see cref="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.OutputWindow.GetAvailable">GetAvailable</see> returns 0
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator">
             <summary>
             This class allows us to retrieve a specified number of bits from
             the input buffer, as well as copy big byte blocks.
            
             It uses an int buffer to store up to 31 bits for direct
             manipulation.  This guarantees that we can get at least 16 bits,
             but we only need at most 15, so this is all safe.
            
             There are some optimizations in this class, for example, you must
             never peek more than 8 bits more than needed, and you must first
             peek bits before you may drop them.  This is not a general purpose
             class but optimized for the behaviour of the Inflater.
            
             authors of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)">
            <summary>
            Get the next sequence of bits but don't increase input pointer.  bitCount must be
            less or equal 16 and if this call succeeds, you must drop
            at least n - 8 bits in the next call.
            </summary>
            <param name="bitCount">The number of bits to peek.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.  */
            </returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.TryGetBits(System.Int32,System.Int32@,System.Int32)">
            <summary>
            Tries to grab the next <paramref name="bitCount"/> bits from the input and
            sets <paramref name="output"/> to the value, adding <paramref name="outputOffset"/>.
            </summary>
            <returns>true if enough bits could be read, otherwise false</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.TryGetBits(System.Int32,System.Byte[]@,System.Int32)">
            <summary>
            Tries to grab the next <paramref name="bitCount"/> bits from the input and
            sets <paramref name="index"/> of <paramref name="array"/> to the value.
            </summary>
            <returns>true if enough bits could be read, otherwise false</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)">
            <summary>
            Drops the next n bits from the input.  You should have called PeekBits
            with a bigger or equal n before, to make sure that enough bits are in
            the bit buffer.
            </summary>
            <param name="bitCount">The number of bits to drop.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.GetBits(System.Int32)">
            <summary>
            Gets the next n bits and increases input pointer.  This is equivalent
            to <see cref="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)"/> followed by <see cref="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)"/>, except for correct error handling.
            </summary>
            <param name="bitCount">The number of bits to retrieve.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.
            </returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.AvailableBits">
            <summary>
            Gets the number of bits available in the bit buffer.  This must be
            only called when a previous PeekBits() returned -1.
            </summary>
            <returns>
            the number of bits available.
            </returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.AvailableBytes">
            <summary>
            Gets the number of bytes available.
            </summary>
            <returns>
            The number of bytes available.
            </returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.SkipToByteBoundary">
            <summary>
            Skips to the next byte boundary.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.IsNeedingInput">
            <summary>
            Returns true when SetInput can be called
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.CopyBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies bytes from input buffer to output buffer starting
            at output[offset].  You have to make sure, that the buffer is
            byte aligned.  If not enough bytes are available, copies fewer
            bytes.
            </summary>
            <param name="output">
            The buffer to copy bytes to.
            </param>
            <param name="offset">
            The offset in the buffer at which copying starts
            </param>
            <param name="length">
            The length to copy, 0 is allowed.
            </param>
            <returns>
            The number of bytes copied, 0 if no bytes were available.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Length is less than zero
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Bit buffer isnt byte aligned
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.Reset">
            <summary>
            Resets state and empties internal buffers
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.Compression.Streams.StreamManipulator.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add more input for consumption.
            Only call when IsNeedingInput returns true
            </summary>
            <param name="buffer">data to be input</param>
            <param name="offset">offset of first byte of input</param>
            <param name="count">number of bytes of input to add.</param>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.DescriptorData">
            <summary>
            Holds data pertinent to a data descriptor.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.DescriptorData.CompressedSize">
            <summary>
            Get /set the compressed size of data.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.DescriptorData.Size">
            <summary>
            Get / set the uncompressed size of data
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.DescriptorData.Crc">
            <summary>
            Get /set the crc value.
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.TestOperation">
            <summary>
            The operation in progress reported by a <see cref="T:GameDevWare.Charon.Packages.Zip.ZipTestResultHandler"/> during testing.
            </summary>
            <seealso cref="M:GameDevWare.Charon.Packages.Zip.ZipFile.TestArchive(System.Boolean)">TestArchive</seealso>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.TestOperation.Initialising">
            <summary>
            Setting up testing.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.TestOperation.EntryHeader">
            <summary>
            Testing an individual entries header
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.TestOperation.EntryData">
            <summary>
            Testing an individual entries data
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.TestOperation.EntryComplete">
            <summary>
            Testing an individual entry has completed.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.TestOperation.MiscellaneousTests">
            <summary>
            Running miscellaneous tests
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.TestOperation.Complete">
            <summary>
            Testing is complete
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.TestStatus">
            <summary>
            Status returned returned by <see cref="T:GameDevWare.Charon.Packages.Zip.ZipTestResultHandler"/> during testing.
            </summary>
            <seealso cref="M:GameDevWare.Charon.Packages.Zip.ZipFile.TestArchive(System.Boolean)">TestArchive</seealso>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.TestStatus.#ctor(GameDevWare.Charon.Packages.Zip.ZipFile)">
            <summary>
            Initialise a new instance of <see cref="T:GameDevWare.Charon.Packages.Zip.TestStatus"/>
            </summary>
            <param name="file">The <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile"/> this status applies to.</param>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.TestStatus.Operation">
            <summary>
            Get the current <see cref="T:GameDevWare.Charon.Packages.Zip.TestOperation"/> in progress.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.TestStatus.File">
            <summary>
            Get the <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile"/> this status is applicable to.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.TestStatus.Entry">
            <summary>
            Get the current/last entry tested.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.TestStatus.ErrorCount">
            <summary>
            Get the number of errors detected so far.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.TestStatus.BytesTested">
            <summary>
            Get the number of bytes tested so far for the current entry.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.TestStatus.EntryValid">
            <summary>
            Get a value indicating wether the last entry test was valid.
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.TestStrategy">
            <summary>
            The strategy to apply to testing.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.TestStrategy.FindFirstError">
            <summary>
            Find the first error only.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.TestStrategy.FindAllErrors">
            <summary>
            Find all possible errors.
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipConstants">
            <summary>
            This class contains constants used for Zip format files
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.VersionMadeBy">
            <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
            <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry.  See <see cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.CanDecompress"/>.
            </remarks>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.VERSION_MADE_BY">
            <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
            <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry.  See <see cref="P:GameDevWare.Charon.Packages.Zip.ZipInputStream.CanDecompressEntry">ZipInputStream.CanDecompressEntry</see>.
            </remarks>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.VersionStrongEncryption">
            <summary>
            The minimum version required to support strong encryption
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.VERSION_STRONG_ENCRYPTION">
            <summary>
            The minimum version required to support strong encryption
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.VERSION_AES">
            <summary>
            Version indicating AES encryption
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.VersionZip64">
            <summary>
            The version required for Zip64 extensions (4.5 or higher)
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.LocalHeaderBaseSize">
            <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.LOCHDR">
            <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.Zip64DataDescriptorSize">
            <summary>
            Size of Zip64 data descriptor
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.DataDescriptorSize">
            <summary>
            Size of data descriptor
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.EXTHDR">
            <summary>
            Size of data descriptor
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.CentralHeaderBaseSize">
            <summary>
            Size of central header entry (excluding variable fields)
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.CENHDR">
            <summary>
            Size of central header entry
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.EndOfCentralRecordBaseSize">
            <summary>
            Size of end of central record (excluding variable fields)
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.ENDHDR">
            <summary>
            Size of end of central record (excluding variable fields)
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.CryptoHeaderSize">
            <summary>
            Size of 'classic' cryptographic header stored before any entry data
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.CRYPTO_HEADER_SIZE">
            <summary>
            Size of cryptographic header stored before entry data
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.LocalHeaderSignature">
            <summary>
            Signature for local entry header
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.LOCSIG">
            <summary>
            Signature for local entry header
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.SpanningSignature">
            <summary>
            Signature for spanning entry
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.SPANNINGSIG">
            <summary>
            Signature for spanning entry
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.SpanningTempSignature">
            <summary>
            Signature for temporary spanning entry
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.SPANTEMPSIG">
            <summary>
            Signature for temporary spanning entry
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.DataDescriptorSignature">
            <summary>
            Signature for data descriptor
            </summary>
            <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.EXTSIG">
            <summary>
            Signature for data descriptor
            </summary>
            <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.CENSIG">
            <summary>
            Signature for central header
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.CentralHeaderSignature">
            <summary>
            Signature for central header
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.Zip64CentralFileHeaderSignature">
            <summary>
            Signature for Zip64 central file header
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.CENSIG64">
            <summary>
            Signature for Zip64 central file header
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.Zip64CentralDirLocatorSignature">
            <summary>
            Signature for Zip64 central directory locator
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.ArchiveExtraDataSignature">
            <summary>
            Signature for archive extra data signature (were headers are encrypted).
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.CentralHeaderDigitalSignature">
            <summary>
            Central header digitial signature
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.CENDIGITALSIG">
            <summary>
            Central header digitial signature
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.EndOfCentralDirectorySignature">
            <summary>
            End of central directory record signature
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipConstants.ENDSIG">
            <summary>
            End of central directory record signature
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipConstants.DefaultCodePage">
            <summary>
            Default encoding used for string conversion.  0 gives the default system OEM code page.
            Using the default code page isnt the full solution neccessarily
            there are many variable factors, codepage 850 is often a good choice for
            European users, however be careful about compatability.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipConstants.ConvertToString(System.Byte[],System.Int32)">
            <summary> Depracated wrapper for <see cref="M:GameDevWare.Charon.Packages.Zip.ZipStrings.ConvertToString(System.Byte[],System.Int32)"/></summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipConstants.ConvertToString(System.Byte[])">
            <summary> Depracated wrapper for <see cref="M:GameDevWare.Charon.Packages.Zip.ZipStrings.ConvertToString(System.Byte[])"/></summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[],System.Int32)">
            <summary> Depracated wrapper for <see cref="M:GameDevWare.Charon.Packages.Zip.ZipStrings.ConvertToStringExt(System.Int32,System.Byte[],System.Int32)"/></summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[])">
            <summary> Depracated wrapper for <see cref="M:GameDevWare.Charon.Packages.Zip.ZipStrings.ConvertToStringExt(System.Int32,System.Byte[])"/></summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipConstants.ConvertToArray(System.String)">
            <summary> Depracated wrapper for <see cref="M:GameDevWare.Charon.Packages.Zip.ZipStrings.ConvertToArray(System.String)"/></summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipConstants.ConvertToArray(System.Int32,System.String)">
            <summary> Depracated wrapper for <see cref="M:GameDevWare.Charon.Packages.Zip.ZipStrings.ConvertToArray(System.Int32,System.String)"/></summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.HostSystemID">
            <summary>
            Defines known values for the <see cref="T:GameDevWare.Charon.Packages.Zip.HostSystemID"/> property.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.Msdos">
            <summary>
            Host system = MSDOS
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.Amiga">
            <summary>
            Host system = Amiga
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.OpenVms">
            <summary>
            Host system = Open VMS
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.Unix">
            <summary>
            Host system = Unix
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.VMCms">
            <summary>
            Host system = VMCms
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.AtariST">
            <summary>
            Host system = Atari ST
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.OS2">
            <summary>
            Host system = OS2
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.Macintosh">
            <summary>
            Host system = Macintosh
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.ZSystem">
            <summary>
            Host system = ZSystem
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.Cpm">
            <summary>
            Host system = Cpm
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.WindowsNT">
            <summary>
            Host system = Windows NT
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.MVS">
            <summary>
            Host system = MVS
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.Vse">
            <summary>
            Host system = VSE
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.AcornRisc">
            <summary>
            Host system = Acorn RISC
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.Vfat">
            <summary>
            Host system = VFAT
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.AlternateMvs">
            <summary>
            Host system = Alternate MVS
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.BeOS">
            <summary>
            Host system = BEOS
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.Tandem">
            <summary>
            Host system = Tandem
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.OS400">
            <summary>
            Host system = OS400
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.OSX">
            <summary>
            Host system = OSX
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.HostSystemID.WinZipAES">
            <summary>
            Host system = WinZIP AES
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipEntry">
            <summary>
            This class represents an entry in a zip archive.  This can be a file
            or a directory
            ZipFile and ZipInputStream will give you instances of this class as
            information about the members in an archive.  ZipOutputStream
            uses an instance of this class when creating an entry in a Zip file.
            <br/>
            <br/>Author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.#ctor(System.String)">
            <summary>
            Creates a zip entry with the given name.
            </summary>
            <param name="name">
            The name for this entry. Can include directory components.
            The convention for names is 'unix' style paths with relative names only.
            There are with no device names and path elements are separated by '/' characters.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.#ctor(System.String,System.Int32)">
            <summary>
            Creates a zip entry with the given name and version required to extract
            </summary>
            <param name="name">
            The name for this entry. Can include directory components.
            The convention for names is 'unix'  style paths with no device names and
            path elements separated by '/' characters.  This is not enforced see <see cref="M:GameDevWare.Charon.Packages.Zip.ZipEntry.CleanName(System.String)">CleanName</see>
            on how to ensure names are valid if this is desired.
            </param>
            <param name="versionRequiredToExtract">
            The minimum 'feature version' required this entry
            </param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.#ctor(System.String,System.Int32,System.Int32,GameDevWare.Charon.Packages.Zip.CompressionMethod)">
            <summary>
            Initializes an entry with the given name and made by information
            </summary>
            <param name="name">Name for this entry</param>
            <param name="madeByInfo">Version and HostSystem Information</param>
            <param name="versionRequiredToExtract">Minimum required zip feature version required to extract this entry</param>
            <param name="method">Compression method for this entry.</param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            versionRequiredToExtract should be 0 (auto-calculate) or > 10
            </exception>
            <remarks>
            This constructor is used by the ZipFile class when reading from the central header
            It is not generally useful, use the constructor specifying the name only.
            </remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.#ctor(GameDevWare.Charon.Packages.Zip.ZipEntry)">
            <summary>
            Creates a deep copy of the given zip entry.
            </summary>
            <param name="entry">
            The entry to copy.
            </param>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.HasCrc">
            <summary>
            Get a value indicating wether the entry has a CRC value available.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.IsCrypted">
            <summary>
            Get/Set flag indicating if entry is encrypted.
            A simple helper routine to aid interpretation of <see cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.Flags">flags</see>
            </summary>
            <remarks>This is an assistant that interprets the <see cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.Flags">flags</see> property.</remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.IsUnicodeText">
            <summary>
            Get / set a flag indicating wether entry name and comment text are
            encoded in <a href="http://www.unicode.org">unicode UTF8</a>.
            </summary>
            <remarks>This is an assistant that interprets the <see cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.Flags">flags</see> property.</remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.CryptoCheckValue">
            <summary>
            Value used during password checking for PKZIP 2.0 / 'classic' encryption.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.Flags">
            <summary>
            Get/Set general purpose bit flag for entry
            </summary>
            <remarks>
            General purpose bit flag<br/>
            <br/>
            Bit 0: If set, indicates the file is encrypted<br/>
            Bit 1-2 Only used for compression type 6 Imploding, and 8, 9 deflating<br/>
            Imploding:<br/>
            Bit 1 if set indicates an 8K sliding dictionary was used.  If clear a 4k dictionary was used<br/>
            Bit 2 if set indicates 3 Shannon-Fanno trees were used to encode the sliding dictionary, 2 otherwise<br/>
            <br/>
            Deflating:<br/>
              Bit 2    Bit 1<br/>
                0        0       Normal compression was used<br/>
                0        1       Maximum compression was used<br/>
                1        0       Fast compression was used<br/>
                1        1       Super fast compression was used<br/>
            <br/>
            Bit 3: If set, the fields crc-32, compressed size
            and uncompressed size are were not able to be written during zip file creation
            The correct values are held in a data descriptor immediately following the compressed data. <br/>
            Bit 4: Reserved for use by PKZIP for enhanced deflating<br/>
            Bit 5: If set indicates the file contains compressed patch data<br/>
            Bit 6: If set indicates strong encryption was used.<br/>
            Bit 7-10: Unused or reserved<br/>
            Bit 11: If set the name and comments for this entry are in <a href="http://www.unicode.org">unicode</a>.<br/>
            Bit 12-15: Unused or reserved<br/>
            </remarks>
            <seealso cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.IsUnicodeText"></seealso>
            <seealso cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.IsCrypted"></seealso>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.ZipFileIndex">
            <summary>
            Get/Set index of this entry in Zip file
            </summary>
            <remarks>This is only valid when the entry is part of a <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile"></see></remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.Offset">
            <summary>
            Get/set offset for use in central header
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.ExternalFileAttributes">
            <summary>
            Get/Set external file attributes as an integer.
            The values of this are operating system dependant see
            <see cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.HostSystem">HostSystem</see> for details
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.VersionMadeBy">
            <summary>
            Get the version made by for this entry or zero if unknown.
            The value / 10 indicates the major version number, and
            the value mod 10 is the minor version number
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.IsDOSEntry">
            <summary>
            Get a value indicating this entry is for a DOS/Windows system.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.HasDosAttributes(System.Int32)">
            <summary>
            Test the external attributes for this <see cref="T:GameDevWare.Charon.Packages.Zip.ZipEntry"/> to
            see if the external attributes are Dos based (including WINNT and variants)
            and match the values
            </summary>
            <param name="attributes">The attributes to test.</param>
            <returns>Returns true if the external attributes are known to be DOS/Windows
            based and have the same attributes set as the value passed.</returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.HostSystem">
             <summary>
             Gets the compatability information for the <see cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.ExternalFileAttributes">external file attribute</see>
             If the external file attributes are compatible with MS-DOS and can be read
             by PKZIP for DOS version 2.04g then this value will be zero.  Otherwise the value
             will be non-zero and identify the host system on which the attributes are compatible.
             </summary>
            
             <remarks>
             The values for this as defined in the Zip File format and by others are shown below.  The values are somewhat
             misleading in some cases as they are not all used as shown.  You should consult the relevant documentation
             to obtain up to date and correct information.  The modified appnote by the infozip group is
             particularly helpful as it documents a lot of peculiarities.  The document is however a little dated.
             <list type="table">
             <item>0 - MS-DOS and OS/2 (FAT / VFAT / FAT32 file systems)</item>
             <item>1 - Amiga</item>
             <item>2 - OpenVMS</item>
             <item>3 - Unix</item>
             <item>4 - VM/CMS</item>
             <item>5 - Atari ST</item>
             <item>6 - OS/2 HPFS</item>
             <item>7 - Macintosh</item>
             <item>8 - Z-System</item>
             <item>9 - CP/M</item>
             <item>10 - Windows NTFS</item>
             <item>11 - MVS (OS/390 - Z/OS)</item>
             <item>12 - VSE</item>
             <item>13 - Acorn Risc</item>
             <item>14 - VFAT</item>
             <item>15 - Alternate MVS</item>
             <item>16 - BeOS</item>
             <item>17 - Tandem</item>
             <item>18 - OS/400</item>
             <item>19 - OS/X (Darwin)</item>
             <item>99 - WinZip AES</item>
             <item>remainder - unused</item>
             </list>
             </remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.Version">
            <summary>
            Get minimum Zip feature version required to extract this entry
            </summary>
            <remarks>
            Minimum features are defined as:<br/>
            1.0 - Default value<br/>
            1.1 - File is a volume label<br/>
            2.0 - File is a folder/directory<br/>
            2.0 - File is compressed using Deflate compression<br/>
            2.0 - File is encrypted using traditional encryption<br/>
            2.1 - File is compressed using Deflate64<br/>
            2.5 - File is compressed using PKWARE DCL Implode<br/>
            2.7 - File is a patch data set<br/>
            4.5 - File uses Zip64 format extensions<br/>
            4.6 - File is compressed using BZIP2 compression<br/>
            5.0 - File is encrypted using DES<br/>
            5.0 - File is encrypted using 3DES<br/>
            5.0 - File is encrypted using original RC2 encryption<br/>
            5.0 - File is encrypted using RC4 encryption<br/>
            5.1 - File is encrypted using AES encryption<br/>
            5.1 - File is encrypted using corrected RC2 encryption<br/>
            5.1 - File is encrypted using corrected RC2-64 encryption<br/>
            6.1 - File is encrypted using non-OAEP key wrapping<br/>
            6.2 - Central directory encryption (not confirmed yet)<br/>
            6.3 - File is compressed using LZMA<br/>
            6.3 - File is compressed using PPMD+<br/>
            6.3 - File is encrypted using Blowfish<br/>
            6.3 - File is encrypted using Twofish<br/>
            </remarks>
            <seealso cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.CanDecompress"></seealso>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.CanDecompress">
            <summary>
            Get a value indicating whether this entry can be decompressed by the library.
            </summary>
            <remarks>This is based on the <see cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.Version"></see> and
            wether the <see cref="M:GameDevWare.Charon.Packages.Zip.ZipEntry.IsCompressionMethodSupported">compression method</see> is supported.</remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.ForceZip64">
            <summary>
            Force this entry to be recorded using Zip64 extensions.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.IsZip64Forced">
            <summary>
            Get a value indicating wether Zip64 extensions were forced.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value of true if Zip64 extensions have been forced on; false if not.</returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.LocalHeaderRequiresZip64">
            <summary>
            Gets a value indicating if the entry requires Zip64 extensions
            to store the full entry values.
            </summary>
            <value>A <see cref="T:System.Boolean"/> value of true if a local header requires Zip64 extensions; false if not.</value>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.CentralHeaderRequiresZip64">
            <summary>
            Get a value indicating wether the central directory entry requires Zip64 extensions to be stored.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.DosTime">
            <summary>
            Get/Set DosTime value.
            </summary>
            <remarks>
            The MS-DOS date format can only represent dates between 1/1/1980 and 12/31/2107.
            </remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.DateTime">
            <summary>
            Gets/Sets the time of last modification of the entry.
            </summary>
            <remarks>
            The <see cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.DosTime"></see> property is updated to match this as far as possible.
            </remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.Name">
             <summary>
             Returns the entry name.
             </summary>
             <remarks>
             The unix naming convention is followed.
             Path components in the entry should always separated by forward slashes ('/').
             Dos device names like C: should also be removed.
             See the <see cref="!:ZipNameTransform"/> class, or <see cref="M:GameDevWare.Charon.Packages.Zip.ZipEntry.CleanName(System.String)"/>
            </remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.Size">
            <summary>
            Gets/Sets the size of the uncompressed data.
            </summary>
            <returns>
            The size or -1 if unknown.
            </returns>
            <remarks>Setting the size before adding an entry to an archive can help
            avoid compatability problems with some archivers which dont understand Zip64 extensions.</remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.CompressedSize">
            <summary>
            Gets/Sets the size of the compressed data.
            </summary>
            <returns>
            The compressed entry size or -1 if unknown.
            </returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.Crc">
            <summary>
            Gets/Sets the crc of the uncompressed data.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Crc is not in the range 0..0xffffffffL
            </exception>
            <returns>
            The crc value or -1 if unknown.
            </returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.CompressionMethod">
            <summary>
            Gets/Sets the compression method. Only Deflated and Stored are supported.
            </summary>
            <returns>
            The compression method for this entry
            </returns>
            <see cref="F:GameDevWare.Charon.Packages.Zip.CompressionMethod.Deflated"/>
            <see cref="F:GameDevWare.Charon.Packages.Zip.CompressionMethod.Stored"/>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.CompressionMethodForHeader">
            <summary>
            Gets the compression method for outputting to the local or central header.
            Returns same value as CompressionMethod except when AES encrypting, which
            places 99 in the method and places the real method in the extra data.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.ExtraData">
            <summary>
            Gets/Sets the extra data.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Extra data is longer than 64KB (0xffff) bytes.
            </exception>
            <returns>
            Extra data or null if not set.
            </returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.AESKeySize">
            <summary>
            For AES encrypted files returns or sets the number of bits of encryption (128, 192 or 256).
            When setting, only 0 (off), 128 or 256 is supported.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.AESEncryptionStrength">
            <summary>
            AES Encryption strength for storage in extra data in entry header.
            1 is 128 bit, 2 is 192 bit, 3 is 256 bit.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.AESSaltLen">
            <summary>
            Returns the length of the salt, in bytes
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.AESOverheadSize">
            <summary>
            Number of extra bytes required to hold the AES Header fields (Salt, Pwd verify, AuthCode)
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.ProcessExtraData(System.Boolean)">
            <summary>
            Process extra data fields updating the entry based on the contents.
            </summary>
            <param name="localHeader">True if the extra data fields should be handled
            for a local header, rather than for a central header.
            </param>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.Comment">
            <summary>
            Gets/Sets the entry comment.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If comment is longer than 0xffff.
            </exception>
            <returns>
            The comment or null if not set.
            </returns>
            <remarks>
            A comment is only available for entries when read via the <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile"/> class.
            The <see cref="T:GameDevWare.Charon.Packages.Zip.ZipInputStream"/> class doesnt have the comment data available.
            </remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.IsDirectory">
            <summary>
            Gets a value indicating if the entry is a directory.
            however.
            </summary>
            <remarks>
            A directory is determined by an entry name with a trailing slash '/'.
            The external file attributes can also indicate an entry is for a directory.
            Currently only dos/windows attributes are tested in this manner.
            The trailing slash convention should always be followed.
            </remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipEntry.IsFile">
            <summary>
            Get a value of true if the entry appears to be a file; false otherwise
            </summary>
            <remarks>
            This only takes account of DOS/Windows attributes.  Other operating systems are ignored.
            For linux and others the result may be incorrect.
            </remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.IsCompressionMethodSupported">
            <summary>
            Test entry to see if data can be extracted.
            </summary>
            <returns>Returns true if data can be extracted for this entry; false otherwise.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.Clone">
            <summary>
            Creates a copy of this zip entry.
            </summary>
            <returns>An <see cref="T:System.Object"/> that is a copy of the current instance.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.ToString">
            <summary>
            Gets a string representation of this ZipEntry.
            </summary>
            <returns>A readable textual representation of this <see cref="T:GameDevWare.Charon.Packages.Zip.ZipEntry"/></returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.IsCompressionMethodSupported(GameDevWare.Charon.Packages.Zip.CompressionMethod)">
            <summary>
            Test a <see cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.CompressionMethod">compression method</see> to see if this library
            supports extracting data compressed with that method
            </summary>
            <param name="method">The compression method to test.</param>
            <returns>Returns true if the compression method is supported; false otherwise</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipEntry.CleanName(System.String)">
            <summary>
            Cleans a name making it conform to Zip file conventions.
            Devices names ('c:\') and UNC share names ('\\server\share') are removed
            and forward slashes ('\') are converted to back slashes ('/').
            Names are made relative by trimming leading slashes which is compatible
            with the ZIP naming convention.
            </summary>
            <param name="name">The name to clean</param>
            <returns>The 'cleaned' name.</returns>
            <remarks>
            The <seealso cref="!:ZipNameTransform">Zip name transform</seealso> class is more flexible.
            </remarks>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipException">
            <summary>
            ZipException represents exceptions specific to Zip classes and code.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipException.#ctor">
            <summary>
            Initialise a new instance of <see cref="T:GameDevWare.Charon.Packages.Zip.ZipException" />.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipException.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:GameDevWare.Charon.Packages.Zip.ZipException" /> with its message string.
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the error.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Initialise a new instance of <see cref="T:GameDevWare.Charon.Packages.Zip.ZipException" />.
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the error.</param>
            <param name="innerException">The <see cref="T:System.Exception"/> that caused this exception.</param>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ITaggedData">
            <summary>
            ExtraData tagged value interface.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ITaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ITaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the contents of this instance from the data passed.
            </summary>
            <param name="data">The data to extract contents from.</param>
            <param name="offset">The offset to begin extracting data from.</param>
            <param name="count">The number of bytes to extract.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ITaggedData.GetData">
            <summary>
            Get the data representing this instance.
            </summary>
            <returns>Returns the data for this instance.</returns>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.RawTaggedData">
            <summary>
            A raw binary tagged value
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.RawTaggedData.#ctor(System.Int16)">
            <summary>
            Initialise a new instance.
            </summary>
            <param name="tag">The tag ID.</param>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.RawTaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.RawTaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="offset">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.RawTaggedData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.RawTaggedData.Data">
            <summary>
            Get /set the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.RawTaggedData._tag">
            <summary>
            The tag ID for this instance.
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ExtendedUnixData">
            <summary>
            Class representing extended unix date time values.
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.Flags">
            <summary>
            Flags indicate which values are included in this instance.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.Flags.ModificationTime">
            <summary>
            The modification time is included
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.Flags.AccessTime">
            <summary>
            The access time is included
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.Flags.CreateTime">
            <summary>
            The create time is included.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.TagID">
            <summary>
            Get the ID
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="index">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.IsValidValue(System.DateTime)">
            <summary>
            Test a <see cref="T:System.DateTime"> value to see if is valid and can be represented here.</see>
            </summary>
            <param name="value">The <see cref="T:System.DateTime">value</see> to test.</param>
            <returns>Returns true if the value is valid and can be represented; false if not.</returns>
            <remarks>The standard Unix time is a signed integer data type, directly encoding the Unix time number,
            which is the number of seconds since 1970-01-01.
            Being 32 bits means the values here cover a range of about 136 years.
            The minimum representable time is 1901-12-13 20:45:52,
            and the maximum representable time is 2038-01-19 03:14:07.
            </remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.ModificationTime">
            <summary>
            Get /set the Modification Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.AccessTime">
            <summary>
            Get / set the Access Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.CreateTime">
            <summary>
            Get / Set the Create Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.Include">
            <summary>
            Get/set the <see cref="T:GameDevWare.Charon.Packages.Zip.ExtendedUnixData.Flags">values</see> to include.
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.NTTaggedData">
            <summary>
            Class handling NT date time values.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.NTTaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.NTTaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="index">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.NTTaggedData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.NTTaggedData.IsValidValue(System.DateTime)">
            <summary>
            Test a <see cref="T:System.DateTime"> valuie to see if is valid and can be represented here.</see>
            </summary>
            <param name="value">The <see cref="T:System.DateTime">value</see> to test.</param>
            <returns>Returns true if the value is valid and can be represented; false if not.</returns>
            <remarks>
            NTFS filetimes are 64-bit unsigned integers, stored in Intel
            (least significant byte first) byte order. They determine the
            number of 1.0E-07 seconds (1/10th microseconds!) past WinNT "epoch",
            which is "01-Jan-1601 00:00:00 UTC". 28 May 60056 is the upper limit
            </remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.NTTaggedData.LastModificationTime">
            <summary>
            Get/set the <see cref="T:System.DateTime">last modification time</see>.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.NTTaggedData.CreateTime">
            <summary>
            Get /set the <see cref="T:System.DateTime">create time</see>
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.NTTaggedData.LastAccessTime">
            <summary>
            Get /set the <see cref="T:System.DateTime">last access time</see>.
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ITaggedDataFactory">
            <summary>
            A factory that creates <see cref="T:GameDevWare.Charon.Packages.Zip.ITaggedData">tagged data</see> instances.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ITaggedDataFactory.Create(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get data for a specific tag value.
            </summary>
            <param name="tag">The tag ID to find.</param>
            <param name="data">The data to search.</param>
            <param name="offset">The offset to begin extracting data from.</param>
            <param name="count">The number of bytes to extract.</param>
            <returns>The located <see cref="T:GameDevWare.Charon.Packages.Zip.ITaggedData">value found</see>, or null if not found.</returns>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipExtraData">
            
             <summary>
             A class to handle the extra data field for Zip entries
             </summary>
             <remarks>
             Extra data contains 0 or more values each prefixed by a header tag and length.
             They contain zero or more bytes of actual data.
             The data is held internally using a copy on write strategy.  This is more efficient but
             means that for extra data created by passing in data can have the values modified by the caller
             in some circumstances.
             </remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.#ctor">
            <summary>
            Initialise a default instance.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.#ctor(System.Byte[])">
            <summary>
            Initialise with known extra data.
            </summary>
            <param name="data">The extra data.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.GetEntryData">
            <summary>
            Get the raw extra data value
            </summary>
            <returns>Returns the raw byte[] extra data this instance represents.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.Clear">
            <summary>
            Clear the stored data.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipExtraData.Length">
            <summary>
            Gets the current extra data length.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.GetStreamForTag(System.Int32)">
            <summary>
            Get a read-only <see cref="T:System.IO.Stream"/> for the associated tag.
            </summary>
            <param name="tag">The tag to locate data for.</param>
            <returns>Returns a <see cref="T:System.IO.Stream"/> containing tag data or null if no tag was found.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.GetData``1">
            <summary>
            Get the <see cref="T:GameDevWare.Charon.Packages.Zip.ITaggedData">tagged data</see> for a tag.
            </summary>
            <typeparam name="T">The tag to search for.</typeparam>
            <returns>Returns a <see cref="T:GameDevWare.Charon.Packages.Zip.ITaggedData">tagged value</see> or null if none found.</returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipExtraData.ValueLength">
            <summary>
            Get the length of the last value found by <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.Find(System.Int32)"/>
            </summary>
            <remarks>This is only valid if <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.Find(System.Int32)"/> has previously returned true.</remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipExtraData.CurrentReadIndex">
            <summary>
            Get the index for the current read value.
            </summary>
            <remarks>This is only valid if <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.Find(System.Int32)"/> has previously returned true.
            Initially the result will be the index of the first byte of actual data.  The value is updated after calls to
            <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.ReadInt"/>, <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.ReadShort"/> and <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.ReadLong"/>. </remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipExtraData.UnreadCount">
            <summary>
            Get the number of bytes remaining to be read for the current value;
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.Find(System.Int32)">
            <summary>
            Find an extra data value
            </summary>
            <param name="headerID">The identifier for the value to find.</param>
            <returns>Returns true if the value was found; false otherwise.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddEntry(GameDevWare.Charon.Packages.Zip.ITaggedData)">
            <summary>
            Add a new entry to extra data.
            </summary>
            <param name="taggedData">The <see cref="T:GameDevWare.Charon.Packages.Zip.ITaggedData"/> value to add.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddEntry(System.Int32,System.Byte[])">
            <summary>
            Add a new entry to extra data
            </summary>
            <param name="headerID">The ID for this entry.</param>
            <param name="fieldData">The data to add.</param>
            <remarks>If the ID already exists its contents are replaced.</remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.StartNewEntry">
            <summary>
            Start adding a new entry.
            </summary>
            <remarks>Add data using <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddData(System.Byte[])"/>, <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddLeShort(System.Int32)"/>, <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddLeInt(System.Int32)"/>, or <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddLeLong(System.Int64)"/>.
            The new entry is completed and actually added by calling <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddNewEntry(System.Int32)"/></remarks>
            <seealso cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddEntry(GameDevWare.Charon.Packages.Zip.ITaggedData)"/>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddNewEntry(System.Int32)">
            <summary>
            Add entry data added since <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.StartNewEntry"/> using the ID passed.
            </summary>
            <param name="headerID">The identifier to use for this entry.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddData(System.Byte)">
            <summary>
            Add a byte of data to the pending new entry.
            </summary>
            <param name="data">The byte to add.</param>
            <seealso cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddData(System.Byte[])">
            <summary>
            Add data to a pending new entry.
            </summary>
            <param name="data">The data to add.</param>
            <seealso cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddLeShort(System.Int32)">
            <summary>
            Add a short value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddLeInt(System.Int32)">
            <summary>
            Add an integer value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.AddLeLong(System.Int64)">
            <summary>
            Add a long value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.Delete(System.Int32)">
            <summary>
            Delete an extra data field.
            </summary>
            <param name="headerID">The identifier of the field to delete.</param>
            <returns>Returns true if the field was found and deleted.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.ReadLong">
            <summary>
            Read a long in little endian form from the last <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.Find(System.Int32)">found</see> data value
            </summary>
            <returns>Returns the long value read.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.ReadInt">
            <summary>
            Read an integer in little endian form from the last <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.Find(System.Int32)">found</see> data value.
            </summary>
            <returns>Returns the integer read.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.ReadShort">
            <summary>
            Read a short value in little endian form from the last <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.Find(System.Int32)">found</see> data value.
            </summary>
            <returns>Returns the short value read.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.ReadByte">
            <summary>
            Read a byte from an extra data
            </summary>
            <returns>The byte value read or -1 if the end of data has been reached.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.Skip(System.Int32)">
            <summary>
            Skip data during reading.
            </summary>
            <param name="amount">The number of bytes to skip.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.ReadShortInternal">
            <summary>
            Internal form of <see cref="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.ReadShort"/> that reads data at any location.
            </summary>
            <returns>Returns the short value read.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipExtraData.Dispose">
            <summary>
            Dispose of this instance.
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipFile">
             <summary>
             This class represents a Zip archive.  You can ask for the contained
             entries, or get an input stream for a file entry.  The entry is
             automatically decompressed.
            
             You can also update the archive adding or deleting entries.
            
             This class is thread safe for input:  You can open input streams for arbitrary
             entries in different threads.
             <br/>
             <br/>Author of the original java version : Jochen Hoenicke
             </summary>
             <example>
             <code>
             using System;
             using System.Text;
             using System.Collections;
             using System.IO;
            
             using ICSharpCode.SharpZipLib.Zip;
            
             class MainClass
             {
             	static public void Main(string[] args)
             	{
             		using (ZipFile zFile = new ZipFile(args[0])) {
             			Console.WriteLine("Listing of : " + zFile.Name);
             			Console.WriteLine("");
             			Console.WriteLine("Raw Size    Size      Date     Time     Name");
             			Console.WriteLine("--------  --------  --------  ------  ---------");
             			foreach (ZipEntry e in zFile) {
             				if ( e.IsFile ) {
             					DateTime d = e.DateTime;
             					Console.WriteLine("{0, -10}{1, -10}{2}  {3}   {4}", e.Size, e.CompressedSize,
             						d.ToString("dd-MM-yy"), d.ToString("HH:mm"),
             						e.Name);
             				}
             			}
             		}
             	}
             }
             </code>
             </example>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.#ctor(System.String)">
            <summary>
            Opens a Zip file with the given name for reading.
            </summary>
            <param name="name">The name of the file to open.</param>
            <exception cref="T:System.ArgumentNullException">The argument supplied is null.</exception>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">
            The file doesn't contain a valid zip archive.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.#ctor(System.IO.FileStream)">
            <summary>
            Opens a Zip file reading the given <see cref="T:System.IO.FileStream"/>.
            </summary>
            <param name="file">The <see cref="T:System.IO.FileStream"/> to read archive data from.</param>
            <exception cref="T:System.ArgumentNullException">The supplied argument is null.</exception>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">
            The file doesn't contain a valid zip archive.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.#ctor(System.IO.FileStream,System.Boolean)">
            <summary>
            Opens a Zip file reading the given <see cref="T:System.IO.FileStream"/>.
            </summary>
            <param name="file">The <see cref="T:System.IO.FileStream"/> to read archive data from.</param>
            <param name="leaveOpen">true to leave the <see cref="T:System.IO.FileStream">file</see> open when the ZipFile is disposed, false to dispose of it</param>
            <exception cref="T:System.ArgumentNullException">The supplied argument is null.</exception>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">
            The file doesn't contain a valid zip archive.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.#ctor(System.IO.Stream)">
            <summary>
            Opens a Zip file reading the given <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to read archive data from.</param>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">
            The stream doesn't contain a valid zip archive.<br/>
            </exception>
            <exception cref="T:System.ArgumentException">
            The <see cref="T:System.IO.Stream">stream</see> doesnt support seeking.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <see cref="T:System.IO.Stream">stream</see> argument is null.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Opens a Zip file reading the given <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to read archive data from.</param>
            <param name="leaveOpen">true to leave the <see cref="T:System.IO.Stream">stream</see> open when the ZipFile is disposed, false to dispose of it</param>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">
            The stream doesn't contain a valid zip archive.<br/>
            </exception>
            <exception cref="T:System.ArgumentException">
            The <see cref="T:System.IO.Stream">stream</see> doesnt support seeking.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <see cref="T:System.IO.Stream">stream</see> argument is null.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.#ctor">
            <summary>
            Initialises a default <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile"/> instance with no entries and no file storage.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.Finalize">
            <summary>
            Finalize this instance.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.Close">
            <summary>
            Closes the ZipFile.  If the stream is <see cref="P:GameDevWare.Charon.Packages.Zip.ZipFile.IsStreamOwner">owned</see> then this also closes the underlying input stream.
            Once closed, no further instance methods should be called.
            </summary>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.Create(System.String)">
            <summary>
            Create a new <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile"/> whose data will be stored in a file.
            </summary>
            <param name="fileName">The name of the archive to create.</param>
            <returns>Returns the newly created <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fileName"></paramref> is null</exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.Create(System.IO.Stream)">
            <summary>
            Create a new <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile"/> whose data will be stored on a stream.
            </summary>
            <param name="outStream">The stream providing data storage.</param>
            <returns>Returns the newly created <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="outStream"> is null</paramref></exception>
            <exception cref="T:System.ArgumentException"><paramref name="outStream"> doesnt support writing.</paramref></exception>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.IsStreamOwner">
            <summary>
            Get/set a flag indicating if the underlying stream is owned by the ZipFile instance.
            If the flag is true then the stream will be closed when <see cref="M:GameDevWare.Charon.Packages.Zip.ZipFile.Close">Close</see> is called.
            </summary>
            <remarks>
            The default value is true in all cases.
            </remarks>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.IsEmbeddedArchive">
            <summary>
            Get a value indicating wether
            this archive is embedded in another file or not.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.IsNewArchive">
            <summary>
            Get a value indicating that this archive is a new one.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.ZipFileComment">
            <summary>
            Gets the comment for the zip file.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.Name">
            <summary>
            Gets the name of this zip file.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.Size">
            <summary>
            Gets the number of entries in this zip file.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The Zip file has been closed.
            </exception>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.Count">
            <summary>
            Get the number of entries contained in this <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile"/>.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.EntryByIndex(System.Int32)">
            <summary>
            Indexer property for ZipEntries
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.GetEnumerator">
            <summary>
            Gets an enumerator for the Zip entries in this Zip file.
            </summary>
            <returns>Returns an <see cref="T:System.Collections.IEnumerator"/> for this archive.</returns>
            <exception cref="T:System.ObjectDisposedException">
            The Zip file has been closed.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.FindEntry(System.String,System.Boolean)">
            <summary>
            Return the index of the entry with a matching name
            </summary>
            <param name="name">Entry name to find</param>
            <param name="ignoreCase">If true the comparison is case insensitive</param>
            <returns>The index position of the matching entry or -1 if not found</returns>
            <exception cref="T:System.ObjectDisposedException">
            The Zip file has been closed.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.GetEntry(System.String)">
            <summary>
            Searches for a zip entry in this archive with the given name.
            String comparisons are case insensitive
            </summary>
            <param name="name">
            The name to find. May contain directory components separated by slashes ('/').
            </param>
            <returns>
            A clone of the zip entry, or null if no entry with that name exists.
            </returns>
            <exception cref="T:System.ObjectDisposedException">
            The Zip file has been closed.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.GetInputStream(GameDevWare.Charon.Packages.Zip.ZipEntry)">
            <summary>
            Gets an input stream for reading the given zip entry data in an uncompressed form.
            Normally the <see cref="T:GameDevWare.Charon.Packages.Zip.ZipEntry"/> should be an entry returned by GetEntry().
            </summary>
            <param name="entry">The <see cref="T:GameDevWare.Charon.Packages.Zip.ZipEntry"/> to obtain a data <see cref="T:System.IO.Stream"/> for</param>
            <returns>An input <see cref="T:System.IO.Stream"/> containing data for this <see cref="T:GameDevWare.Charon.Packages.Zip.ZipEntry"/></returns>
            <exception cref="T:System.ObjectDisposedException">
            The ZipFile has already been closed
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">
            The compression method for the entry is unknown
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">
            The entry is not found in the ZipFile
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.GetInputStream(System.Int64)">
            <summary>
            Creates an input stream reading a zip entry
            </summary>
            <param name="entryIndex">The index of the entry to obtain an input stream for.</param>
            <returns>
            An input <see cref="T:System.IO.Stream"/> containing data for this <paramref name="entryIndex"/>
            </returns>
            <exception cref="T:System.ObjectDisposedException">
            The ZipFile has already been closed
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">
            The compression method for the entry is unknown
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">
            The entry is not found in the ZipFile
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.TestArchive(System.Boolean)">
            <summary>
            Test an archive for integrity/validity
            </summary>
            <param name="testData">Perform low level data Crc check</param>
            <returns>true if all tests pass, false otherwise</returns>
            <remarks>Testing will terminate on the first error found.</remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.TestArchive(System.Boolean,GameDevWare.Charon.Packages.Zip.TestStrategy,GameDevWare.Charon.Packages.Zip.ZipTestResultHandler)">
            <summary>
            Test an archive for integrity/validity
            </summary>
            <param name="testData">Perform low level data Crc check</param>
            <param name="strategy">The <see cref="T:GameDevWare.Charon.Packages.Zip.TestStrategy"></see> to apply.</param>
            <param name="resultHandler">The <see cref="T:GameDevWare.Charon.Packages.Zip.ZipTestResultHandler"></see> handler to call during testing.</param>
            <returns>true if all tests pass, false otherwise</returns>
            <exception cref="T:System.ObjectDisposedException">The object has already been closed.</exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.TestLocalHeader(GameDevWare.Charon.Packages.Zip.ZipEntry,GameDevWare.Charon.Packages.Zip.ZipFile.HeaderTest)">
            <summary>
            Test a local header against that provided from the central directory
            </summary>
            <param name="entry">
            The entry to test against
            </param>
            <param name="tests">The type of <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile.HeaderTest">tests</see> to carry out.</param>
            <returns>The offset of the entries data in the file</returns>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipFile.UpdateCommand">
            <summary>
            The kind of update to apply.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.UseZip64">
            <summary>
            Get / set a value indicating how Zip64 Extension usage is determined when adding entries.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the this instance and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources;
            false to release only unmanaged resources.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.ReadLEUshort">
            <summary>
            Read an unsigned short in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
            The stream ends prematurely
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.ReadLEUint">
            <summary>
            Read a uint in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.ReadEntries">
            <summary>
            Search for and read the central directory of a zip file filling the entries array.
            </summary>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">
            The central directory is malformed or cannot be found
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.LocateEntry(GameDevWare.Charon.Packages.Zip.ZipEntry)">
            <summary>
            Locate the data for a given entry.
            </summary>
            <returns>
            The start offset of the data.
            </returns>
            <exception cref="T:System.IO.EndOfStreamException">
            The stream ends prematurely
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">
            The local header signature is invalid, the entry and central header file name lengths are different
            or the local and entry compression methods dont match
            </exception>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipFile.ZipString">
            <summary>
            Represents a string from a <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile"/> which is stored as an array of bytes.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.ZipString.#ctor(System.String)">
            <summary>
            Initialise a <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile.ZipString"/> with a string.
            </summary>
            <param name="comment">The textual string form.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.ZipString.#ctor(System.Byte[])">
            <summary>
            Initialise a <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile.ZipString"/> using a string in its binary 'raw' form.
            </summary>
            <param name="rawString"></param>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.ZipString.IsSourceString">
            <summary>
            Get a value indicating the original source of data for this instance.
            True if the source was a string; false if the source was binary data.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.ZipString.RawLength">
            <summary>
            Get the length of the comment when represented as raw bytes.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.ZipString.RawComment">
            <summary>
            Get the comment in its 'raw' form as plain bytes.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.ZipString.Reset">
            <summary>
            Reset the comment to its initial state.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.ZipString.op_Implicit(GameDevWare.Charon.Packages.Zip.ZipFile.ZipString)~System.String">
            <summary>
            Implicit conversion of comment to a string.
            </summary>
            <param name="zipString">The <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile.ZipString"/> to convert to a string.</param>
            <returns>The textual equivalent for the input value.</returns>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipFile.ZipEntryEnumerator">
            <summary>
            An <see cref="T:System.Collections.IEnumerator">enumerator</see> for <see cref="T:GameDevWare.Charon.Packages.Zip.ZipEntry">Zip entries</see>
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipFile.UncompressedStream">
            <summary>
            An <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile.UncompressedStream"/> is a stream that you can write uncompressed data
            to and flush, but cannot read, seek or do anything else to.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.UncompressedStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.UncompressedStream.Flush">
            <summary>
            Write any buffered data to underlying storage.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.UncompressedStream.CanWrite">
            <summary>
            Gets a value indicating whether the current stream supports writing.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.UncompressedStream.CanSeek">
            <summary>
            Gets a value indicating whether the current stream supports seeking.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.UncompressedStream.Length">
            <summary>
            Get the length in bytes of the stream.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.UncompressedStream.Position">
            <summary>
            Gets or sets the position within the current stream.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.UncompressedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.ArgumentException">The sum of offset and count is larger than the buffer length. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
            <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.UncompressedStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream.
            </summary>
            <param name="offset">A byte offset relative to the origin parameter.</param>
            <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"></see> indicating the reference point used to obtain the new position.</param>
            <returns>
            The new position within the current stream.
            </returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.UncompressedStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the current stream.
            </summary>
            <param name="value">The desired length of the current stream in bytes.</param>
            <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.UncompressedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support writing. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
            <exception cref="T:System.ArgumentException">The sum of offset and count is greater than the buffer length. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream">
            <summary>
            A <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream"/> is an <see cref="T:GameDevWare.Charon.Packages.Zip.Compression.Streams.InflaterInputStream"/>
            whose data is only a part or subsection of a file.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.#ctor(GameDevWare.Charon.Packages.Zip.ZipFile,System.Int64,System.Int64)">
            <summary>
            Initialise a new instance of the <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream"/> class.
            </summary>
            <param name="zipFile">The <see cref="T:GameDevWare.Charon.Packages.Zip.ZipFile"/> containing the underlying stream to use for IO.</param>
            <param name="start">The start of the partial data.</param>
            <param name="length">The length of the partial data.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.ReadByte">
            <summary>
            Read a byte from this stream.
            </summary>
            <returns>Returns the byte read or -1 on end of stream.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.ArgumentException">The sum of offset and count is larger than the buffer length. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
            <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support writing. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
            <exception cref="T:System.ArgumentNullException">buffer is null. </exception>
            <exception cref="T:System.ArgumentException">The sum of offset and count is greater than the buffer length. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.SetLength(System.Int64)">
            <summary>
            When overridden in a derived class, sets the length of the current stream.
            </summary>
            <param name="value">The desired length of the current stream in bytes.</param>
            <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            When overridden in a derived class, sets the position within the current stream.
            </summary>
            <param name="offset">A byte offset relative to the origin parameter.</param>
            <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"></see> indicating the reference point used to obtain the new position.</param>
            <returns>
            The new position within the current stream.
            </returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.Flush">
            <summary>
            Clears all buffers for this stream and causes any buffered data to be written to the underlying device.
            </summary>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.Position">
            <summary>
            Gets or sets the position within the current stream.
            </summary>
            <value></value>
            <returns>The current position within the stream.</returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.Length">
            <summary>
            Gets the length in bytes of the stream.
            </summary>
            <value></value>
            <returns>A long value representing the length of the stream in bytes.</returns>
            <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.CanWrite">
            <summary>
            Gets a value indicating whether the current stream supports writing.
            </summary>
            <value>false</value>
            <returns>true if the stream supports writing; otherwise, false.</returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.CanSeek">
            <summary>
            Gets a value indicating whether the current stream supports seeking.
            </summary>
            <value>true</value>
            <returns>true if the stream supports seeking; otherwise, false.</returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading.
            </summary>
            <value>true.</value>
            <returns>true if the stream supports reading; otherwise, false.</returns>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipFile.PartialInputStream.CanTimeout">
            <summary>
            Gets a value that determines whether the current stream can time out.
            </summary>
            <value></value>
            <returns>A value that determines whether the current stream can time out.</returns>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipHelperStream">
            <summary>
            This class assists with writing/reading from Zip files.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.#ctor(System.String)">
            <summary>
            Initialise an instance of this class.
            </summary>
            <param name="name">The name of the file to open.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.#ctor(System.IO.Stream)">
            <summary>
            Initialise a new instance of <see cref="T:GameDevWare.Charon.Packages.Zip.ZipHelperStream"/>.
            </summary>
            <param name="stream">The stream to use.</param>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipHelperStream.IsStreamOwner">
            <summary>
            Get / set a value indicating wether the the underlying stream is owned or not.
            </summary>
            <remarks>If the stream is owned it is closed when this instance is closed.</remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.Dispose(System.Boolean)">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            The underlying stream is closed only if <see cref="P:GameDevWare.Charon.Packages.Zip.ZipHelperStream.IsStreamOwner"/> is true.
            </remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.LocateBlockWithSignature(System.Int32,System.Int64,System.Int32,System.Int32)">
            <summary>
            Locates a block with the desired <paramref name="signature"/>.
            </summary>
            <param name="signature">The signature to find.</param>
            <param name="endLocation">Location, marking the end of block.</param>
            <param name="minimumBlockSize">Minimum size of the block.</param>
            <param name="maximumVariableData">The maximum variable data.</param>
            <returns>Eeturns the offset of the first byte after the signature; -1 if not found</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.WriteZip64EndOfCentralDirectory(System.Int64,System.Int64,System.Int64)">
            <summary>
            Write Zip64 end of central directory records (File header and locator).
            </summary>
            <param name="noOfEntries">The number of entries in the central directory.</param>
            <param name="sizeEntries">The size of entries in the central directory.</param>
            <param name="centralDirOffset">The offset of the dentral directory.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.WriteEndOfCentralDirectory(System.Int64,System.Int64,System.Int64,System.Byte[])">
            <summary>
            Write the required records to end the central directory.
            </summary>
            <param name="noOfEntries">The number of entries in the directory.</param>
            <param name="sizeEntries">The size of the entries in the directory.</param>
            <param name="startOfCentralDirectory">The start of the central directory.</param>
            <param name="comment">The archive comment.  (This can be null).</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.ReadLEShort">
            <summary>
            Read an unsigned short in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.ReadLEInt">
            <summary>
            Read an int in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.ReadLELong">
            <summary>
            Read a long in little endian byte order.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.WriteLEShort(System.Int32)">
            <summary>
            Write an unsigned short in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.WriteLEUshort(System.UInt16)">
            <summary>
            Write a ushort in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.WriteLEInt(System.Int32)">
            <summary>
            Write an int in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.WriteLEUint(System.UInt32)">
            <summary>
            Write a uint in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.WriteLELong(System.Int64)">
            <summary>
            Write a long in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.WriteLEUlong(System.UInt64)">
            <summary>
            Write a ulong in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.WriteDataDescriptor(GameDevWare.Charon.Packages.Zip.ZipEntry)">
            <summary>
            Write a data descriptor.
            </summary>
            <param name="entry">The entry to write a descriptor for.</param>
            <returns>Returns the number of descriptor bytes written.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipHelperStream.ReadDataDescriptor(System.Boolean,GameDevWare.Charon.Packages.Zip.DescriptorData)">
            <summary>
            Read data descriptor at the end of compressed data.
            </summary>
            <param name="zip64">if set to <c>true</c> [zip64].</param>
            <param name="data">The data to fill in.</param>
            <returns>Returns the number of bytes read in the descriptor.</returns>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipInputStream">
             <summary>
             This is an InflaterInputStream that reads the files baseInputStream an zip archive
             one after another.  It has a special method to get the zip entry of
             the next file.  The zip entry contains information about the file name
             size, compressed size, Crc, etc.
             It includes support for Stored and Deflated entries.
             <br/>
             <br/>Author of the original java version : Jochen Hoenicke
             </summary>
            
             <example> This sample shows how to read a zip file
             <code lang="C#">
             using System;
             using System.Text;
             using System.IO;
            
             using ICSharpCode.SharpZipLib.Zip;
            
             class MainClass
             {
             	public static void Main(string[] args)
             	{
             		using ( ZipInputStream s = new ZipInputStream(File.OpenRead(args[0]))) {
            
             			ZipEntry theEntry;
             			const int size = 2048;
             			byte[] data = new byte[2048];
            
             			while ((theEntry = s.GetNextEntry()) != null) {
                             if ( entry.IsFile ) {
             				    Console.Write("Show contents (y/n) ?");
             				    if (Console.ReadLine() == "y") {
             				    	while (true) {
             				    		size = s.Read(data, 0, data.Length);
             				    		if (size > 0) {
             				    			Console.Write(new ASCIIEncoding().GetString(data, 0, size));
             				    		} else {
             				    			break;
             				    		}
             				    	}
             				    }
             				}
             			}
             		}
             	}
             }
             </code>
             </example>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipInputStream.ReadDataHandler">
            <summary>
            Delegate for reading bytes from a stream.
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipInputStream.internalReader">
            <summary>
            The current reader this instance.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new Zip input stream, for reading a zip archive.
            </summary>
            <param name="baseInputStream">The underlying <see cref="T:System.IO.Stream"/> providing data.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Creates a new Zip input stream, for reading a zip archive.
            </summary>
            <param name="baseInputStream">The underlying <see cref="T:System.IO.Stream"/> providing data.</param>
            <param name="bufferSize">Size of the buffer.</param>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipInputStream.Password">
            <summary>
            Optional password used for encryption when non-null
            </summary>
            <value>A password for all encrypted <see cref="T:GameDevWare.Charon.Packages.Zip.ZipEntry">entries </see> in this <see cref="T:GameDevWare.Charon.Packages.Zip.ZipInputStream"/></value>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipInputStream.CanDecompressEntry">
            <summary>
            Gets a value indicating if there is a current entry and it can be decompressed
            </summary>
            <remarks>
            The entry can only be decompressed if the library supports the zip features required to extract it.
            See the <see cref="P:GameDevWare.Charon.Packages.Zip.ZipEntry.Version">ZipEntry Version</see> property for more details.
            </remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.GetNextEntry">
            <summary>
            Advances to the next entry in the archive
            </summary>
            <returns>
            The next <see cref="T:GameDevWare.Charon.Packages.Zip.ZipEntry">entry</see> in the archive or null if there are no more entries.
            </returns>
            <remarks>
            If the previous entry is still open <see cref="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.CloseEntry">CloseEntry</see> is called.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Input stream is closed
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">
            Password is not set, password is invalid, compression method is invalid,
            version required to extract is not supported
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.ReadDataDescriptor">
            <summary>
            Read data descriptor at the end of compressed data.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.CompleteCloseEntry(System.Boolean)">
            <summary>
            Complete cleanup as the final part of closing.
            </summary>
            <param name="testCrc">True if the crc value should be tested</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.CloseEntry">
            <summary>
            Closes the current zip entry and moves to the next one.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The stream is closed
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">
            The Zip stream ends early
            </exception>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipInputStream.Available">
            <summary>
            Returns 1 if there is an entry available
            Otherwise returns 0.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipInputStream.Length">
            <summary>
            Returns the current size that can be read from the current entry if available
            </summary>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">Thrown if the entry size is not known.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if no entry is currently available.</exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.ReadByte">
            <summary>
            Reads a byte from the current zip entry.
            </summary>
            <returns>
            The byte or -1 if end of stream is reached.
            </returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.ReadingNotAvailable(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Handle attempts to read by throwing an <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="destination">The destination array to store data in.</param>
            <param name="offset">The offset at which data read should be stored.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>Returns the number of bytes actually read.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.ReadingNotSupported(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Handle attempts to read from this entry by throwing an exception
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.InitialRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Perform the initial read on an entry which may include
            reading encryption headers and setting up inflation.
            </summary>
            <param name="destination">The destination to fill with data read.</param>
            <param name="offset">The offset to start reading at.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>The actual number of bytes read.</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a block of bytes from the stream.
            </summary>
            <param name="buffer">The destination for the bytes.</param>
            <param name="offset">The index to start storing data.</param>
            <param name="count">The number of bytes to attempt to read.</param>
            <returns>Returns the number of bytes read.</returns>
            <remarks>Zero bytes read means end of stream.</remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.BodyRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a block of bytes from the current zip entry.
            </summary>
            <returns>
            The number of bytes read (this may be less than the length requested, even before the end of stream), or 0 on end of stream.
            </returns>
            <exception name="IOException">
            An i/o error occured.
            </exception>
            <exception cref="T:GameDevWare.Charon.Packages.Zip.ZipException">
            The deflated stream is corrupted.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            The stream is not open.
            </exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipInputStream.Dispose(System.Boolean)">
            <summary>
            Closes the zip input stream
            </summary>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipStrings">
            <summary>
            This static class contains functions for encoding and decoding zip file strings
            </summary>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipStrings.codePage">
            <summary>Code page backing field</summary>
            <remarks>
            The original Zip specification (https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT) states
            that file names should only be encoded with IBM Code Page 437 or UTF-8.
            In practice, most zip apps use OEM or system encoding (typically cp437 on Windows).
            Let's be good citizens and default to UTF-8 http://utf8everywhere.org/
            </remarks>
        </member>
        <member name="F:GameDevWare.Charon.Packages.Zip.ZipStrings.AutomaticCodePage">
            Automatically select codepage while opening archive
            see https://github.com/icsharpcode/SharpZipLib/pull/280#issuecomment-433608324
            
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipStrings.CodePage">
            <summary>
            Encoding used for string conversion. Setting this to 65001 (UTF-8) will
            also set the Language encoding flag to indicate UTF-8 encoded file names.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipStrings.SystemDefaultCodePage">
            <summary>
            Attempt to get the operating system default codepage, or failing that, to
            the fallback code page IBM 437.
            </summary>
        </member>
        <member name="P:GameDevWare.Charon.Packages.Zip.ZipStrings.UseUnicode">
            <summary>
            Get wether the default codepage is set to UTF-8. Setting this property to false will
            set the <see cref="P:GameDevWare.Charon.Packages.Zip.ZipStrings.CodePage"/> to <see cref="P:GameDevWare.Charon.Packages.Zip.ZipStrings.SystemDefaultCodePage"/>
            </summary>
            <remarks>
            /// Get OEM codepage from NetFX, which parses the NLP file with culture info table etc etc.
            But sometimes it yields the special value of 1 which is nicknamed <c>CodePageNoOEM</c> in <see cref="T:System.Text.Encoding"/> sources (might also mean <c>CP_OEMCP</c>, but Encoding puts it so).
            This was observed on Ukranian and Hindu systems.
            Given this value, <see cref="M:System.Text.Encoding.GetEncoding(System.Int32)"/> throws an <see cref="T:System.ArgumentException"/>.
            So replace it with <see cref="F:GameDevWare.Charon.Packages.Zip.ZipStrings.FallbackCodePage"/>, (IBM 437 which is the default code page in a default Windows installation console.
            </remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipStrings.ConvertToString(System.Byte[],System.Int32)">
            <summary>
            Convert a portion of a byte array to a string using <see cref="P:GameDevWare.Charon.Packages.Zip.ZipStrings.CodePage"/>
            </summary>
            <param name="data">
            Data to convert to string
            </param>
            <param name="count">
            Number of bytes to convert starting from index 0
            </param>
            <returns>
            data[0]..data[count - 1] converted to a string
            </returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipStrings.ConvertToString(System.Byte[])">
            <summary>
            Convert a byte array to a string using <see cref="P:GameDevWare.Charon.Packages.Zip.ZipStrings.CodePage"/>
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipStrings.ConvertToStringExt(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert a byte array to a string  using <see cref="P:GameDevWare.Charon.Packages.Zip.ZipStrings.CodePage"/>
            </summary>
            <param name="flags">The applicable general purpose bits flags</param>
            <param name="data">
            Byte array to convert
            </param>
            <param name="count">The number of bytes to convert.</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipStrings.ConvertToStringExt(System.Int32,System.Byte[])">
            <summary>
            Convert a byte array to a string using <see cref="P:GameDevWare.Charon.Packages.Zip.ZipStrings.CodePage"/>
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <param name="flags">The applicable general purpose bits flags</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipStrings.ConvertToArray(System.String)">
            <summary>
            Convert a string to a byte array using <see cref="P:GameDevWare.Charon.Packages.Zip.ZipStrings.CodePage"/>
            </summary>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="M:GameDevWare.Charon.Packages.Zip.ZipStrings.ConvertToArray(System.Int32,System.String)">
            <summary>
            Convert a string to a byte array using <see cref="P:GameDevWare.Charon.Packages.Zip.ZipStrings.CodePage"/>
            </summary>
            <param name="flags">The applicable <see cref="T:GameDevWare.Charon.Packages.Zip.GeneralBitFlags">general purpose bits flags</see></param>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="T:GameDevWare.Charon.Packages.Zip.ZipTestResultHandler">
            <summary>
            Delegate invoked during <see cref="M:GameDevWare.Charon.Packages.Zip.ZipFile.TestArchive(System.Boolean,GameDevWare.Charon.Packages.Zip.TestStrategy,GameDevWare.Charon.Packages.Zip.ZipTestResultHandler)">testing</see> if supplied indicating current progress and status.
            </summary>
            <remarks>If the message is non-null an error has occured.  If the message is null
            the operation as found in <see cref="T:GameDevWare.Charon.Packages.Zip.TestStatus">status</see> has started.</remarks>
        </member>
        <member name="T:GameDevWare.Charon.Packages.SharpZipBaseException">
            <summary>
            SharpZipBaseException is the base exception class for SharpZipLib.
            All library exceptions are derived from this.
            </summary>
            <remarks>NOTE: Not all exceptions thrown will be derived from this class.
            A variety of other exceptions are possible for example <see cref="T:System.ArgumentNullException"></see></remarks>
        </member>
        <member name="M:GameDevWare.Charon.Packages.SharpZipBaseException.#ctor">
            <summary>
            Initializes a new instance of the SharpZipBaseException class.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.SharpZipBaseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified error message.
            </summary>
            <param name="message">A message describing the exception.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.SharpZipBaseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified
            error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">A message describing the exception.</param>
            <param name="innerException">The inner exception</param>
        </member>
        <member name="T:GameDevWare.Charon.Packages.StreamDecodingException">
            <summary>
            Indicates that an error occured during decoding of a input stream due to corrupt
            data or (unintentional) library incompability.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.StreamDecodingException.#ctor">
            <summary>
            Initializes a new instance of the StreamDecodingException with a generic message
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.StreamDecodingException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the StreamDecodingException class with a specified error message.
            </summary>
            <param name="message">A message describing the exception.</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.StreamDecodingException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the StreamDecodingException class with a specified
            error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">A message describing the exception.</param>
            <param name="innerException">The inner exception</param>
        </member>
        <member name="T:GameDevWare.Charon.Packages.ValueOutOfRangeException">
            <summary>
            Indicates that a value was outside of the expected range when decoding an input stream
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.ValueOutOfRangeException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ValueOutOfRangeException class naming the the causing variable
            </summary>
            <param name="nameOfValue">Name of the variable, use: nameof()</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.ValueOutOfRangeException.#ctor(System.String,System.Int64,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the ValueOutOfRangeException class naming the the causing variable,
            it's current value and expected range.
            </summary>
            <param name="nameOfValue">Name of the variable, use: nameof()</param>
            <param name="value">The invalid value</param>
            <param name="maxValue">Expected maximum value</param>
            <param name="minValue">Expected minimum value</param>
        </member>
        <member name="M:GameDevWare.Charon.Packages.ValueOutOfRangeException.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the ValueOutOfRangeException class naming the the causing variable,
            it's current value and expected range.
            </summary>
            <param name="nameOfValue">Name of the variable, use: nameof()</param>
            <param name="value">The invalid value</param>
            <param name="maxValue">Expected maximum value</param>
            <param name="minValue">Expected minimum value</param>
        </member>
        <member name="T:GameDevWare.Charon.Packages.StreamUtils">
            <summary>
            Provides simple <see cref="T:System.IO.Stream"/>" utilities.
            </summary>
        </member>
        <member name="M:GameDevWare.Charon.Packages.StreamUtils.ReadFully(System.IO.Stream,System.Byte[])">
            <summary>
            Read from a <see cref="T:System.IO.Stream"/> ensuring all the required data is read.
            </summary>
            <param name="stream">The stream to read.</param>
            <param name="buffer">The buffer to fill.</param>
            <seealso cref="M:GameDevWare.Charon.Packages.StreamUtils.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:GameDevWare.Charon.Packages.StreamUtils.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from a <see cref="T:System.IO.Stream"/>" ensuring all the required data is read.
            </summary>
            <param name="stream">The stream to read data from.</param>
            <param name="buffer">The buffer to store data in.</param>
            <param name="offset">The offset at which to begin storing data.</param>
            <param name="count">The number of bytes of data to store.</param>
            <exception cref="T:System.ArgumentNullException">Required parameter is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> and or <paramref name="count"/> are invalid.</exception>
            <exception cref="T:System.IO.EndOfStreamException">End of stream is encountered before all the data has been read.</exception>
        </member>
        <member name="M:GameDevWare.Charon.Packages.StreamUtils.Copy(System.IO.Stream,System.IO.Stream,System.Byte[])">
            <summary>
            Copy the contents of one <see cref="T:System.IO.Stream"/> to another.
            </summary>
            <param name="source">The stream to source data from.</param>
            <param name="destination">The stream to write data to.</param>
            <param name="buffer">The buffer to use during copying.</param>
        </member>
        <member name="M:GameDevWare.Charon.Utils.NoCertificateValidationContext.Dispose">
            <inheritdoc />
        </member>
        <member name="M:GameDevWare.Charon.Utils.CommandInput.Finalize">
            <inheritdoc />
        </member>
        <member name="M:GameDevWare.Charon.Utils.CommandInput.ReleaseUnmanagedResources">
            <inheritdoc />
        </member>
        <member name="M:GameDevWare.Charon.Utils.CommandInput.Dispose">
            <inheritdoc />
        </member>
    </members>
</doc>
